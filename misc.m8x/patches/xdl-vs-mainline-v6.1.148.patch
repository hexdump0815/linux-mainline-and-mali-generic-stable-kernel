just in case i should at any point in time try to create a v6.1 m8x tree
this diff might be a good start - it seems to apply cleanly to v6.1 and
should contain everything for meson8 not yet in mainline

this patch has been created via:

cd /compile/source/linux-stable-repo/
git pull
git worktree add ../linux-stable-xdl v6.2-rc1
cd ../linux-stable-xdl/
git remote add xdl https://github.com/xdarklight/linux.git
git remote update
git diff v6.2-rc1 remotes/xdl/meson-mx-integration-6.2-20221226

diff --git a/Documentation/devicetree/bindings/arm/amlogic.yaml b/Documentation/devicetree/bindings/arm/amlogic.yaml
index e16b5fa55847..18eb1786963d 100644
--- a/Documentation/devicetree/bindings/arm/amlogic.yaml
+++ b/Documentation/devicetree/bindings/arm/amlogic.yaml
@@ -35,12 +35,15 @@ properties:
         items:
           - enum:
               - minix,neo-x8
+              - tronsmart,s82
           - const: amlogic,meson8
 
       - description: Boards with the Amlogic Meson8m2 SoC
         items:
           - enum:
+              - tronsmart,mxiii
               - tronsmart,mxiii-plus
+              - wetek,core
           - const: amlogic,meson8m2
 
       - description: Boards with the Amlogic Meson8b SoC
diff --git a/Documentation/devicetree/bindings/arm/cpus.yaml b/Documentation/devicetree/bindings/arm/cpus.yaml
index 01b5a9c689a2..2950b2ce8352 100644
--- a/Documentation/devicetree/bindings/arm/cpus.yaml
+++ b/Documentation/devicetree/bindings/arm/cpus.yaml
@@ -204,6 +204,7 @@ properties:
           - allwinner,sun9i-a80-smp
           - allwinner,sun8i-a83t-smp
           - amlogic,meson8-smp
+          - amlogic,meson8-trustzone-firmware-smp
           - amlogic,meson8b-smp
           - arm,realview-smp
           - aspeed,ast2600-smp
diff --git a/Documentation/devicetree/bindings/clock/amlogic,meson8b-clkc.txt b/Documentation/devicetree/bindings/clock/amlogic,meson8b-clkc.txt
index cc51e4746b3b..8559315097de 100644
--- a/Documentation/devicetree/bindings/clock/amlogic,meson8b-clkc.txt
+++ b/Documentation/devicetree/bindings/clock/amlogic,meson8b-clkc.txt
@@ -16,6 +16,10 @@ Required Properties:
   * "xtal": the 24MHz system oscillator
   * "ddr_pll": the DDR PLL clock
   * "clk_32k": (if present) the 32kHz clock signal from GPIOAO_6 (CLK_32K_IN)
+  * "rmii_clk": (if present) the 50MHz RMII reference clock (from the PHY or
+                an external oscillator
+  * "rtc_32k": the clock signal from the 32kHz oscillator connected to the
+               RTC32K_XI and RTC32K_XO pads
 
 Parent node should have the following properties :
 - compatible: "amlogic,meson-hhi-sysctrl", "simple-mfd", "syscon"
diff --git a/Documentation/devicetree/bindings/display/amlogic,meson-vpu.yaml b/Documentation/devicetree/bindings/display/amlogic,meson-vpu.yaml
index 6655a93b1874..bbc58c8bdfc2 100644
--- a/Documentation/devicetree/bindings/display/amlogic,meson-vpu.yaml
+++ b/Documentation/devicetree/bindings/display/amlogic,meson-vpu.yaml
@@ -66,8 +66,12 @@ properties:
           - const: amlogic,meson-gx-vpu
       - enum:
           - amlogic,meson-g12a-vpu # G12A (S905X2, S905Y2, S905D2)
+          - amlogic,meson8-vpu
+          - amlogic,meson8b-vpu
+          - amlogic,meson8m2-vpu
 
   reg:
+    minItems: 1
     maxItems: 2
 
   reg-names:
@@ -82,6 +86,15 @@ properties:
     description: should point to a canvas provider node
     $ref: /schemas/types.yaml#/definitions/phandle
 
+  phys:
+    maxItems: 1
+    description:
+      PHY specifier for the CVBS DAC
+
+  phy-names:
+    items:
+      - const: cvbs-dac
+
   power-domains:
     maxItems: 1
     description: phandle to the associated power domain
@@ -125,6 +138,9 @@ examples:
         #size-cells = <0>;
         amlogic,canvas = <&canvas>;
 
+        phys = <&cvbs_dac_phy>;
+        phy-names = "cvbs-dac";
+
         /* CVBS VDAC output port */
         port@0 {
             reg = <0>;
diff --git a/Documentation/devicetree/bindings/firmware/meson/amlogic,meson-mx-trustzone-firmware.yaml b/Documentation/devicetree/bindings/firmware/meson/amlogic,meson-mx-trustzone-firmware.yaml
new file mode 100644
index 000000000000..1e0e19a35473
--- /dev/null
+++ b/Documentation/devicetree/bindings/firmware/meson/amlogic,meson-mx-trustzone-firmware.yaml
@@ -0,0 +1,47 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+# Copyright 2021 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+%YAML 1.2
+---
+$id: "http://devicetree.org/schemas/firmware/meson/amlogic,meson-mx-trustzone-firmware.yaml#"
+$schema: "http://devicetree.org/meta-schemas/core.yaml#"
+
+title: Amlogic Meson6/8/8b/8m2 TrustZone secure firmware
+
+description: |
+  Amlogic Meson6/8/8b/8m2 SoCs can optionally use a TrustZone secure
+  firmware. This prevents anything outside of the TEE (Trusted
+  Execution Environment aka TrustZone secure firmware) from accessing
+  certain functionality of these SoCs, such as (but not limited to):
+  Bringing up/down secondary SMP cores, accessing the eFuse and getting
+  the SoC misc version.
+  ARM SMCCC is used for communication with the TrustZone secure
+  firmware.
+
+maintainers:
+  - Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+
+properties:
+  compatible:
+    oneOf:
+      - items:
+          - enum:
+              - amlogic,meson6-trustzone-firmware
+              - amlogic,meson8-trustzone-firmware
+              - amlogic,meson8b-trustzone-firmware
+              - amlogic,meson8m2-trustzone-firmware
+          - const: amlogic,meson-mx-trustzone-firmware
+
+required:
+  - compatible
+
+additionalProperties: false
+
+examples:
+  - |
+    firmware {
+      trustzone-firmware {
+        compatible = "amlogic,meson8m2-trustzone-firmware",
+                     "amlogic,meson-mx-trustzone-firmware";
+      };
+    };
+...
diff --git a/Documentation/devicetree/bindings/mtd/amlogic,meson-nand.yaml b/Documentation/devicetree/bindings/mtd/amlogic,meson-nand.yaml
index 28fb9a7dd70f..a0b478adf33f 100644
--- a/Documentation/devicetree/bindings/mtd/amlogic,meson-nand.yaml
+++ b/Documentation/devicetree/bindings/mtd/amlogic,meson-nand.yaml
@@ -6,19 +6,21 @@ $schema: http://devicetree.org/meta-schemas/core.yaml#
 
 title: Amlogic NAND Flash Controller (NFC) for GXBB/GXL/AXG family SoCs
 
-allOf:
-  - $ref: nand-controller.yaml
-
 maintainers:
   - liang.yang@amlogic.com
 
 properties:
   compatible:
     enum:
+      - amlogic,meson8-nfc
+      - amlogic,meson8b-nfc
+      - amlogic,meson8m2-nfc
+      - amlogic,meson-gxbb-nfc
       - amlogic,meson-gxl-nfc
       - amlogic,meson-axg-nfc
 
   reg:
+    minItems: 1
     maxItems: 2
 
   reg-names:
@@ -33,9 +35,13 @@ properties:
     minItems: 2
 
   clock-names:
-    items:
-      - const: core
-      - const: device
+    oneOf:
+      - items:
+          - const: core
+          - const: device
+      - items:
+          - const: core
+          - const: nand
 
 patternProperties:
   "^nand@[0-7]$":
@@ -55,9 +61,18 @@ patternProperties:
         enum: [8, 16, 24, 30, 40, 50, 60]
         description: |
           The ECC configurations that can be supported are as follows.
-            meson-gxl-nfc 8, 16, 24, 30, 40, 50, 60
+            meson8/8b/8m2/gxbb/gxl-nfc 8, 16, 24, 30, 40, 50, 60
             meson-axg-nfc 8
 
+allOf:
+  - $ref: nand-controller.yaml
+
+  - if:
+      properties:
+        compatible:
+          contains:
+            const: amlogic,meson-axg-nfc
+
 required:
   - compatible
   - reg
@@ -85,6 +100,25 @@ examples:
       #address-cells = <1>;
       #size-cells = <0>;
 
+      nand@0 {
+        reg = <0>;
+      };
+    };
+  - |
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    nand-controller@48600 {
+      compatible = "amlogic,meson8b-nfc";
+      reg = <0x48600 0x24>;
+      interrupts = <GIC_SPI 34 IRQ_TYPE_EDGE_RISING>;
+      clocks = <&nand_pclk>, <&nand_clock>;
+      clock-names = "core", "nand";
+
+      pinctrl-0 = <&nand_pins>;
+      pinctrl-names = "default";
+
+      #address-cells = <1>;
+      #size-cells = <0>;
+
       nand@0 {
         reg = <0>;
       };
diff --git a/Documentation/devicetree/bindings/net/amlogic,meson-dwmac.yaml b/Documentation/devicetree/bindings/net/amlogic,meson-dwmac.yaml
index ddd5a073c3a8..d3bf6b1f3f39 100644
--- a/Documentation/devicetree/bindings/net/amlogic,meson-dwmac.yaml
+++ b/Documentation/devicetree/bindings/net/amlogic,meson-dwmac.yaml
@@ -127,6 +127,28 @@ allOf:
             - 2800
             - 3000
 
+  - if:
+      properties:
+        compatible:
+          contains:
+            enum:
+              - amlogic,meson6-dwmac
+    then:
+      properties:
+        clocks:
+          minItems: 1
+          maxItems: 2
+          items:
+            - description: GMAC main clock
+            - description: The RMII reference clock
+
+        clock-names:
+          minItems: 1
+          maxItems: 2
+          items:
+            - const: stmmaceth
+            - const: ethernet
+
 properties:
   compatible:
     additionalItems: true
diff --git a/Documentation/devicetree/bindings/net/realtek,rtl8211f.yaml b/Documentation/devicetree/bindings/net/realtek,rtl8211f.yaml
new file mode 100644
index 000000000000..d62b24f27175
--- /dev/null
+++ b/Documentation/devicetree/bindings/net/realtek,rtl8211f.yaml
@@ -0,0 +1,75 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: "http://devicetree.org/schemas/net/realtek,rtl8211f.yaml#"
+$schema: "http://devicetree.org/meta-schemas/core.yaml#"
+
+title: Realtek RTL8211F Ethernet PHY
+
+maintainers:
+  - Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+
+description: |
+  The Realtek RTL8211F-CG/RTL8211FI-CG is a highly integrated Ethernet
+  transceiver that is compatible with 10Base-T, 100Base-TX, and 1000Base-T
+  IEEE 802.3 standards. It provides all the necessary physical layer
+  functions to transmit and receive Ethernet packets over CAT.5 UTP cable.
+  The RTL8211FI-CG is manufactured to industrial grade standards.
+
+  The RTL8211F(I)-CG uses state-of-the-art DSP technology and an Analog
+  Front End (AFE) to enable high-speed data transmission and reception over
+  UTP cable. Functions such as Crossover Detection & Auto-Correction,
+  polarity correction, adaptive equalization, cross-talk cancellation,
+  echo cancellation, timing recovery, and error correction are implemented
+  in the RTL8211F(I)-CG to provide robust transmission and reception
+  capabilities at 10Mbps, 100Mbps, or 1000Mbps.
+
+  Data transfer between MAC and PHY is via the Reduced Gigabit Media
+  Independent Interface (RGMII) for 1000Base-T, 10Base-T, and 100Base-TX.
+  The RTL8211F(I)-CG supports various RGMII signaling voltages, including
+  3.3V, 2.5V, 1.8V, and 1.5V.
+
+  The RTL8211F(I)-CG incorporates a state-of-the-art switching regulator that
+  requires a well-designed PCB layout in order to achieve good power efficiency
+  and lower the output voltage ripple and input overshoot.
+
+allOf:
+  - $ref: ethernet-phy.yaml#
+
+properties:
+  realtek,led-0-mode:
+    $ref: /schemas/types.yaml#definitions/uint32
+    description: |
+       LED0 configuration; see the RTL8211F_LED_* values from
+       <dt-bindings/net/realtek-rtl8211f.h>
+
+  realtek,led-1-mode:
+    $ref: /schemas/types.yaml#definitions/uint32
+    description: |
+       LED1 configuration; see the RTL8211F_LED_* values from
+       <dt-bindings/net/realtek-rtl8211f.h>
+
+  realtek,led-2-mode:
+    $ref: /schemas/types.yaml#definitions/uint32
+    description: |
+       LED2 configuration; see the RTL8211F_LED_* values from
+       <dt-bindings/net/realtek-rtl8211f.h>
+
+required:
+  - reg
+
+examples:
+  - |
+    #include <dt-bindings/net/realtek-rtl8211f.h>
+
+    mdio {
+      #address-cells = <1>;
+      #size-cells = <0>;
+
+      ethernet-phy@0 {
+        reg = <0>;
+        realtek,led-0-mode = <0>;
+        realtek,led-1-mode = <(RTL8211F_LED_LINK_100 | RTL8211F_LED_ACTIVITY | RTL8211F_LED_EEE)>;
+        realtek,led-2-mode = <(RTL8211F_LED_LINK_1000 | RTL8211F_LED_ACTIVITY | RTL8211F_LED_EEE)>;
+      };
+    };
diff --git a/Documentation/devicetree/bindings/phy/amlogic,meson-cvbs-dac-phy.yaml b/Documentation/devicetree/bindings/phy/amlogic,meson-cvbs-dac-phy.yaml
new file mode 100644
index 000000000000..d73cb12c0d9f
--- /dev/null
+++ b/Documentation/devicetree/bindings/phy/amlogic,meson-cvbs-dac-phy.yaml
@@ -0,0 +1,81 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: "http://devicetree.org/schemas/phy/amlogic,meson-cvbs-dac-phy.yaml#"
+$schema: "http://devicetree.org/meta-schemas/core.yaml#"
+
+title: Amlogic Meson Composite Video Baseband Signal DAC
+
+maintainers:
+  - Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+
+description: |+
+  The CVBS DAC node should be the child of a syscon node with the
+  required property:
+
+  compatible = "amlogic,meson-hhi-sysctrl", "simple-mfd", "syscon"
+
+  Refer to the bindings described in
+  Documentation/devicetree/bindings/mfd/syscon.yaml
+
+properties:
+  $nodename:
+    pattern: "^video-dac@[0-9a-f]+$"
+
+  compatible:
+    oneOf:
+      - items:
+          - enum:
+              - amlogic,meson8-cvbs-dac
+              - amlogic,meson-gxbb-cvbs-dac
+              - amlogic,meson-gxl-cvbs-dac
+              - amlogic,meson-g12a-cvbs-dac
+          - const: amlogic,meson-cvbs-dac
+      - const: amlogic,meson-cvbs-dac
+
+  reg:
+    maxItems: 1
+
+  clocks:
+    minItems: 1
+
+  nvmem-cells:
+    minItems: 1
+
+  nvmem-cell-names:
+    items:
+      - const: cvbs_trimming
+
+  "#phy-cells":
+    const: 0
+
+required:
+  - compatible
+  - reg
+  - clocks
+  - "#phy-cells"
+
+additionalProperties: false
+
+examples:
+  - |
+    video-dac@2f4 {
+      compatible = "amlogic,meson8-cvbs-dac", "amlogic,meson-cvbs-dac";
+      reg = <0x2f4 0x8>;
+
+      #phy-cells = <0>;
+
+      clocks = <&vdac_clock>;
+
+      nvmem-cells = <&cvbs_trimming>;
+      nvmem-cell-names = "cvbs_trimming";
+    };
+  - |
+    video-dac@2ec {
+      compatible = "amlogic,meson-g12a-cvbs-dac", "amlogic,meson-cvbs-dac";
+      reg = <0x2ec 0x8>;
+
+      #phy-cells = <0>;
+
+      clocks = <&vdac_clock>;
+    };
diff --git a/Documentation/devicetree/bindings/phy/amlogic,meson8b-usb2-phy.yaml b/Documentation/devicetree/bindings/phy/amlogic,meson8b-usb2-phy.yaml
index 03c4809dbe8d..c354919c01bc 100644
--- a/Documentation/devicetree/bindings/phy/amlogic,meson8b-usb2-phy.yaml
+++ b/Documentation/devicetree/bindings/phy/amlogic,meson8b-usb2-phy.yaml
@@ -6,6 +6,12 @@ $schema: "http://devicetree.org/meta-schemas/core.yaml#"
 
 title: Amlogic Meson8, Meson8b, Meson8m2 and GXBB USB2 PHY
 
+description: |
+  Amlogic Meson8, Meson8b, Meson8m2 and GXBB embed two USB2 PHYs.
+  Typically the USB "ID" signal (used for dual role operation) is
+  routed to the first PHY. In that case the value can be read out
+  as a GPIO.
+
 maintainers:
   - Martin Blumenstingl <martin.blumenstingl@googlemail.com>
 
@@ -31,6 +37,11 @@ properties:
       - const: usb_general
       - const: usb
 
+  '#gpio-cells':
+    const: 2
+
+  gpio-controller: true
+
   resets:
     minItems: 1
 
diff --git a/Documentation/devicetree/bindings/sound/cirrus,cs4334.yaml b/Documentation/devicetree/bindings/sound/cirrus,cs4334.yaml
new file mode 100644
index 000000000000..3941dda1442f
--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/cirrus,cs4334.yaml
@@ -0,0 +1,42 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/sound/cirrus,cs4334.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+
+title: Cirrus CS4334 - or functionally compatible - I2S Stereo DACs
+
+maintainers:
+  - Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+
+description: |
+  Cirrus CS4334 16-24 bit stereo DAC with I2S input.
+  https://statics.cirrus.com/pubs/proDatasheet/CS4334-5-8-9_F7.pdf
+  http://www.mxtronics.com/n107/n124/n181/n184/c697/attr/2625.pdf
+
+properties:
+  compatible:
+    enum:
+      - cirrus,cs4334
+      - mxtronics,mxt8234
+
+  "#sound-dai-cells":
+    const: 0
+
+  VDD-supply:
+    description:
+      Regulator for the codec voltage supply
+
+required:
+  - compatible
+  - "#sound-dai-cells"
+  - VDD-supply
+
+examples:
+  - |
+     audio-codec {
+         compatible = "mxtronics,mxt8234";
+         #sound-dai-cells = <0>;
+         VDD-supply = <&codec_vdd>;
+     };
diff --git a/Documentation/devicetree/bindings/usb/etron,ej1x8.yaml b/Documentation/devicetree/bindings/usb/etron,ej1x8.yaml
new file mode 100644
index 000000000000..0fbb2ffd0a25
--- /dev/null
+++ b/Documentation/devicetree/bindings/usb/etron,ej1x8.yaml
@@ -0,0 +1,49 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/usb/etron,ej1x8.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: EJ168/EJ188/EJ198 xHCI controllers with four GPIO lines
+
+maintainers:
+  - Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+
+allOf:
+  - $ref: "usb-hcd.yaml#"
+
+properties:
+  compatible:
+    enum:
+      - pci1b6f,7023
+      - pci1b6f,7052
+
+  reg:
+    maxItems: 1
+
+  "#gpio-cells":
+    const: 2
+
+  gpio-controller: true
+
+required:
+  - compatible
+  - reg
+
+additionalProperties: false
+
+examples:
+  - |
+      pcie {
+        #address-cells = <3>;
+        #size-cells = <2>;
+
+        usb@0,0,0 {
+          compatible = "pci1b6f,7023";
+          reg = <0x0 0x0 0x0 0x0 0x1000>;
+          gpio-controller;
+          #gpio-cells = <2>;
+        };
+      };
+
+...
diff --git a/Documentation/devicetree/bindings/vendor-prefixes.yaml b/Documentation/devicetree/bindings/vendor-prefixes.yaml
index 70ffb3780621..f177c94c6d6d 100644
--- a/Documentation/devicetree/bindings/vendor-prefixes.yaml
+++ b/Documentation/devicetree/bindings/vendor-prefixes.yaml
@@ -877,6 +877,8 @@ patternProperties:
     deprecated: true
   "^mxicy,.*":
     description: Macronix International Co., Ltd.
+  "^mxtronics,.*":
+    description: Beijing Times Minxin Technology Co., Ltd.
   "^myir,.*":
     description: MYIR Tech Limited
   "^national,.*":
diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index d08a3c450ce7..2c23cb43813e 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -401,10 +401,14 @@ dtb-$(CONFIG_MACH_MESON6) += \
 	meson6-atv1200.dtb
 dtb-$(CONFIG_MACH_MESON8) += \
 	meson8-minix-neo-x8.dtb \
+	meson8-tronsmart-s82.dtb \
 	meson8b-ec100.dtb \
 	meson8b-mxq.dtb \
 	meson8b-odroidc1.dtb \
-	meson8m2-mxiii-plus.dtb
+	meson8m2-mxiii.dtb \
+	meson8m2-mxiii-plus.dtb \
+	meson8m2-m8s.dtb \
+	meson8m2-wetek-core.dtb
 dtb-$(CONFIG_ARCH_MMP) += \
 	pxa168-aspenite.dtb \
 	pxa910-dkb.dtb \
diff --git a/arch/arm/boot/dts/meson.dtsi b/arch/arm/boot/dts/meson.dtsi
index 8e3860d5d916..b95adb9a2237 100644
--- a/arch/arm/boot/dts/meson.dtsi
+++ b/arch/arm/boot/dts/meson.dtsi
@@ -35,6 +35,19 @@ hhi: system-controller@4000 {
 					     "simple-mfd",
 					     "syscon";
 				reg = <0x4000 0x400>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0x0 0x4000 0x400>;
+
+
+				cvbs_dac: video-dac@2f4 {
+					compatible = "amlogic,meson-cvbs-dac";
+					reg = <0x2f4 0x8>;
+
+					#phy-cells = <0>;
+
+					status = "disabled";
+				};
 			};
 
 			aiu: audio-controller@5400 {
@@ -124,6 +137,8 @@ usb0_phy: phy@8800 {
 				compatible = "amlogic,meson-mx-usb2-phy";
 				#phy-cells = <0>;
 				reg = <0x8800 0x20>;
+				gpio-controller;
+				#gpio-cells = <2>;
 				status = "disabled";
 			};
 
diff --git a/arch/arm/boot/dts/meson6.dtsi b/arch/arm/boot/dts/meson6.dtsi
index 4716030a48d0..c63b769a23e9 100644
--- a/arch/arm/boot/dts/meson6.dtsi
+++ b/arch/arm/boot/dts/meson6.dtsi
@@ -28,6 +28,18 @@ cpu@201 {
 		};
 	};
 
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		/* 1 MiB reserved for Hardware ROM Firmware */
+		hwrom@0 {
+			reg = <0x1ff00000 0x100000>;
+			no-map;
+		};
+	};
+
 	apb2: bus@d0000000 {
 		compatible = "simple-bus";
 		reg = <0xd0000000 0x40000>;
diff --git a/arch/arm/boot/dts/meson8-tronsmart-s82.dts b/arch/arm/boot/dts/meson8-tronsmart-s82.dts
new file mode 100644
index 000000000000..b24f3ab6e5aa
--- /dev/null
+++ b/arch/arm/boot/dts/meson8-tronsmart-s82.dts
@@ -0,0 +1,403 @@
+// SPDX-License-Identifier: GPL-2.0 OR MIT
+/*
+ * Copyright 2021 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ */
+
+/dts-v1/;
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/leds/common.h>
+#include "meson8.dtsi"
+
+/ {
+	model = "Tronsmart S82";
+	compatible = "tronsmart,s82", "amlogic,meson8";
+
+	aliases {
+		serial0 = &uart_AO;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x40000000 0x80000000>;
+	};
+
+	cvbs-connector {
+		compatible = "composite-video-connector";
+
+		port {
+			cvbs_connector_in: endpoint {
+				remote-endpoint = <&cvbs_vdac_out>;
+			};
+		};
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+
+		blue {
+			function = LED_FUNCTION_STATUS;
+			default-state = "on";
+			gpios = <&gpio_ao GPIO_TEST_N GPIO_ACTIVE_HIGH>;
+		};
+	};
+
+	hdmi-connector {
+		compatible = "hdmi-connector";
+		type = "a";
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&hdmi_tx_tmds_out>;
+			};
+		};
+	};
+
+	sdio_pwrseq: sdio-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+
+		pinctrl-0 = <&xtal_32k_out_pins>;
+		pinctrl-names = "default";
+
+		reset-gpios = <&gpio GPIOX_11 GPIO_ACTIVE_LOW>,
+			      <&gpio_ao GPIOAO_6 GPIO_ACTIVE_LOW>;
+
+/*
+	TODO:
+		clocks = <&xtal_32k_out>;
+		clock-names = "ext_clock";
+*/
+	};
+
+	sound {
+		compatible = "amlogic,gx-sound-card";
+		model = "TRONSMART-S82";
+
+		assigned-clocks = <&clkc CLKID_MPLL0>,
+				  <&clkc CLKID_MPLL1>,
+				  <&clkc CLKID_MPLL2>;
+		assigned-clock-rates = <294912000>,
+				       <270950400>,
+				       <393216000>;
+
+		dai-link-0 {
+			sound-dai = <&aiu AIU_CPU CPU_I2S_FIFO>;
+		};
+
+		dai-link-1 {
+			sound-dai = <&aiu AIU_CPU CPU_SPDIF_FIFO>;
+		};
+
+		dai-link-2 {
+			sound-dai = <&aiu AIU_CPU CPU_I2S_ENCODER>;
+			dai-format = "i2s";
+			mclk-fs = <256>;
+
+			codec-0 {
+				sound-dai = <&aiu AIU_HDMI CTRL_I2S>;
+			};
+		};
+
+		dai-link-3 {
+			sound-dai = <&aiu AIU_HDMI CTRL_OUT>;
+
+			codec-0 {
+				sound-dai = <&hdmi_tx 0>;
+			};
+		};
+
+		dai-link-4 {
+			sound-dai = <&aiu AIU_CPU CPU_SPDIF_ENCODER>;
+
+			codec-0 {
+				sound-dai = <&spdif_dit>;
+			};
+
+			codec-1 {
+				sound-dai = <&hdmi_tx 1>;
+			};
+		};
+	};
+
+	spdif_dit: spdif-audio-codec {
+		compatible = "linux,spdif-dit";
+		#sound-dai-cells = <0>;
+		sound-name-prefix = "DIT";
+	};
+
+	usb_vbus: regulator-usb-vbus {
+		compatible = "regulator-fixed";
+
+		regulator-name = "USB_VBUS";
+
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+
+		gpio = <&gpio GPIOZ_1 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
+	vcc_3v3: regulator-vcc3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "VCC3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+};
+
+&aiu {
+	status = "okay";
+
+	pinctrl-0 = <&i2s_am_clk_pins>, <&i2s_out_ao_clk_pins>,
+		    <&i2s_out_lr_clk_pins>, <&i2s_out_ch01_ao_pins>,
+		    <&spdif_out_pins>;
+	pinctrl-names = "default";
+};
+
+&cpu0 {
+	cpu-supply = <&vcck>;
+};
+
+&cvbs_vdac_port {
+	cvbs_vdac_out: endpoint {
+		remote-endpoint = <&cvbs_connector_in>;
+	};
+};
+
+&ethmac {
+	status = "okay";
+
+	pinctrl-0 = <&eth_pins>;
+	pnictrl-names = "default";
+
+	phy-handle = <&eth_phy0>;
+	phy-mode = "rmii";
+
+	mdio {
+		compatible = "snps,dwmac-mdio";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		eth_phy0: ethernet-phy@0 {
+			/* IC Plus IP101A/G (0x02430c54) */
+			reg = <0>;
+		};
+	};
+};
+
+&hdmi_tx {
+	status = "okay";
+	pinctrl-0 = <&hdmi_hpd_pins>, <&hdmi_i2c_pins>;
+	pinctrl-names = "default";
+};
+
+&hdmi_tx_tmds_port {
+	hdmi_tx_tmds_out: endpoint {
+		remote-endpoint = <&hdmi_connector_in>;
+	};
+};
+
+&ir_receiver {
+	status = "okay";
+	pinctrl-0 = <&ir_recv_pins>;
+	pinctrl-names = "default";
+};
+
+&i2c_AO {
+	status = "okay";
+	pinctrl-0 = <&i2c_ao_pins>;
+	pinctrl-names = "default";
+
+	pmic@32 {
+		compatible = "ricoh,rn5t618";
+		reg = <0x32>;
+		system-power-controller;
+
+		regulators {
+			vcck: DCDC1 {
+				regulator-name = "VCCK";
+				regulator-min-microvolt = <825000>;
+				regulator-max-microvolt = <1150000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vddee: DCDC2 {
+				/* the output is also used as VDDAO */
+				regulator-name = "VDD_EE";
+				regulator-min-microvolt = <950000>;
+				regulator-max-microvolt = <1150000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			DCDC3 {
+				regulator-name = "VDD_DDR";
+				regulator-min-microvolt = <1500000>;
+				regulator-max-microvolt = <1500000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			LDO1 {
+				regulator-name = "VDDIO_AO28";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vddio_ao1v8: LDO2 {
+				regulator-name = "VDDIO_AO18";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			LDO3 {
+				regulator-name = "VCC1V8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			LDO4 {
+				regulator-name = "VCC2V8";
+				regulator-min-microvolt = <2850000>;
+				regulator-max-microvolt = <2850000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			LDO5 {
+				regulator-name = "AVDD1V8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			LDORTC1 {
+				regulator-name = "VDD_LDO";
+				regulator-min-microvolt = <2700000>;
+				regulator-max-microvolt = <2700000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			LDORTC2 {
+				regulator-name = "RTC_0V9";
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+		};
+	};
+};
+
+&mali {
+	mali-supply = <&vddee>;
+};
+
+&saradc {
+	status = "okay";
+	vref-supply = <&vddio_ao1v8>;
+};
+
+/* SDIO wifi */
+&sdhc {
+	status = "okay";
+
+	pinctrl-0 = <&sdxc_a_pins>;
+	pinctrl-names = "default";
+
+	bus-width = <4>;
+	max-frequency = <50000000>;
+
+	disable-wp;
+	non-removable;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+
+	mmc-pwrseq = <&sdio_pwrseq>;
+
+	vmmc-supply = <&vcc_3v3>;
+	vqmmc-supply = <&vcc_3v3>;
+};
+
+/* SD card */
+&sdio {
+	status = "okay";
+
+	pinctrl-0 = <&sd_b_pins>;
+	pinctrl-names = "default";
+
+	slot@1 {
+		compatible = "mmc-slot";
+		reg = <1>;
+
+		bus-width = <4>;
+		max-frequency = <50000000>;
+
+		no-mmc;
+		no-sdio;
+		cap-sd-highspeed;
+		disable-wp;
+
+		cd-gpios = <&gpio CARD_6 GPIO_ACTIVE_LOW>;
+
+		vmmc-supply = <&vcc_3v3>;
+	};
+};
+
+&uart_A {
+	status = "okay";
+
+	pinctrl-0 = <&uart_a1_pins>, <&uart_a1_cts_rts_pins>;
+	pinctrl-names = "default";
+	uart-has-rtscts;
+
+	bluetooth {
+		compatible = "brcm,bcm20702a1";
+		reset-gpios = <&gpio GPIOX_20 GPIO_ACTIVE_LOW>;
+		max-speed = <2000000>;
+	};
+};
+
+&uart_AO {
+	status = "okay";
+	pinctrl-0 = <&uart_ao_a_pins>;
+	pinctrl-names = "default";
+};
+
+&usb0 {
+	status = "okay";
+
+	dr_mode = "otg";
+	usb-role-switch;
+
+	connector {
+		compatible = "gpio-usb-b-connector", "usb-b-connector";
+		type = "micro";
+		id-gpios = <&usb0_phy 0 GPIO_ACTIVE_HIGH>;
+		vbus-supply = <&usb_vbus>;
+	};
+};
+
+&usb1 {
+	status = "okay";
+};
+
+&usb0_phy {
+	status = "okay";
+};
+
+&usb1_phy {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/meson8.dtsi b/arch/arm/boot/dts/meson8.dtsi
index 0f8bac8bac8b..821d01333577 100644
--- a/arch/arm/boot/dts/meson8.dtsi
+++ b/arch/arm/boot/dts/meson8.dtsi
@@ -193,6 +193,14 @@ power-firmware@4f00000 {
 			reg = <0x4f00000 0x100000>;
 			no-map;
 		};
+
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x10000000>;
+			alignment = <0x400000>;
+			linux,cma-default;
+		};
 	};
 
 	thermal-zones {
@@ -314,6 +322,124 @@ mali: gpu@c0000 {
 			operating-points-v2 = <&gpu_opp_table>;
 			#cooling-cells = <2>; /* min followed by max */
 		};
+
+		hdmi_tx: hdmi-tx@42000 {
+			compatible = "amlogic,meson8-hdmi-tx";
+			reg = <0x42000 0xc>;
+			interrupts = <GIC_SPI 57 IRQ_TYPE_EDGE_RISING>;
+			phys = <&hdmi_tx_phy>;
+			phy-names = "hdmi";
+			clocks = <&clkc CLKID_HDMI_PCLK>,
+				 <&clkc CLKID_HDMI_SYS>;
+			clock-names = "pclk", "sys";
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			#sound-dai-cells = <1>;
+			sound-name-prefix = "HDMITX";
+
+			status = "disabled";
+
+			/* VPU VENC Input */
+			hdmi_tx_venc_port: port@0 {
+				reg = <0>;
+
+				hdmi_tx_in: endpoint {
+					remote-endpoint = <&hdmi_tx_out>;
+				};
+			};
+
+			/* TMDS Output */
+			hdmi_tx_tmds_port: port@1 {
+				reg = <1>;
+			};
+		};
+
+		nfc: nand-controller@48600 {
+			compatible = "amlogic,meson8-nfc";
+			reg = <0x48600 0x24>;
+			interrupts = <GIC_SPI 34 IRQ_TYPE_EDGE_RISING>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			clocks = <&clkc CLKID_NAND>, <&clkc CLKID_NAND_CLK>;
+			clock-names = "core", "nand";
+			status = "disabled";
+		};
+
+		vpu: vpu@100000 {
+			compatible = "amlogic,meson8-vpu";
+
+			reg = <0x100000 0x10000>;
+			reg-names = "vpu";
+
+			interrupts = <GIC_SPI 3 IRQ_TYPE_EDGE_RISING>;
+
+			amlogic,canvas = <&canvas>;
+
+			/*
+			 * The VCLK{,2}_IN path always needs to derived from
+			 * the CLKID_VID_PLL_FINAL_DIV so other clocks like
+			 * MPLL1 are not used (MPLL1 is reserved for audio
+			 * purposes).
+			 */
+			assigned-clocks = <&clkc CLKID_VCLK_IN_SEL>,
+					  <&clkc CLKID_VCLK2_IN_SEL>;
+			assigned-clock-parents = <&clkc CLKID_VID_PLL_FINAL_DIV>,
+						 <&clkc CLKID_VID_PLL_FINAL_DIV>;
+
+			clocks = <&clkc CLKID_VPU_INTR>,
+				 <&clkc CLKID_HDMI_INTR_SYNC>,
+				 <&clkc CLKID_GCLK_VENCI_INT>,
+				 <&clkc CLKID_HDMI_PLL_HDMI_OUT>,
+				 <&clkc CLKID_HDMI_TX_PIXEL>,
+				 <&clkc CLKID_CTS_ENCP>,
+				 <&clkc CLKID_CTS_ENCI>,
+				 <&clkc CLKID_CTS_ENCT>,
+				 <&clkc CLKID_CTS_ENCL>,
+				 <&clkc CLKID_CTS_VDAC0>;
+			clock-names = "vpu_intr",
+				      "hdmi_intr_sync",
+				      "venci_int",
+				      "tmds",
+				      "hdmi_tx_pixel",
+				      "cts_encp",
+				      "cts_enci",
+				      "cts_enct",
+				      "cts_encl",
+				      "cts_vdac0";
+
+			resets = <&clkc CLKC_RESET_VID_DIVIDER_CNTL_RESET_N_PRE>,
+				 <&clkc CLKC_RESET_VID_DIVIDER_CNTL_RESET_N_POST>,
+				 <&clkc CLKC_RESET_VID_DIVIDER_CNTL_SOFT_RESET_PRE>,
+				 <&clkc CLKC_RESET_VID_DIVIDER_CNTL_SOFT_RESET_POST>;
+			reset-names = "vid_pll_pre",
+				      "vid_pll_post",
+				      "vid_pll_soft_pre",
+				      "vid_pll_soft_post";
+
+			phys = <&cvbs_dac>;
+			phy-names = "cvbs-dac";
+
+			power-domains = <&pwrc PWRC_MESON8_VPU_ID>;
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			/* CVBS VDAC output port */
+			cvbs_vdac_port: port@0 {
+				reg = <0>;
+			};
+
+			/* HDMI-TX output port */
+			hdmi_tx_port: port@1 {
+				reg = <1>;
+
+				hdmi_tx_out: endpoint {
+					remote-endpoint = <&hdmi_tx_in>;
+				};
+			};
+		};
 	};
 }; /* end of / */
 
@@ -363,6 +489,14 @@ gpio_ao: ao-bank@14 {
 			gpio-ranges = <&pinctrl_aobus 0 0 16>;
 		};
 
+		hdmi_cec_ao_pins: hdmi-cec-ao {
+			mux {
+				groups = "hdmi_cec_ao";
+				function = "hdmi_cec_ao";
+				bias-pull-up;
+			};
+		};
+
 		i2s_am_clk_pins: i2s-am-clk-out {
 			mux {
 				groups = "i2s_am_clk_out_ao";
@@ -427,6 +561,15 @@ mux {
 			};
 		};
 	};
+
+	cec_AO: cec@100 {
+		compatible = "amlogic,meson-gx-ao-cec"; // FIXME
+		reg = <0x100 0x14>;
+		interrupts = <GIC_SPI 151 IRQ_TYPE_EDGE_RISING>;
+		// TODO: 32768HZ clock
+		hdmi-phandle = <&hdmi_tx>;
+		status = "disabled";
+	};
 };
 
 &ao_arc_rproc {
@@ -479,6 +622,36 @@ gpio: banks@80b0 {
 			gpio-ranges = <&pinctrl_cbus 0 0 120>;
 		};
 
+		hdmi_hpd_pins: hdmi-hpd {
+			mux {
+				groups = "hdmi_hpd";
+				function = "hdmi";
+				bias-disable;
+			};
+		};
+
+		hdmi_i2c_pins: hdmi-i2c {
+			mux {
+				groups = "hdmi_sda", "hdmi_scl";
+				function = "hdmi";
+				bias-disable;
+			};
+		};
+
+		pwm_c_dv9_pins: pwm-c-dv9 {
+			mux {
+				groups = "pwm_c_dv9";
+				function = "pwm_c";
+			};
+		};
+
+		pwm_d_pins: pwm-d {
+			mux {
+				groups = "pwm_d";
+				function = "pwm_d";
+			};
+		};
+
 		sd_a_pins: sd-a {
 			mux {
 				groups = "sd_d0_a", "sd_d1_a", "sd_d2_a",
@@ -506,6 +679,15 @@ mux {
 			};
 		};
 
+		sdxc_a_pins: sdxc-a {
+			mux {
+				groups = "sdxc_d0_a", "sdxc_d13_a",
+					 "sdxc_clk_a", "sdxc_cmd_a";
+				function = "sdxc_a";
+				bias-pull-up;
+			};
+		};
+
 		sdxc_b_pins: sdxc-b {
 			mux {
 				groups = "sdxc_d0_b", "sdxc_d13_b",
@@ -543,6 +725,35 @@ mux {
 			};
 		};
 
+		nand_pins: nand {
+			mux {
+				groups = "nand_io",
+					"nand_ale",
+					"nand_cle",
+					"nand_wen_clk",
+					"nand_ren_clk",
+					"nand_dqs";
+				function = "nand";
+				bias-pull-down;
+			};
+		};
+
+		nand_ce0_pins: nand-ce0 {
+			mux {
+				groups = "nand_io_ce0";
+				function = "nand";
+				bias-pull-up;
+			};
+		};
+
+		nand_rb0_pins: nand-rb0 {
+			mux {
+				groups = "nand_io_rb0";
+				function = "nand";
+				bias-pull-up;
+			};
+		};
+
 		pwm_e_pins: pwm-e {
 			mux {
 				groups = "pwm_e";
@@ -568,6 +779,14 @@ mux {
 				bias-disable;
 			};
 		};
+
+		xtal_32k_out_pins: xtal-32k-out {
+			mux {
+				groups = "xtal_32k_out";
+				function = "xtal";
+				bias-disable;
+			};
+		};
 	};
 };
 
@@ -584,6 +803,17 @@ smp-sram@1ff80 {
 	};
 };
 
+&cvbs_dac {
+	compatible = "amlogic,meson8-cvbs-dac", "amlogic,meson-cvbs-dac";
+
+	clocks = <&clkc CLKID_CTS_VDAC0>;
+
+	nvmem-cells = <&cvbs_trimming>;
+	nvmem-cell-names = "cvbs_trimming";
+
+	status = "okay";
+};
+
 &efuse {
 	compatible = "amlogic,meson8-efuse";
 	clocks = <&clkc CLKID_EFUSE>;
@@ -593,11 +823,15 @@ temperature_calib: calib@1f4 {
 		/* only the upper two bytes are relevant */
 		reg = <0x1f4 0x4>;
 	};
+
+	cvbs_trimming: calib@1f8 {
+		reg = <0x1f8 0x2>;
+	};
 };
 
 &ethmac {
-	clocks = <&clkc CLKID_ETH>;
-	clock-names = "stmmaceth";
+	clocks = <&clkc CLKID_ETH>, <&clkc CLKID_ETH_CLK>;
+	clock-names = "stmmaceth", "ethernet";
 
 	power-domains = <&pwrc PWRC_MESON8_ETHERNET_MEM_ID>;
 };
@@ -608,16 +842,18 @@ &gpio_intc {
 };
 
 &hhi {
-	clkc: clock-controller {
+	clkc: clock-controller@0 {
 		compatible = "amlogic,meson8-clkc";
+		reg = <0x0 0x39c>;
 		clocks = <&xtal>, <&ddr_clkc DDR_CLKID_DDR_PLL>;
 		clock-names = "xtal", "ddr_pll";
 		#clock-cells = <1>;
 		#reset-cells = <1>;
 	};
 
-	pwrc: power-controller {
+	pwrc: power-controller@100 {
 		compatible = "amlogic,meson8-pwrc";
+		reg = <0x100 0x10>;
 		#power-domain-cells = <1>;
 		amlogic,ao-sysctrl = <&pmu>;
 		clocks = <&clkc CLKID_VPU>;
@@ -625,6 +861,13 @@ pwrc: power-controller {
 		assigned-clocks = <&clkc CLKID_VPU>;
 		assigned-clock-rates = <364285714>;
 	};
+
+	hdmi_tx_phy: hdmi-phy@3a0 {
+		compatible = "amlogic,meson8-hdmi-tx-phy";
+		clocks = <&clkc CLKID_HDMI_PLL_HDMI_OUT>;
+		reg = <0x3a0 0xc>;
+		#phy-cells = <0>;
+	};
 };
 
 &hwrng {
@@ -651,6 +894,9 @@ &L2 {
 	arm,filter-ranges = <0x100000 0xc0000000>;
 	prefetch-data = <1>;
 	prefetch-instr = <1>;
+	arm,prefetch-offset = <7>;
+	arm,double-linefill = <1>;
+	arm,prefetch-drop = <1>;
 	arm,shared-override;
 };
 
diff --git a/arch/arm/boot/dts/meson8b-ec100.dts b/arch/arm/boot/dts/meson8b-ec100.dts
index 77d4beeb8010..30643dff0489 100644
--- a/arch/arm/boot/dts/meson8b-ec100.dts
+++ b/arch/arm/boot/dts/meson8b-ec100.dts
@@ -27,6 +27,16 @@ memory {
 		reg = <0x40000000 0x40000000>;
 	};
 
+	cvbs-connector {
+		compatible = "composite-video-connector";
+
+		port {
+			cvbs_connector_in: endpoint {
+				remote-endpoint = <&cvbs_vdac_out>;
+			};
+		};
+	};
+
 	emmc_pwrseq: emmc-pwrseq {
 		compatible = "mmc-pwrseq-emmc";
 		reset-gpios = <&gpio BOOT_9 GPIO_ACTIVE_LOW>;
@@ -70,6 +80,17 @@ gpio-poweroff {
 		timeout-ms = <20000>;
 	};
 
+	hdmi-connector {
+		compatible = "hdmi-connector";
+		type = "a";
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&hdmi_tx_tmds_out>;
+			};
+		};
+	};
+
 	leds {
 		compatible = "gpio-leds";
 
@@ -119,6 +140,18 @@ dai-link-1 {
 			codec-0 {
 				sound-dai = <&rt5640>;
 			};
+
+			codec-1 {
+				sound-dai = <&aiu AIU_HDMI CTRL_I2S>;
+			};
+		};
+
+		dai-link-2 {
+			sound-dai = <&aiu AIU_HDMI CTRL_OUT>;
+
+			codec-0 {
+				sound-dai = <&hdmi_tx 0>;
+			};
 		};
 	};
 
@@ -280,6 +313,12 @@ &cpu0 {
 	cpu-supply = <&vcck>;
 };
 
+&cvbs_vdac_port {
+	cvbs_vdac_out: endpoint {
+		remote-endpoint = <&cvbs_connector_in>;
+	};
+};
+
 &ethmac {
 	status = "okay";
 
@@ -310,6 +349,18 @@ eth_phy0: ethernet-phy@0 {
 	};
 };
 
+&hdmi_tx {
+	status = "okay";
+	pinctrl-0 = <&hdmi_hpd_pins>, <&hdmi_i2c_pins>;
+	pinctrl-names = "default";
+};
+
+&hdmi_tx_tmds_port {
+	hdmi_tx_tmds_out: endpoint {
+		remote-endpoint = <&hdmi_connector_in>;
+	};
+};
+
 &i2c_A {
 	status = "okay";
 	pinctrl-0 = <&i2c_a_pins>;
diff --git a/arch/arm/boot/dts/meson8b-mxq.dts b/arch/arm/boot/dts/meson8b-mxq.dts
index 7adedd3258c3..ab5b3e6576e3 100644
--- a/arch/arm/boot/dts/meson8b-mxq.dts
+++ b/arch/arm/boot/dts/meson8b-mxq.dts
@@ -27,6 +27,17 @@ memory {
 		reg = <0x40000000 0x40000000>;
 	};
 
+	hdmi-connector {
+		compatible = "hdmi-connector";
+		type = "a";
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&hdmi_tx_tmds_out>;
+			};
+		};
+	};
+
 	vcck: regulator-vcck {
 		compatible = "pwm-regulator";
 
@@ -43,6 +54,38 @@ vcck: regulator-vcck {
 		regulator-always-on;
 	};
 
+	sound {
+		compatible = "amlogic,gx-sound-card";
+		model = "M8B-MXQ";
+
+		assigned-clocks = <&clkc CLKID_MPLL0>,
+				  <&clkc CLKID_MPLL1>;
+		assigned-clock-rates = <294912000>,
+				       <270950400>;
+
+		dai-link-0 {
+			sound-dai = <&aiu AIU_CPU CPU_I2S_FIFO>;
+		};
+
+		dai-link-1 {
+			sound-dai = <&aiu AIU_CPU CPU_I2S_ENCODER>;
+			dai-format = "i2s";
+			mclk-fs = <256>;
+
+			codec-0 {
+				sound-dai = <&aiu AIU_HDMI CTRL_I2S>;
+			};
+		};
+
+		dai-link-2 {
+			sound-dai = <&aiu AIU_HDMI CTRL_OUT>;
+
+			codec-0 {
+				sound-dai = <&hdmi_tx 0>;
+			};
+		};
+	};
+
 	vcc_1v8: regulator-vcc1v8 {
 		compatible = "regulator-fixed";
 
@@ -91,6 +134,10 @@ vddee: regulator-vddee {
 	};
 };
 
+&aiu {
+	status = "okay";
+};
+
 &cpu0 {
 	cpu-supply = <&vcck>;
 };
@@ -125,6 +172,18 @@ eth_phy0: ethernet-phy@0 {
 	};
 };
 
+&hdmi_tx {
+	status = "okay";
+	pinctrl-0 = <&hdmi_hpd_pins>, <&hdmi_i2c_pins>;
+	pinctrl-names = "default";
+};
+
+&hdmi_tx_tmds_port {
+	hdmi_tx_tmds_out: endpoint {
+		remote-endpoint = <&hdmi_connector_in>;
+	};
+};
+
 &mali {
 	mali-supply = <&vddee>;
 };
diff --git a/arch/arm/boot/dts/meson8b-odroidc1.dts b/arch/arm/boot/dts/meson8b-odroidc1.dts
index 04356bc639fa..dc035d16bb2f 100644
--- a/arch/arm/boot/dts/meson8b-odroidc1.dts
+++ b/arch/arm/boot/dts/meson8b-odroidc1.dts
@@ -7,6 +7,7 @@
 /dts-v1/;
 #include "meson8b.dtsi"
 #include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/net/realtek-rtl8211f.h>
 
 / {
 	model = "Hardkernel ODROID-C1";
@@ -32,6 +33,17 @@ emmc_pwrseq: emmc-pwrseq {
 		reset-gpios = <&gpio BOOT_9 GPIO_ACTIVE_LOW>;
 	};
 
+	hdmi-connector {
+		compatible = "hdmi-connector";
+		type = "a";
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&hdmi_tx_tmds_out>;
+			};
+		};
+	};
+
 	leds {
 		compatible = "gpio-leds";
 		blue {
@@ -93,6 +105,52 @@ rtc32k_xtal: rtc32k-xtal-clk {
 		#clock-cells = <0>;
 	};
 
+	sound {
+		compatible = "amlogic,gx-sound-card";
+		model = "ODROID-C1";
+
+		assigned-clocks = <&clkc CLKID_MPLL0>,
+				  <&clkc CLKID_MPLL1>;
+		assigned-clock-rates = <294912000>,
+				       <270950400>;
+
+		dai-link-0 {
+			sound-dai = <&aiu AIU_CPU CPU_I2S_FIFO>;
+		};
+
+		dai-link-1 {
+			sound-dai = <&aiu AIU_CPU CPU_I2S_ENCODER>;
+			dai-format = "i2s";
+			mclk-fs = <256>;
+
+			codec-0 {
+				sound-dai = <&aiu AIU_HDMI CTRL_I2S>;
+			};
+		};
+
+		dai-link-2 {
+			sound-dai = <&aiu AIU_HDMI CTRL_OUT>;
+
+			codec-0 {
+				sound-dai = <&hdmi_tx 0>;
+			};
+		};
+	};
+
+	usb0_vbus: regulator-usb0-vbus {
+		/* Richtek RT9715EGB */
+		compatible = "regulator-fixed";
+
+		regulator-name = "USB0_VBUS";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+
+		vin-supply = <&p5v0>;
+
+		gpio = <&gpio_ao GPIOAO_5 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
 	vcc_1v8: regulator-vcc-1v8 {
 		/*
 		 * RICHTEK RT9179 configured for a fixed output voltage of
@@ -187,6 +245,10 @@ vdd_rtc: regulator-vdd-rtc {
 	};
 };
 
+&aiu {
+	status = "okay";
+};
+
 &cpu0 {
 	cpu-supply = <&vcck>;
 };
@@ -225,6 +287,13 @@ eth_phy: ethernet-phy@0 {
 			interrupt-parent = <&gpio_intc>;
 			/* GPIOH_3 */
 			interrupts = <17 IRQ_TYPE_LEVEL_LOW>;
+
+			/* absent */
+			realtek,led-0-mode = <0>;
+			/* green */
+			realtek,led-1-mode = <(RTL8211F_LED_LINK_100 | RTL8211F_LED_ACTIVITY | RTL8211F_LED_EEE)>;
+			/* amber */
+			realtek,led-2-mode = <(RTL8211F_LED_LINK_1000 | RTL8211F_LED_ACTIVITY | RTL8211F_LED_EEE)>;
 		};
 	};
 };
@@ -296,6 +365,18 @@ usb-hub {
 	};
 };
 
+&hdmi_tx {
+	status = "okay";
+	pinctrl-0 = <&hdmi_hpd_pins>, <&hdmi_i2c_pins>;
+	pinctrl-names = "default";
+};
+
+&hdmi_tx_tmds_port {
+	hdmi_tx_tmds_out: endpoint {
+		remote-endpoint = <&hdmi_connector_in>;
+	};
+};
+
 &ir_receiver {
 	status = "okay";
 	pinctrl-0 = <&ir_recv_pins>;
@@ -376,10 +457,28 @@ &uart_AO {
 	pinctrl-names = "default";
 };
 
-&usb1_phy {
+&usb0 {
 	status = "okay";
+
+	dr_mode = "otg";
+	usb-role-switch;
+
+	connector {
+		compatible = "gpio-usb-b-connector", "usb-b-connector";
+		type = "micro";
+		id-gpios = <&usb0_phy 0 GPIO_ACTIVE_HIGH>;
+		vbus-supply = <&usb0_vbus>;
+	};
 };
 
 &usb1 {
 	status = "okay";
 };
+
+&usb0_phy {
+	status = "okay";
+};
+
+&usb1_phy {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/meson8b.dtsi b/arch/arm/boot/dts/meson8b.dtsi
index cf9c04a61ba3..0244d6837889 100644
--- a/arch/arm/boot/dts/meson8b.dtsi
+++ b/arch/arm/boot/dts/meson8b.dtsi
@@ -276,6 +276,116 @@ mali: gpu@c0000 {
 			operating-points-v2 = <&gpu_opp_table>;
 			#cooling-cells = <2>; /* min followed by max */
 		};
+
+		hdmi_tx: hdmi-tx@42000 {
+			compatible = "amlogic,meson8b-hdmi-tx";
+			reg = <0x42000 0xc>;
+			interrupts = <GIC_SPI 57 IRQ_TYPE_EDGE_RISING>;
+			phys = <&hdmi_tx_phy>;
+			phy-names = "hdmi";
+			clocks = <&clkc CLKID_HDMI_PCLK>,
+				 <&clkc CLKID_HDMI_SYS>;
+			clock-names = "pclk", "sys";
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			#sound-dai-cells = <1>;
+			sound-name-prefix = "HDMITX";
+
+			status = "disabled";
+
+			/* VPU VENC Input */
+			hdmi_tx_venc_port: port@0 {
+				reg = <0>;
+
+				hdmi_tx_in: endpoint {
+					remote-endpoint = <&hdmi_tx_out>;
+				};
+			};
+
+			/* TMDS Output */
+			hdmi_tx_tmds_port: port@1 {
+				reg = <1>;
+			};
+		};
+
+		vpu: vpu@100000 {
+			compatible = "amlogic,meson8b-vpu";
+
+			reg = <0x100000 0x10000>;
+			reg-names = "vpu";
+
+			interrupts = <GIC_SPI 3 IRQ_TYPE_EDGE_RISING>;
+
+			amlogic,canvas = <&canvas>;
+
+			/*
+			 * The VCLK{,2}_IN path always needs to derived from
+			 * the CLKID_VID_PLL_FINAL_DIV so other clocks like
+			 * MPLL1 are not used (MPLL1 is reserved for audio
+			 * purposes).
+			 */
+			assigned-clocks = <&clkc CLKID_VCLK_IN_SEL>,
+					  <&clkc CLKID_VCLK2_IN_SEL>;
+			assigned-clock-parents = <&clkc CLKID_VID_PLL_FINAL_DIV>,
+						 <&clkc CLKID_VID_PLL_FINAL_DIV>;
+
+			clocks = <&clkc CLKID_VPU_INTR>,
+				 <&clkc CLKID_HDMI_INTR_SYNC>,
+				 <&clkc CLKID_GCLK_VENCI_INT>,
+				 <&clkc CLKID_HDMI_PLL_HDMI_OUT>,
+				 <&clkc CLKID_HDMI_TX_PIXEL>,
+				 <&clkc CLKID_CTS_ENCP>,
+				 <&clkc CLKID_CTS_ENCI>,
+				 <&clkc CLKID_CTS_ENCT>,
+				 <&clkc CLKID_CTS_ENCL>,
+				 <&clkc CLKID_CTS_VDAC0>;
+			clock-names = "vpu_intr",
+				      "hdmi_intr_sync",
+				      "venci_int",
+				      "tmds",
+				      "hdmi_tx_pixel",
+				      "cts_encp",
+				      "cts_enci",
+				      "cts_enct",
+				      "cts_encl",
+				      "cts_vdac0";
+
+			resets = <&clkc CLKC_RESET_VID_DIVIDER_CNTL_RESET_N_PRE>,
+				 <&clkc CLKC_RESET_VID_DIVIDER_CNTL_RESET_N_POST>,
+				 <&clkc CLKC_RESET_VID_DIVIDER_CNTL_SOFT_RESET_PRE>,
+				 <&clkc CLKC_RESET_VID_DIVIDER_CNTL_SOFT_RESET_POST>;
+			reset-names = "vid_pll_pre",
+				      "vid_pll_post",
+				      "vid_pll_soft_pre",
+				      "vid_pll_soft_post";
+
+			phys = <&cvbs_dac>;
+			phy-names = "cvbs-dac";
+
+			power-domains = <&pwrc PWRC_MESON8_VPU_ID>;
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			#sound-dai-cells = <0>;
+			sound-name-prefix = "HDMITX";
+
+			/* CVBS VDAC output port */
+			cvbs_vdac_port: port@0 {
+				reg = <0>;
+			};
+
+			/* HDMI-TX output port */
+			hdmi_tx_port: port@1 {
+				reg = <1>;
+
+				hdmi_tx_out: endpoint {
+					remote-endpoint = <&hdmi_tx_in>;
+				};
+			};
+		};
 	};
 }; /* end of / */
 
@@ -325,6 +435,14 @@ gpio_ao: ao-bank@14 {
 			gpio-ranges = <&pinctrl_aobus 0 0 16>;
 		};
 
+		hdmi_cec_ao_pins: hdmi-cec-ao {
+			mux {
+				groups = "hdmi_cec_1";
+				function = "hdmi_cec";
+				bias-pull-up;
+			};
+		};
+
 		i2s_am_clk_pins: i2s-am-clk-out {
 			mux {
 				groups = "i2s_am_clk_out";
@@ -381,6 +499,15 @@ mux {
 			};
 		};
 	};
+
+	cec_AO: cec@100 {
+		compatible = "amlogic,meson-gx-ao-cec"; // FIXME
+		reg = <0x100 0x14>;
+		interrupts = <GIC_SPI 151 IRQ_TYPE_EDGE_RISING>;
+		// TODO: 32768HZ clock
+		hdmi-phandle = <&hdmi_tx>;
+		status = "disabled";
+	};
 };
 
 &ao_arc_rproc {
@@ -389,6 +516,8 @@ &ao_arc_rproc {
 	sram = <&ao_arc_sram>;
 	resets = <&reset RESET_MEDIA_CPU>;
 	clocks = <&clkc CLKID_AO_MEDIA_CPU>;
+	status = "okay";
+	firmware-name = "zephyr.elf";
 };
 
 &cbus {
@@ -471,6 +600,22 @@ mux {
 			};
 		};
 
+		hdmi_hpd_pins: hdmi-hpd {
+			mux {
+				groups = "hdmi_hpd";
+				function = "hdmi";
+				bias-disable;
+			};
+		};
+
+		hdmi_i2c_pins: hdmi-i2c {
+			mux {
+				groups = "hdmi_sda", "hdmi_scl";
+				function = "hdmi";
+				bias-disable;
+			};
+		};
+
 		i2c_a_pins: i2c-a {
 			mux {
 				groups = "i2c_sda_a", "i2c_sck_a";
@@ -547,6 +692,16 @@ smp-sram@1ff80 {
 	};
 };
 
+&cvbs_dac {
+	compatible = "amlogic,meson8-cvbs-dac", "amlogic,meson-cvbs-dac";
+
+	clocks = <&clkc CLKID_CTS_VDAC0>;
+
+	nvmem-cells = <&cvbs_trimming>;
+	nvmem-cell-names = "cvbs_trimming";
+
+	status = "okay";
+};
 
 &efuse {
 	compatible = "amlogic,meson8b-efuse";
@@ -557,6 +712,10 @@ temperature_calib: calib@1f4 {
 		/* only the upper two bytes are relevant */
 		reg = <0x1f4 0x4>;
 	};
+
+	cvbs_trimming: calib@1f8 {
+		reg = <0x1f8 0x2>;
+	};
 };
 
 &ethmac {
@@ -586,16 +745,18 @@ &gpio_intc {
 };
 
 &hhi {
-	clkc: clock-controller {
+	clkc: clock-controller@0 {
 		compatible = "amlogic,meson8b-clkc";
+		reg = <0x0 0x39c>;
 		clocks = <&xtal>, <&ddr_clkc DDR_CLKID_DDR_PLL>;
 		clock-names = "xtal", "ddr_pll";
 		#clock-cells = <1>;
 		#reset-cells = <1>;
 	};
 
-	pwrc: power-controller {
+	pwrc: power-controller@100 {
 		compatible = "amlogic,meson8b-pwrc";
+		reg = <0x100 0x10>;
 		#power-domain-cells = <1>;
 		amlogic,ao-sysctrl = <&pmu>;
 		resets = <&reset RESET_DBLK>,
@@ -617,6 +778,14 @@ pwrc: power-controller {
 		assigned-clocks = <&clkc CLKID_VPU>;
 		assigned-clock-rates = <182142857>;
 	};
+
+	hdmi_tx_phy: hdmi-phy@3a0 {
+		compatible = "amlogic,meson8b-hdmi-tx-phy",
+			     "amlogic,meson8-hdmi-tx-phy";
+		clocks = <&clkc CLKID_HDMI_PLL_HDMI_OUT>;
+		reg = <0x3a0 0xc>;
+		#phy-cells = <0>;
+	};
 };
 
 &hwrng {
@@ -643,6 +812,9 @@ &L2 {
 	arm,filter-ranges = <0x100000 0xc0000000>;
 	prefetch-data = <1>;
 	prefetch-instr = <1>;
+	arm,prefetch-offset = <7>;
+	arm,double-linefill = <1>;
+	arm,prefetch-drop = <1>;
 	arm,shared-override;
 };
 
diff --git a/arch/arm/boot/dts/meson8m2-m8s.dts b/arch/arm/boot/dts/meson8m2-m8s.dts
new file mode 100644
index 000000000000..666e1d1b263c
--- /dev/null
+++ b/arch/arm/boot/dts/meson8m2-m8s.dts
@@ -0,0 +1,437 @@
+/*
+ * Copyright (c) 2017 Martin Blumenstingl <martin.blumenstingl@googlemail.com>.
+ *
+ * SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+ */
+
+/dts-v1/;
+
+#include "meson8m2.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+/ {
+	model = "Akaso M8S";
+	compatible = "akaso,m8s", "amlogic,meson8m2";
+
+	aliases {
+		ethernet0 = &ethmac;
+		serial0 = &uart_AO;
+		mmc0 = &sdio_sd_card_slot;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x40000000 0x80000000>;
+	};
+
+	adc-keys {
+		compatible = "adc-keys";
+		io-channels = <&saradc 0>;
+		io-channel-names = "buttons";
+		keyup-threshold-microvolt = <1710000>;
+
+		button-function {
+			label = "Function";
+			linux,code = <KEY_FN>;
+			press-threshold-microvolt = <10000>;
+		};
+	};
+
+	cvbs-connector {
+		compatible = "composite-video-connector";
+
+		port {
+			cvbs_connector_in: endpoint {
+				remote-endpoint = <&cvbs_vdac_out>;
+			};
+		};
+	};
+
+	hdmi-connector {
+		compatible = "hdmi-connector";
+		type = "a";
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&hdmi_tx_tmds_out>;
+			};
+		};
+	};
+
+	pwmleds {
+		compatible = "pwm-leds";
+
+		power {
+			label = "m8s:blue:power";
+			pwms = <&pwm_ef 1 7812500 0>;
+			max-brightness = <255>;
+			active-low;
+			linux,default-trigger = "default-on";
+		};
+	};
+
+	sdio_pwrseq: sdio-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+
+		pinctrl-0 = <&xtal_32k_out_pins>;
+		pinctrl-names = "default";
+
+		reset-gpios = <&gpio_ao GPIOAO_6 GPIO_ACTIVE_LOW>,
+			      <&gpio GPIOX_11 GPIO_ACTIVE_LOW>; /* TODO: should be enable-gpios with GPIO_ACTIVE_HIGH in the card's node, this is WIFI_DISn */
+
+		clocks = <&xtal_32k_out>;
+		clock-names = "ext_clock";
+	};
+
+	sound {
+		compatible = "amlogic,gx-sound-card";
+		model = "AKASO-M8S";
+
+		assigned-clocks = <&clkc CLKID_MPLL0>,
+				  <&clkc CLKID_MPLL1>,
+				  <&clkc CLKID_MPLL2>;
+		assigned-clock-rates = <294912000>,
+				       <270950400>,
+				       <393216000>;
+
+		dai-link-0 {
+			sound-dai = <&aiu AIU_CPU CPU_I2S_FIFO>;
+		};
+
+		dai-link-1 {
+			sound-dai = <&aiu AIU_CPU CPU_SPDIF_FIFO>;
+		};
+
+		dai-link-2 {
+			sound-dai = <&aiu AIU_CPU CPU_I2S_ENCODER>;
+			dai-format = "i2s";
+			mclk-fs = <256>;
+
+			codec-0 {
+				sound-dai = <&aiu AIU_HDMI CTRL_I2S>;
+			};
+
+			codec-1 {
+				sound-dai = <&stereo_i2s_codec>;
+			};
+		};
+
+		dai-link-3 {
+			sound-dai = <&aiu AIU_HDMI CTRL_OUT>;
+
+			codec-0 {
+				sound-dai = <&hdmi_tx 0>;
+			};
+		};
+
+		dai-link-4 {
+			sound-dai = <&aiu AIU_CPU CPU_SPDIF_ENCODER>;
+
+			codec-0 {
+				sound-dai = <&hdmi_tx 1>;
+			};
+
+			codec-1 {
+				sound-dai = <&spdif_dit>;
+			};
+		};
+	};
+
+	stereo_i2s_codec: i2s-audio-codec {
+		compatible = "everest,es7134";
+		#sound-dai-cells = <0>;
+	};
+
+	spdif_dit: spdif-audio-codec {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dit";
+		sound-name-prefix = "DIT";
+	};
+
+	vcck: regulator-vcck {
+		compatible = "regulator-fixed";
+		regulator-name = "VCCK";
+		regulator-min-microvolt = <975000>;
+		regulator-max-microvolt = <975000>;
+		vin-supply = <&vcc_5v>;
+	};
+
+	vddee: regulator-vddee {
+		compatible = "regulator-fixed";
+		regulator-name = "VDD_EE";
+		regulator-min-microvolt = <1150000>;
+		regulator-max-microvolt = <1150000>;
+		vin-supply = <&vcc_5v>;
+	};
+
+	vcc_1v8: regulator-vcc1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "VCC1V8";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&vcc_5v>;
+	};
+
+	vcc_3v3: regulator-vcc3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "VCC3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&vcc_5v>;
+	};
+
+	vcc_5v: regulator-vcc5v {
+		compatible = "regulator-fixed";
+		regulator-name = "VCC5V";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+	};
+
+	xtal_32k_out: xtal-32k-out-clk {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <32768>;
+		clock-output-names = "xtal_32k_out";
+	};
+};
+
+&aiu {
+	status = "okay";
+
+	pinctrl-0 = <&i2s_am_clk_pins>, <&i2s_out_ao_clk_pins>,
+		    <&i2s_out_lr_clk_pins>, <&i2s_out_ch01_ao_pins>,
+		    <&spdif_out_pins>;
+	pinctrl-names = "default";
+};
+
+&cec_AO {
+	// TODO: is this correct?
+	clocks = <&xtal_32k_out>;
+	clock-names = "core";
+
+	pinctrl-0 = <&hdmi_cec_ao_pins>;
+	pinctrl-names = "default";
+};
+
+&cpu0 {
+	cpu-supply = <&vcck>;
+};
+
+&cvbs_vdac_port {
+	cvbs_vdac_out: endpoint {
+		remote-endpoint = <&cvbs_connector_in>;
+	};
+};
+
+&ethmac {
+	status = "okay";
+
+	pinctrl-0 = <&eth_pins>;
+	pinctrl-names = "default";
+
+	phy-handle = <&eth_phy0>;
+	phy-mode = "rmii";
+
+	mdio {
+		compatible = "snps,dwmac-mdio";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		eth_phy0: ethernet-phy@0 {
+			/* IC Plus IP101GR (0x02430c54) */
+			reg = <0>;
+
+			reset-assert-us = <10000>;
+			reset-deassert-us = <10000>;
+			reset-gpios = <&gpio GPIOZ_14 GPIO_ACTIVE_LOW>;
+		};
+	};
+};
+
+&hdmi_tx {
+	status = "okay";
+	pinctrl-0 = <&hdmi_hpd_pins>, <&hdmi_i2c_pins>;
+	pinctrl-names = "default";
+};
+
+&hdmi_tx_tmds_port {
+	hdmi_tx_tmds_out: endpoint {
+		remote-endpoint = <&hdmi_connector_in>;
+	};
+};
+
+&ir_receiver {
+	status = "okay";
+	pinctrl-0 = <&ir_recv_pins>;
+	pinctrl-names = "default";
+};
+
+
+&mali {
+	mali-supply = <&vddee>;
+};
+
+&nfc {
+	/* TODO: status = "okay"; */
+
+	pinctrl-0 = <&nand_pins>, <&nand_ce0_pins>, <&nand_rb0_pins>;
+	pinctrl-names = "default";
+
+	nand@0 {
+		reg = <0>;
+
+		nand-on-flash-bbt;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@2 {
+				label = "2GiB";
+				reg = <0x0 0xffffffff>;
+				read-only;
+			};
+
+			partition@0 {
+				label = "nand_page0_cfg";
+				reg = <0x0 0x4000>;
+				read-only;
+			};
+
+			partition@4000 {
+				label = "u-boot";
+				reg = <0x4000 0x60000>;
+				read-only;
+			};
+
+			partition@400000 {
+				label = "u-boot-env";
+				reg = <0x400000 0x10000>;
+				read-only;
+			};
+
+			partition@1000000 {
+				label = "boot";
+				reg = <0x1000000 0x400000>;
+				read-only;
+			};
+
+			partition@1400000 {
+				label = "uboot_p1";
+				reg = <0x1400000 0x8000000>;
+				read-only;
+			};
+
+			partition@d000000 {
+				label = "cache";
+				reg = <0xd000000 0x19000000>;
+				read-only;
+			};
+
+			partition@33000000 {
+				label = "system";
+				reg = <0x33000000 0x1f000000>;
+				read-only;
+			};
+
+			partition@85000000 {
+				label = "data";
+				reg = <0x85000000 0xf6000000>;
+				read-only;
+			};
+		};
+	};
+};
+
+&saradc {
+	status = "okay";
+	vref-supply = <&vcc_1v8>;
+};
+
+/* wifi */
+&sdhc {
+	status = "okay";
+
+	pinctrl-0 = <&sdxc_a_pins>;
+	pinctrl-names = "default";
+
+	bus-width = <4>;
+	max-frequency = <50000000>;
+
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	non-removable;
+	disable-wp;
+
+	mmc-pwrseq = <&sdio_pwrseq>;
+
+	vmmc-supply = <&vcc_3v3>;
+	vqmmc-supply = <&vcc_3v3>;
+};
+
+/* SD card */
+&sdio {
+	status = "okay";
+
+	pinctrl-0 = <&sd_b_pins>;
+	pinctrl-names = "default";
+
+	sdio_sd_card_slot: slot@1 {
+		compatible = "mmc-slot";
+		reg = <1>;
+
+		bus-width = <4>;
+		max-frequency = <50000000>;
+
+		no-mmc;
+		no-sdio;
+		cap-sd-highspeed;
+		disable-wp;
+
+		cd-gpios = <&gpio CARD_6 GPIO_ACTIVE_LOW>;
+
+		vmmc-supply = <&vcc_3v3>;
+	};
+};
+
+&uart_A {
+	status = "okay";
+
+	pinctrl-0 = <&uart_a1_pins>, <&uart_a1_cts_rts_pins>;
+	pinctrl-names = "default";
+	uart-has-rtscts;
+
+	bluetooth {
+		compatible = "realtek,rtl8723bs-bt";
+		enable-gpios = <&gpio GPIOX_20 GPIO_ACTIVE_HIGH>;
+	};
+};
+
+&uart_AO {
+	status = "okay";
+	pinctrl-0 = <&uart_ao_a_pins>;
+	pinctrl-names = "default";
+};
+
+&usb0 {
+	status = "okay";
+};
+
+&usb1 {
+	status = "okay";
+};
+
+&usb0_phy {
+	status = "okay";
+};
+
+&usb1_phy {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/meson8m2-mxiii-plus.dts b/arch/arm/boot/dts/meson8m2-mxiii-plus.dts
index fa6d55f1cfb9..0a332ed2933c 100644
--- a/arch/arm/boot/dts/meson8m2-mxiii-plus.dts
+++ b/arch/arm/boot/dts/meson8m2-mxiii-plus.dts
@@ -6,57 +6,17 @@
 
 /dts-v1/;
 
-#include "meson8m2.dtsi"
-
-#include <dt-bindings/gpio/gpio.h>
-#include <dt-bindings/input/input.h>
+#include "meson8m2-mxiii.dtsi"
 
 / {
 	model = "Tronsmart MXIII Plus";
 	compatible = "tronsmart,mxiii-plus", "amlogic,meson8m2";
 
 	aliases {
-		ethernet0 = &ethmac;
-		i2c0 = &i2c_AO;
-		serial0 = &uart_AO;
 		serial1 = &uart_A;
-		mmc0 = &sd_card_slot;
-	};
-
-	chosen {
-		stdout-path = "serial0:115200n8";
-	};
-
-	memory {
-		device_type = "memory";
-		reg = <0x40000000 0x80000000>;
-	};
-
-	adc-keys {
-		compatible = "adc-keys";
-		io-channels = <&saradc 0>;
-		io-channel-names = "buttons";
-		keyup-threshold-microvolt = <1710000>;
-
-		button-function {
-			label = "Function";
-			linux,code = <KEY_FN>;
-			press-threshold-microvolt = <10000>;
-		};
-	};
-
-	vcc_3v3: regulator-vcc3v3 {
-		compatible = "regulator-fixed";
-		regulator-name = "VCC3V3";
-		regulator-min-microvolt = <3300000>;
-		regulator-max-microvolt = <3300000>;
 	};
 };
 
-&cpu0 {
-	cpu-supply = <&vcck>;
-};
-
 &ethmac {
 	status = "okay";
 
@@ -82,116 +42,6 @@ eth_phy0: ethernet-phy@0 {
 	};
 };
 
-&ir_receiver {
-	status = "okay";
-	pinctrl-0 = <&ir_recv_pins>;
-	pinctrl-names = "default";
-};
-
-&i2c_AO {
-	status = "okay";
-	pinctrl-0 = <&i2c_ao_pins>;
-	pinctrl-names = "default";
-
-	pmic@32 {
-		compatible = "ricoh,rn5t618";
-		reg = <0x32>;
-		system-power-controller;
-
-		regulators {
-			vcck: DCDC1 {
-				regulator-name = "VCCK";
-				regulator-min-microvolt = <825000>;
-				regulator-max-microvolt = <1150000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			vddee: DCDC2 {
-				/* the output is also used as VDDAO */
-				regulator-name = "VDD_EE";
-				regulator-min-microvolt = <950000>;
-				regulator-max-microvolt = <1150000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			DCDC3 {
-				regulator-name = "VDD_DDR";
-				regulator-min-microvolt = <1500000>;
-				regulator-max-microvolt = <1500000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			LDO1 {
-				regulator-name = "VDDIO_AO28";
-				regulator-min-microvolt = <2900000>;
-				regulator-max-microvolt = <2900000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			vddio_ao1v8: LDO2 {
-				regulator-name = "VDDIO_AO18";
-				regulator-min-microvolt = <1800000>;
-				regulator-max-microvolt = <1800000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			LDO3 {
-				regulator-name = "VCC1V8";
-				regulator-min-microvolt = <1800000>;
-				regulator-max-microvolt = <1800000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			LDO4 {
-				regulator-name = "VCC2V8";
-				regulator-min-microvolt = <2850000>;
-				regulator-max-microvolt = <2850000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			LDO5 {
-				regulator-name = "AVDD1V8";
-				regulator-min-microvolt = <1800000>;
-				regulator-max-microvolt = <1800000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			LDORTC1 {
-				regulator-name = "VDD_LDO";
-				regulator-min-microvolt = <2700000>;
-				regulator-max-microvolt = <2700000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-
-			LDORTC2 {
-				regulator-name = "RTC_0V9";
-				regulator-min-microvolt = <900000>;
-				regulator-max-microvolt = <900000>;
-				regulator-boot-on;
-				regulator-always-on;
-			};
-		};
-	};
-};
-
-&mali {
-	mali-supply = <&vddee>;
-};
-
-&saradc {
-	status = "okay";
-	vref-supply = <&vddio_ao1v8>;
-};
-
 &sdio {
 	status = "okay";
 
@@ -216,32 +66,9 @@ sd_card_slot: slot@1 {
 	};
 };
 
-/* connected to the Bluetooth module */
 &uart_A {
 	status = "okay";
 	pinctrl-0 = <&uart_a1_pins>, <&uart_a1_cts_rts_pins>;
 	pinctrl-names = "default";
 	uart-has-rtscts;
 };
-
-&uart_AO {
-	status = "okay";
-	pinctrl-0 = <&uart_ao_a_pins>;
-	pinctrl-names = "default";
-};
-
-&usb0 {
-	status = "okay";
-};
-
-&usb1 {
-	status = "okay";
-};
-
-&usb0_phy {
-	status = "okay";
-};
-
-&usb1_phy {
-	status = "okay";
-};
diff --git a/arch/arm/boot/dts/meson8m2-mxiii.dts b/arch/arm/boot/dts/meson8m2-mxiii.dts
new file mode 100644
index 000000000000..89b1dcf4e73a
--- /dev/null
+++ b/arch/arm/boot/dts/meson8m2-mxiii.dts
@@ -0,0 +1,99 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2018 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ */
+
+/dts-v1/;
+
+#include "meson8m2-mxiii.dtsi"
+
+/ {
+	model = "Tronsmart MXIII";
+	compatible = "tronsmart,mxiii", "amlogic,meson8m2";
+
+	gpio-keys-polled {
+		compatible = "gpio-keys-polled";
+		poll-interval = <100>;
+
+		button-power {
+			label = "power";
+			linux,code = <KEY_POWER>;
+			gpios = <&gpio_ao GPIOAO_3 GPIO_ACTIVE_LOW>;
+		};
+	};
+};
+
+&ethmac {
+	status = "okay";
+
+	pinctrl-0 = <&eth_pins>;
+	pinctrl-names = "default";
+
+	phy-handle = <&eth_phy0>;
+	phy-mode = "rmii";
+
+	mdio {
+		compatible = "snps,dwmac-mdio";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		eth_phy0: ethernet-phy@0 {
+			/* IC Plus IP101A/G (0x02430c54) */
+			reg = <0>;
+			icplus,select-interrupt;
+			interrupt-parent = <&gpio_intc>;
+			/* GPIODV_29 = 94 and GPIOZ_4 are not working */
+			/* interrupts = <94 IRQ_TYPE_LEVEL_LOW>; */
+
+			reset-assert-us = <10000>;
+			reset-deassert-us = <10000>;
+			reset-gpios = <&gpio GPIOZ_14 GPIO_ACTIVE_LOW>;
+		};
+	};
+};
+
+/* SDIO wifi */
+&sdhc {
+	status = "okay";
+
+	pinctrl-0 = <&sdxc_a_pins>;
+	pinctrl-names = "default";
+
+	bus-width = <4>;
+	max-frequency = <50000000>;
+
+	disable-wp;
+	non-removable;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+
+	mmc-pwrseq = <&sdio_pwrseq>;
+
+	vmmc-supply = <&vcc_3v3>;
+	vqmmc-supply = <&vcc_3v3>;
+};
+
+/* SD card */
+&sdio {
+	status = "okay";
+
+	pinctrl-0 = <&sd_b_pins>;
+	pinctrl-names = "default";
+
+	slot@0 {
+		compatible = "mmc-slot";
+		reg = <1>;
+
+		bus-width = <4>;
+		max-frequency = <50000000>;
+
+		no-mmc;
+		no-sdio;
+		cap-sd-highspeed;
+		disable-wp;
+
+		cd-gpios = <&gpio CARD_6 GPIO_ACTIVE_LOW>;
+
+		vmmc-supply = <&vcc_3v3>;
+	};
+};
diff --git a/arch/arm/boot/dts/meson8m2-mxiii.dtsi b/arch/arm/boot/dts/meson8m2-mxiii.dtsi
new file mode 100644
index 000000000000..8a35491a6b98
--- /dev/null
+++ b/arch/arm/boot/dts/meson8m2-mxiii.dtsi
@@ -0,0 +1,325 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2018 Oleg Ivanov <balbes-150@yandex.ru>
+ * Copyright (c) 2018 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ */
+
+/dts-v1/;
+
+#include "meson8m2.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+/ {
+	aliases {
+		ethernet0 = &ethmac;
+		i2c0 = &i2c_AO;
+		serial0 = &uart_AO;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory {
+		reg = <0x40000000 0x40000000>;
+		device_type = "memory";
+	};
+
+	adc-keys {
+		compatible = "adc-keys";
+		io-channels = <&saradc 0>;
+		io-channel-names = "buttons";
+		keyup-threshold-microvolt = <1710000>;
+
+		button-function {
+			label = "Function";
+			linux,code = <KEY_FN>;
+			press-threshold-microvolt = <10000>;
+		};
+	};
+
+	cvbs-connector {
+		compatible = "composite-video-connector";
+
+		port {
+			cvbs_connector_in: endpoint {
+				remote-endpoint = <&cvbs_vdac_out>;
+			};
+		};
+	};
+
+	hdmi-connector {
+		compatible = "hdmi-connector";
+		type = "a";
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&hdmi_tx_tmds_out>;
+			};
+		};
+	};
+
+	sdio_pwrseq: sdio-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+
+		pinctrl-0 = <&xtal_32k_out_pins>;
+		pinctrl-names = "default";
+
+		reset-gpios = <&gpio GPIOX_11 GPIO_ACTIVE_LOW>,
+			      <&gpio_ao GPIOAO_6 GPIO_ACTIVE_LOW>;
+
+		clocks = <&xtal_32k_out>;
+		clock-names = "ext_clock";
+	};
+
+	sound {
+		compatible = "amlogic,gx-sound-card";
+		model = "TRONSMART-MXIII";
+
+		assigned-clocks = <&clkc CLKID_MPLL0>,
+				  <&clkc CLKID_MPLL1>;
+		assigned-clock-rates = <270950400>,
+				       <294912000>;
+
+		dai-link-0 {
+			sound-dai = <&aiu AIU_CPU CPU_I2S_FIFO>;
+		};
+
+		dai-link-1 {
+			sound-dai = <&aiu AIU_CPU CPU_SPDIF_FIFO>;
+		};
+
+		dai-link-2 {
+			sound-dai = <&aiu AIU_CPU CPU_I2S_ENCODER>;
+			dai-format = "i2s";
+			mclk-fs = <256>;
+
+			codec-0 {
+				sound-dai = <&aiu AIU_HDMI CTRL_I2S>;
+			};
+		};
+
+		dai-link-3 {
+			sound-dai = <&aiu AIU_HDMI CTRL_OUT>;
+
+			codec-0 {
+				sound-dai = <&hdmi_tx 0>;
+			};
+		};
+
+		dai-link-4 {
+			sound-dai = <&aiu AIU_CPU CPU_SPDIF_ENCODER>;
+
+			codec-0 {
+				sound-dai = <&spdif_dit>;
+			};
+		};
+	};
+
+	spdif_dit: spdif-audio-codec {
+		compatible = "linux,spdif-dit";
+		#sound-dai-cells = <0>;
+		sound-name-prefix = "DIT";
+	};
+
+	usb_vbus: regulator-usb-vbus {
+		compatible = "regulator-fixed";
+
+		regulator-name = "USB_VBUS";
+
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+
+		gpio = <&gpio GPIOZ_1 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
+	vcc_3v3: regulator-vcc3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "VCC3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	xtal_32k_out: xtal-32k-out-clk {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <32768>;
+		clock-output-names = "xtal_32k_out";
+	};
+};
+
+&aiu {
+	status = "okay";
+
+	pinctrl-0 = <&i2s_am_clk_pins>, <&i2s_out_ao_clk_pins>,
+		    <&i2s_out_lr_clk_pins>, <&i2s_out_ch01_ao_pins>,
+		    <&spdif_out_pins>;
+	pinctrl-names = "default";
+};
+
+&cpu0 {
+	cpu-supply = <&vcck>;
+};
+
+&cvbs_vdac_port {
+	cvbs_vdac_out: endpoint {
+		remote-endpoint = <&cvbs_connector_in>;
+	};
+};
+
+&hdmi_tx {
+	status = "okay";
+	pinctrl-0 = <&hdmi_hpd_pins>, <&hdmi_i2c_pins>;
+	pinctrl-names = "default";
+};
+
+&hdmi_tx_tmds_port {
+	hdmi_tx_tmds_out: endpoint {
+		remote-endpoint = <&hdmi_connector_in>;
+	};
+};
+
+&ir_receiver {
+	status = "okay";
+	pinctrl-0 = <&ir_recv_pins>;
+	pinctrl-names = "default";
+};
+
+&i2c_AO {
+	status = "okay";
+	pinctrl-0 = <&i2c_ao_pins>;
+	pinctrl-names = "default";
+
+	pmic@32 {
+		compatible = "ricoh,rn5t618";
+		reg = <0x32>;
+		system-power-controller;
+
+		regulators {
+			vcck: DCDC1 {
+				regulator-name = "VCCK";
+				regulator-min-microvolt = <825000>;
+				regulator-max-microvolt = <1150000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vddee: DCDC2 {
+				/* the output is also used as VDDAO */
+				regulator-name = "VDD_EE";
+				regulator-min-microvolt = <950000>;
+				regulator-max-microvolt = <1150000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			DCDC3 {
+				regulator-name = "VDD_DDR";
+				regulator-min-microvolt = <1500000>;
+				regulator-max-microvolt = <1500000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			LDO1 {
+				regulator-name = "VDDIO_AO28";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vddio_ao1v8: LDO2 {
+				regulator-name = "VDDIO_AO18";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			LDO3 {
+				regulator-name = "VCC1V8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			LDO4 {
+				regulator-name = "VCC2V8";
+				regulator-min-microvolt = <2850000>;
+				regulator-max-microvolt = <2850000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			LDO5 {
+				regulator-name = "AVDD1V8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			LDORTC1 {
+				regulator-name = "VDD_LDO";
+				regulator-min-microvolt = <2700000>;
+				regulator-max-microvolt = <2700000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			LDORTC2 {
+				regulator-name = "RTC_0V9";
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+		};
+	};
+};
+
+&mali {
+	mali-supply = <&vddee>;
+};
+
+&saradc {
+	status = "okay";
+	vref-supply = <&vddio_ao1v8>;
+};
+
+&uart_AO {
+	status = "okay";
+	pinctrl-0 = <&uart_ao_a_pins>;
+	pinctrl-names = "default";
+};
+
+&usb0 {
+	status = "okay";
+
+	dr_mode = "otg";
+	usb-role-switch;
+
+	connector {
+		compatible = "gpio-usb-b-connector", "usb-b-connector";
+		type = "micro";
+		id-gpios = <&usb0_phy 0 GPIO_ACTIVE_HIGH>;
+		vbus-supply = <&usb_vbus>;
+	};
+};
+
+&usb1 {
+	status = "okay";
+};
+
+&usb0_phy {
+	status = "okay";
+};
+
+&usb1_phy {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/meson8m2-wetek-core.dts b/arch/arm/boot/dts/meson8m2-wetek-core.dts
new file mode 100644
index 000000000000..c02e82e9271e
--- /dev/null
+++ b/arch/arm/boot/dts/meson8m2-wetek-core.dts
@@ -0,0 +1,495 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2021 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ */
+
+/dts-v1/;
+
+#include "meson8m2.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+/ {
+	model = "WeTek Core";
+	compatible = "wetek,core", "amlogic,meson8m2";
+
+	aliases {
+		ethernet0 = &ethmac;
+		serial0 = &uart_AO;
+		mmc0 = &sdhc;
+		mmc1 = &sd_card_slot;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x40000000 0x80000000>;
+	};
+
+	adc-keys {
+		compatible = "adc-keys";
+		io-channels = <&saradc 0>;
+		io-channel-names = "buttons";
+		keyup-threshold-microvolt = <1710000>;
+
+		button-function {
+			label = "update";
+			linux,code = <KEY_VENDOR>;
+			press-threshold-microvolt = <10000>;
+		};
+	};
+
+	ao_5v: regulator-ao-5v {
+		/* SY8120BABC */
+		compatible = "regulator-fixed";
+		regulator-name = "AO_5V";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&dc_12v>;
+	};
+
+	dc_12v: regulator-dc-12v {
+		compatible = "regulator-fixed";
+		regulator-name = "DC_12V";
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+	};
+
+	firmware {
+		trustzone-firmware {
+			compatible = "amlogic,meson8m2-trustzone-firmware",
+				     "amlogic,meson-mx-trustzone-firmware";
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		poll-interval = <100>;
+
+		button-power {
+			label = "power";
+			linux,code = <KEY_POWER>;
+			gpios = <&gpio_ao GPIOAO_4 GPIO_ACTIVE_LOW>;
+		};
+	};
+
+	reserved-memory {
+		trustzone-firmware@6100000 {
+			reg = <0x6100000 0x3000000>;
+			no-map;
+		};
+
+		video-stream-buf-config@aa00000 {
+			reg = <0xaa00000 0x2000000>;
+			no-map;
+		};
+
+		video-frame-buf-config@ca00000 {
+			reg = <0xca00000 0x10000000>;
+			no-map;
+		};
+	};
+
+	rtc_xin: rtc-xin-clk {
+		compatible = "fixed-clock";
+		clock-frequency = <32768>;
+		clock-output-names = "RTC_XIN";
+		#clock-cells = <0>;
+	};
+
+	sdio_pwrseq: sdio-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+
+		reset-gpios = <&gpio GPIOX_11 GPIO_ACTIVE_LOW>;
+
+		clocks = <&rtc_xin>;
+		clock-names = "ext_clock";
+	};
+
+	vcc_1v8: regulator-vcc-1v8 {
+		/* Will Semiconductor WL2803E18-5 */
+		compatible = "regulator-fixed";
+		regulator-name = "VCC_1V8";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		vin-supply = <&vcc_3v3>;
+
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	vcc_3v3: regulator-vcc-3v3 {
+		/* transistor controlled by 3V3_5V_EN */
+		compatible = "regulator-fixed";
+		regulator-name = "VCC3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		vin-supply = <&vddio_ao_3v3>;
+
+		gpios = <&gpio_ao GPIOAO_2 GPIO_ACTIVE_LOW>;
+
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	vcc_5v: regulator-vcc-5v {
+		/* transistor controlled by 3V3_5V_EN */
+		compatible = "regulator-fixed";
+		regulator-name = "VCC5V";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+
+		vin-supply = <&ao_5v>;
+
+		gpios = <&gpio_ao GPIOAO_2 GPIO_ACTIVE_LOW>;
+
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	vcck: regulator-vcck {
+		/* Silergy SY8120BABC */
+		compatible = "pwm-regulator";
+
+		regulator-name = "VCCK";
+		regulator-min-microvolt = <860000>;
+		regulator-max-microvolt = <1140000>;
+
+		pwm-supply = <&dc_12v>;
+
+		pwms = <&pwm_cd 0 1148 0>;
+		pwm-dutycycle-range = <100 0>;
+
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	vdd_ee: regulator-vdd-ee {
+		/* Silergy SY8113BADC */
+		compatible = "pwm-regulator";
+
+		regulator-name = "VDD_EE";
+		regulator-min-microvolt = <860000>;
+		regulator-max-microvolt = <1140000>;
+
+		pwm-supply = <&dc_12v>;
+
+		pwms = <&pwm_cd 1 12218 0>;
+		pwm-dutycycle-range = <91 0>;
+
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	vddio_ao_3v3: regulator-vddio-ao-3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "VDDIO_AO_3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		vin-supply = <&dc_12v>;
+
+		gpios = <&gpio_ao GPIOAO_2 GPIO_ACTIVE_LOW>;
+
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	vddio_ao_1v8: regulator-vddio-ao-1v8 {
+		/* Will Semiconductor WL2803E18-5 */
+		compatible = "regulator-fixed";
+		regulator-name = "VDDIO_AO_1V8";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+
+		vin-supply = <&ao_5v>;
+
+		regulator-boot-on;
+		regulator-always-on;
+	};
+};
+
+&cpu0 {
+	cpu-supply = <&vcck>;
+	enable-method = "amlogic,meson8-trustzone-firmware-smp";
+};
+
+&cpu1 {
+	cpu-supply = <&vcck>;
+	enable-method = "amlogic,meson8-trustzone-firmware-smp";
+};
+
+&cpu2 {
+	cpu-supply = <&vcck>;
+	enable-method = "amlogic,meson8-trustzone-firmware-smp";
+};
+
+&cpu3 {
+	cpu-supply = <&vcck>;
+	enable-method = "amlogic,meson8-trustzone-firmware-smp";
+};
+
+/*
+ * The VCCK regulator is limited in range and requires higher voltages
+ * on lower frequencies (<= 720MHz) as well as lower voltages on 1992MHz.
+ */
+&cpu_opp_table {
+	opp-96000000 {
+		opp-microvolt = <860000>;
+	};
+	opp-192000000 {
+		opp-microvolt = <860000>;
+	};
+	opp-312000000 {
+		opp-microvolt = <860000>;
+	};
+	opp-408000000 {
+		opp-microvolt = <860000>;
+	};
+	opp-504000000 {
+		opp-microvolt = <860000>;
+	};
+	opp-600000000 {
+		opp-microvolt = <860000>;
+	};
+	opp-720000000 {
+		opp-microvolt = <860000>;
+	};
+	opp-816000000 {
+		opp-microvolt = <880000>;
+	};
+	opp-1008000000 {
+		opp-microvolt = <930000>;
+	};
+	opp-1200000000 {
+		opp-microvolt = <980000>;
+	};
+	opp-1416000000 {
+		opp-microvolt = <1030000>;
+	};
+	opp-1608000000 {
+		opp-microvolt = <1100000>;
+	};
+	opp-1800000000 {
+		opp-microvolt = <1130000>;
+	};
+	opp-1992000000 {
+		opp-microvolt = <1140000>;
+	};
+};
+
+/*
+ * The VDDEE regulator is limited in range and u-boot configures it
+ * to ~1.135V (instead of 1.15V as used on boards with a Ricoh PMU).
+ */
+&gpu_opp_table {
+	opp-182142857 {
+		opp-microvolt = <1135000>;
+	};
+	opp-318750000 {
+		opp-microvolt = <1135000>;
+	};
+	opp-425000000 {
+		opp-microvolt = <1135000>;
+	};
+	opp-510000000 {
+		opp-microvolt = <1135000>;
+	};
+	opp-637500000 {
+		opp-microvolt = <1135000>;
+	};
+};
+
+&ethmac {
+	status = "okay";
+
+	pinctrl-0 = <&eth_rgmii_pins>;
+	pinctrl-names = "default";
+
+	phy-handle = <&eth_phy1>;
+	phy-mode = "rgmii-id";
+
+	mdio {
+		compatible = "snps,dwmac-mdio";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		eth_phy1: ethernet-phy@1 {
+			/* Realtek RTL8211F (0x001cc916) */
+			reg = <1>;
+
+			reset-assert-us = <10000>;
+			reset-deassert-us = <80000>;
+			reset-gpios = <&gpio GPIOZ_14 GPIO_ACTIVE_LOW>;
+
+			interrupt-parent = <&gpio_intc>;
+			/* GPIODV_29 */
+			interrupts = <94 IRQ_TYPE_LEVEL_LOW>;
+		};
+	};
+};
+
+&gpio {
+	gpio-line-names = /* Bank GPIOX */
+			  "WIFI_SD_D0", "WIFI_SD_D1", "WIFI_SD_D2",
+			  "WIFI_SD_D3", "BTPCM_DOUT", "BTPCM_DIN",
+			  "BTPCM_SYNC", "BTPCM_CLK", "WIFI_SD_CLK",
+			  "WIFI_SD_CMD", "WIFI_32K", "WIFI_PWREN",
+			  "UART_A_TX", "UART_A_RX", "UART_A_CTS_N",
+			  "UART_A_RTS_N", "ISO7816_EN/DET", "ISO7816_RST",
+			  "ISO7816_CLK", "ISO7816_DATA", "BT_EN",
+			  "WIFI_WAKE_HOST",
+			  /* Bank GPIOY */
+			  "TSIN_A_VAL", "TSIN_A_SYNC", "", "SPDIF",
+			  "PDN", "TSIN_RST", "ANT1_CTRL", "",
+			  "TSIN_A_CLK", "TSIN_A_D0", "TSIN_A_D1",
+			  "TSIN_A_D2", "TSIN_A_D3", "TSIN_A_D4",
+			  "TSIN_A_D5", "TSIN_A_D6", "TSIN_A_D7",
+			  /* Bank GPIODV */
+			  "", "", "", "", "", "", "", "", "",
+			  "VCCK_PWM_C", "", "", "", "", "", "", "",
+			  "", "", "", "", "", "", "", "", "", "", "",
+			  "VDDEE_PWM_D", "RGMII_IRQ#",
+			  /* Bank GPIOH */
+			  "HDMI_HPD", "HDMI_SDA", "HDMI_SCL", "HUB_REST",
+			  "", "ANT_OVERLOAD", "", "I2C_SDA", "I2C_SCL",
+			  "",
+			  /* Bank GPIOZ */
+			  "RGMII_TXD3", "RGMII_TXD2", "RGMII_RXD3",
+			  "RGMII_RXD2", "RGMII_TXCLK", "RGMII_TXEN",
+			  "RGMII_TXD1", "RGMII_TXD0", "RGMII_RXCLK",
+			  "RGM RGMII_RXDV", "RGMII_RXD1", "RGMII_RXD0",
+			  "RGMII_MDIO", "RGMII_MDC", "RGMII_RST#",
+			  /* Bank CARD */
+			  "SD_D1_B", "SD_D0_B", "SD_CLK_B", "SD_CMD_B",
+			  "SD_D3_B", "SD_D2_B", "CARD_EN_DET",
+			  /* Bank BOOT */
+			  "NAND_D0", "NAND_D1", "NAND_D2", "NAND_D3",
+			  "NAND_D4", "NAND_D5", "NAND_D6", "NAND_D7",
+			  "NAND_CS1", "INAND_RST", "NAND_NR/B",
+			  "NAND_ALE", "SPI_O", "NAND_NWE", "NAND_NRE",
+			  "NAND_DQS", "INAND_CMD", "INAND_CLK",
+			  "SPI_CS";
+
+	/*
+	 * WARNING: The USB Hub on the WeTek core needs a reset signal
+	 * to be turned high in order to be detected by the USB Controller.
+	 * This signal should be handled by a USB specific power sequence
+	 * in order to reset the Hub when USB bus is powered down.
+	 */
+	usb-hub {
+		gpio-hog;
+		gpios = <GPIOH_3 GPIO_ACTIVE_HIGH>;
+		output-high;
+		line-name = "usb-hub-reset";
+	};
+};
+
+&gpio_ao {
+	gpio-line-names = "LINUX_TX", "LINUX_RX", "3V3_5V_EN",
+			  "VCCK_CON", "PWR_KEY", "VDEE_PWM_D",
+			  "RGMII_RST#", "IR", "", "FRONT_CS",
+			  "I2C_SDA_AO", "I2C_SCK_AO", "HDMI_CEC",
+			  "IR_BLASTER", "MUTE", "";
+};
+
+&ir_receiver {
+	status = "okay";
+	pinctrl-0 = <&ir_recv_pins>;
+	pinctrl-names = "default";
+};
+
+&mali {
+	mali-supply = <&vdd_ee>;
+};
+
+&pwm_cd {
+	status = "okay";
+	pinctrl-0 = <&pwm_c_dv9_pins>, <&pwm_d_pins>;
+	pinctrl-names = "default";
+	clocks = <&xtal>, <&xtal>;
+	clock-names = "clkin0", "clkin1";
+};
+
+&saradc {
+	status = "okay";
+	vref-supply = <&vddio_ao_1v8>;
+};
+
+&sdhc {
+	status = "disabled"; // TODO: until pinctrl is updated...
+
+	// TODO: pinctrl-0 = <&sdxc_a_pins>;
+	pinctrl-names = "default";
+
+	bus-width = <4>;
+	cap-sd-highspeed;
+	max-frequency = <50000000>;
+
+	non-removable;
+	disable-wp;
+
+	vmmc-supply = <&vcc_3v3>;
+	vqmmc-supply = <&vddio_ao_3v3>;
+};
+
+&sdio {
+	status = "okay";
+
+	pinctrl-0 = <&sd_b_pins>;
+	pinctrl-names = "default";
+
+	/* SD card */
+	sd_card_slot: slot@1 {
+		compatible = "mmc-slot";
+		reg = <1>;
+		status = "okay";
+
+		bus-width = <4>;
+		no-sdio;
+		cap-mmc-highspeed;
+		cap-sd-highspeed;
+		disable-wp;
+
+		cd-gpios = <&gpio CARD_6 GPIO_ACTIVE_LOW>;
+
+		vmmc-supply = <&vcc_3v3>;
+	};
+};
+
+&uart_A {
+	status = "okay";
+	pinctrl-0 = <&uart_a1_pins>, <&uart_a1_cts_rts_pins>;
+	pinctrl-names = "default";
+	uart-has-rtscts;
+
+	bluetooth {
+		compatible = "brcm,bcm43438-bt";
+		shutdown-gpios = <&gpio GPIOX_20 GPIO_ACTIVE_HIGH>;
+		max-speed = <2000000>;
+		clocks = <&rtc_xin>;
+		clock-names = "lpo";
+	};
+};
+
+&uart_AO {
+	status = "okay";
+	pinctrl-0 = <&uart_ao_a_pins>;
+	pinctrl-names = "default";
+};
+
+&usb1 {
+	status = "okay";
+};
+
+&usb1_phy {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/meson8m2.dtsi b/arch/arm/boot/dts/meson8m2.dtsi
index 6725dd9fd825..fcb2ad976098 100644
--- a/arch/arm/boot/dts/meson8m2.dtsi
+++ b/arch/arm/boot/dts/meson8m2.dtsi
@@ -96,6 +96,10 @@ &usb1_phy {
 	compatible = "amlogic,meson8m2-usb2-phy", "amlogic,meson-mx-usb2-phy";
 };
 
+&vpu {
+	compatible = "amlogic,meson8m2-vpu";
+};
+
 &wdt {
 	compatible = "amlogic,meson8m2-wdt", "amlogic,meson8b-wdt";
 };
diff --git a/arch/arm/mach-meson/Makefile b/arch/arm/mach-meson/Makefile
index 49cfbaee4e00..b8fe5f1406b6 100644
--- a/arch/arm/mach-meson/Makefile
+++ b/arch/arm/mach-meson/Makefile
@@ -1,3 +1,3 @@
 # SPDX-License-Identifier: GPL-2.0-only
-obj-$(CONFIG_ARCH_MESON) += meson.o
+obj-$(CONFIG_ARCH_MESON) += meson.o tz_firmware.o
 obj-$(CONFIG_SMP) += platsmp.o
diff --git a/arch/arm/mach-meson/meson.c b/arch/arm/mach-meson/meson.c
index de56e707c7aa..ad6e776db8d5 100644
--- a/arch/arm/mach-meson/meson.c
+++ b/arch/arm/mach-meson/meson.c
@@ -6,6 +6,8 @@
 #include <linux/of_platform.h>
 #include <asm/mach/arch.h>
 
+#include "tz_firmware.h"
+
 static const char * const meson_common_board_compat[] = {
 	"amlogic,meson6",
 	"amlogic,meson8",
@@ -18,4 +20,6 @@ DT_MACHINE_START(MESON, "Amlogic Meson platform")
 	.dt_compat	= meson_common_board_compat,
 	.l2c_aux_val	= 0,
 	.l2c_aux_mask	= ~0,
+	.init_early	= meson_mx_trustzone_firmware_init,
+	.reserve	= meson_mx_trustzone_firmware_reserve_mem,
 MACHINE_END
diff --git a/arch/arm/mach-meson/platsmp.c b/arch/arm/mach-meson/platsmp.c
index 32ac60b89fdc..3e38066fc65a 100644
--- a/arch/arm/mach-meson/platsmp.c
+++ b/arch/arm/mach-meson/platsmp.c
@@ -16,6 +16,7 @@
 
 #include <asm/cacheflush.h>
 #include <asm/cp15.h>
+#include <asm/firmware.h>
 #include <asm/smp_scu.h>
 #include <asm/smp_plat.h>
 
@@ -291,6 +292,31 @@ static int meson8b_smp_boot_secondary(unsigned int cpu,
 	return 0;
 }
 
+static int meson8_smp_trustzone_firmware_boot_secondary(unsigned int cpu,
+							struct task_struct *idle)
+{
+	unsigned int addr = __pa_symbol(secondary_startup);
+	int ret;
+
+	ret = call_firmware_op(set_cpu_boot_addr, cpu, addr);
+	if (ret) {
+		pr_err("Failed to set aux core boot address for CPU%u using TrustZone secure firmware\n",
+			cpu);
+		return ret;
+	}
+
+	ret = call_firmware_op(cpu_boot, cpu);
+	if (ret) {
+		pr_err("Failed to modify core control for CPU%u using TrustZone secure firmware\n",
+			cpu);
+		return ret;
+	}
+
+	udelay(10);
+
+	return 0;
+}
+
 #ifdef CONFIG_HOTPLUG_CPU
 static void meson8_smp_cpu_die(unsigned int cpu)
 {
@@ -428,5 +454,12 @@ static struct smp_operations meson8b_smp_ops __initdata = {
 #endif
 };
 
+static struct smp_operations meson8_smp_trustzone_firmware_ops __initdata = {
+	.smp_boot_secondary	= meson8_smp_trustzone_firmware_boot_secondary,
+};
+
 CPU_METHOD_OF_DECLARE(meson8_smp, "amlogic,meson8-smp", &meson8_smp_ops);
 CPU_METHOD_OF_DECLARE(meson8b_smp, "amlogic,meson8b-smp", &meson8b_smp_ops);
+CPU_METHOD_OF_DECLARE(meson8_trustzone_firmware_smp,
+		      "amlogic,meson8-trustzone-firmware-smp",
+		      &meson8_smp_trustzone_firmware_ops);
diff --git a/arch/arm/mach-meson/tz_firmware.c b/arch/arm/mach-meson/tz_firmware.c
new file mode 100644
index 000000000000..9cdad41447df
--- /dev/null
+++ b/arch/arm/mach-meson/tz_firmware.c
@@ -0,0 +1,250 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2021 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ */
+
+#include <linux/arm-smccc.h>
+#include <linux/firmware/meson/meson_mx_trustzone.h>
+#include <linux/memblock.h>
+#include <linux/of.h>
+
+#include <asm/firmware.h>
+#include <asm/hardware/cache-l2x0.h>
+#include <asm/outercache.h>
+
+#include "tz_firmware.h"
+
+struct meson_mx_trustzone_firmware_memconfig {
+	unsigned char name[64];
+	unsigned int start_phy_addr;
+	unsigned int end_phy_addr;
+} __packed;
+
+static struct meson_mx_trustzone_firmware_memconfig meson_firmware_memconfig[2];
+
+static int meson_mx_trustzone_firmware_hal_api(unsigned int cmd, u32 *args)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(MESON_CALL_TRUSTZONE_HAL_API, cmd, virt_to_phys(args), 0,
+		      0, 0, 0, 0, &res);
+
+	return res.a0;
+}
+
+static u32 meson_mx_trustzone_firmware_mon(unsigned int cmd, unsigned int arg0,
+					   unsigned int arg1)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(MESON_CALL_TRUSTZONE_MON, cmd, arg0, arg1, 0, 0, 0, 0,
+		      &res);
+
+	return res.a0;
+}
+
+static int meson_mx_trustzone_firmware_set_cpu_boot_addr(int cpu,
+							 unsigned long boot_addr){
+	return meson_mx_trustzone_firmware_mon(MESON_TRUSTZONE_MON_CORE_BOOTADDR_INDEX,
+					       cpu, boot_addr);
+}
+
+static int meson_mx_trustzone_firmware_cpu_boot(int cpu)
+{
+	u32 ret, corectrl;
+
+	corectrl = meson_mx_trustzone_firmware_mon(MESON_TRUSTZONE_MON_CORE_RD_CTRL_INDEX,
+						   0, 0);
+
+	corectrl |= BIT(cpu);
+
+	ret = meson_mx_trustzone_firmware_mon(MESON_TRUSTZONE_MON_CORE_WR_CTRL_INDEX,
+					      corectrl, 0);
+	if (ret != corectrl)
+		return -EINVAL;
+
+	return 0;
+}
+
+static void meson_mx_trustzone_firmware_l2x0_write_sec(unsigned long val,
+						       unsigned int reg)
+{
+	u32 fn;
+
+	switch (reg) {
+	case L2X0_CTRL:
+		fn = MESON_TRUSTZONE_MON_L2X0_CTRL_INDEX;
+		break;
+
+	case L2X0_AUX_CTRL:
+		fn = MESON_TRUSTZONE_MON_L2X0_AUXCTRL_INDEX;
+		break;
+
+	case L310_TAG_LATENCY_CTRL:
+		fn = MESON_TRUSTZONE_MON_L2X0_TAGLATENCY_INDEX;
+		break;
+
+	case L310_DATA_LATENCY_CTRL:
+		fn = MESON_TRUSTZONE_MON_L2X0_DATALATENCY_INDEX;
+		break;
+
+	case L310_ADDR_FILTER_START:
+		fn = MESON_TRUSTZONE_MON_L2X0_FILTERSTART_INDEX;
+		break;
+
+	case L310_ADDR_FILTER_END:
+		fn = MESON_TRUSTZONE_MON_L2X0_FILTEREND_INDEX;
+		break;
+
+	case L2X0_DEBUG_CTRL:
+		fn = MESON_TRUSTZONE_MON_L2X0_DEBUG_INDEX;
+		break;
+
+	case L310_PREFETCH_CTRL:
+		fn = MESON_TRUSTZONE_MON_L2X0_PREFETCH_INDEX;
+		break;
+
+	case L310_POWER_CTRL:
+		fn = MESON_TRUSTZONE_MON_L2X0_POWER_INDEX;
+		break;
+
+	default:
+		pr_warn("Amlogic Meson TrustZone - unsupported L2X0 register 0x%08x\n",
+			reg);
+		return;
+	}
+
+	WARN_ON(meson_mx_trustzone_firmware_mon(fn, val, 0));
+}
+
+static int __maybe_unused meson_mx_trustzone_firmware_l2x0_init(void)
+{
+	if (IS_ENABLED(CONFIG_CACHE_L2X0))
+		outer_cache.write_sec = meson_mx_trustzone_firmware_l2x0_write_sec;
+
+	return 0;
+}
+
+static const struct firmware_ops meson_mx_trustzone_firmware_ops = {
+	.set_cpu_boot_addr	= meson_mx_trustzone_firmware_set_cpu_boot_addr,
+	.cpu_boot		= meson_mx_trustzone_firmware_cpu_boot,
+	.l2x0_init		= meson_mx_trustzone_firmware_l2x0_init,
+};
+
+void __init meson_mx_trustzone_firmware_init(void)
+{
+	if (!meson_mx_trustzone_firmware_available())
+		return;
+
+	pr_info("Running under Amlogic Meson TrustZone secure firmware.\n");
+
+	register_firmware_ops(&meson_mx_trustzone_firmware_ops);
+
+	call_firmware_op(l2x0_init);
+}
+
+static void __init meson_mx_trustzone_firmware_memconfig_init(void)
+{
+	unsigned int i, size;
+	u32 args[2] = {
+		__pa_symbol(meson_firmware_memconfig),
+		ARRAY_SIZE(meson_firmware_memconfig),
+	};
+	int ret;
+
+	ret = meson_mx_trustzone_firmware_hal_api(MESON_TRUSTZONE_HAL_API_MEMCONFIG,
+						  args);
+	if (ret) {
+		pr_err("Amlogic Meson TrustZone memconfig failed: %d\n", ret);
+		return;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(meson_firmware_memconfig); i++) {
+		size = meson_firmware_memconfig[i].end_phy_addr -
+		       meson_firmware_memconfig[i].start_phy_addr;
+
+		pr_debug("\tAmlogic Meson TrustZone memblock[%d]: %s (%u bytes)\n",
+			 i, meson_firmware_memconfig[i].name, size);
+
+		ret = memblock_mark_nomap(meson_firmware_memconfig[i].start_phy_addr,
+					  size);
+		if (ret)
+			pr_err("Failed to reserve %u bytes for Amlogic Meson TrustZone memblock[%d] (%s): %d\n",
+			       size, i, meson_firmware_memconfig[i].name, ret);
+	}
+}
+
+static void __init meson_mx_trustzone_firmware_monitor_memory_init(void)
+{
+	u32 base, size;
+	int ret;
+
+	base = meson_mx_trustzone_firmware_mon(MESON_TRUSTZONE_MON_MEM_BASE,
+					       0, 0);
+	WARN_ON(!base);
+
+	size = meson_mx_trustzone_firmware_mon(MESON_TRUSTZONE_MON_MEM_TOTAL_SIZE,
+					       0, 0);
+	WARN_ON(!size);
+
+	ret = memblock_mark_nomap(base, size);
+	if (ret)
+		pr_err("Failed to reserve %u bytes of Amlogic Meson TrustZone monitor memory: %d\n",
+		       size, ret);
+}
+
+void __init meson_mx_trustzone_firmware_reserve_mem(void)
+{
+	if (!meson_mx_trustzone_firmware_available())
+		return;
+
+	meson_mx_trustzone_firmware_monitor_memory_init();
+	meson_mx_trustzone_firmware_memconfig_init();
+}
+
+bool meson_mx_trustzone_firmware_available(void)
+{
+	struct device_node *np;
+
+	np = of_find_compatible_node(NULL, NULL,
+				     "amlogic,meson-mx-trustzone-firmware");
+	if (!np)
+		return false;
+
+	of_node_put(np);
+
+	return true;
+}
+EXPORT_SYMBOL_GPL(meson_mx_trustzone_firmware_available);
+
+int meson_mx_trustzone_firmware_efuse_read(unsigned int offset,
+					   unsigned int bytes, void *buf)
+{
+	unsigned int read_bytes;
+	u32 args[5] = {
+		MESON_TRUSTZONE_HAL_API_EFUSE_CMD_READ,
+		offset,
+		bytes,
+		__pa_symbol(buf),
+		virt_to_phys(&read_bytes)
+	};
+	int ret;
+
+	ret = meson_mx_trustzone_firmware_hal_api(MESON_TRUSTZONE_HAL_API_EFUSE,
+						  args);
+	if (ret)
+		return -EIO;
+
+	if (read_bytes != bytes)
+		return -EINVAL;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(meson_mx_trustzone_firmware_efuse_read);
+
+u32 meson_mx_trustzone_read_soc_rev1(void)
+{
+	return meson_mx_trustzone_firmware_mon(MESON_TRUSTZONE_MON_CORE_RD_SOC_REV1,
+					       0, 0);
+}
+EXPORT_SYMBOL_GPL(meson_mx_trustzone_read_soc_rev1);
diff --git a/arch/arm/mach-meson/tz_firmware.h b/arch/arm/mach-meson/tz_firmware.h
new file mode 100644
index 000000000000..a9da3c84a3df
--- /dev/null
+++ b/arch/arm/mach-meson/tz_firmware.h
@@ -0,0 +1,76 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Amlogic Meson6/8/8b/8m2 secure TrustZone firmware definitions.
+ *
+ * Based on meson-secure.c and meson-secure.h from the Amlogic vendor kernel:
+ *   Copyright (C) 2002 ARM Ltd.
+ *   Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+ *   Copyright (C) 2013 Amlogic, Inc.
+ *     Author: Platform-SH@amlogic.com
+ *
+ * Copyright (C) 2021 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ */
+
+/* Meson Secure Monitor/HAL APIs */
+#define MESON_CALL_TRUSTZONE_API			0x1
+#define MESON_CALL_TRUSTZONE_MON			0x4
+#define MESON_CALL_TRUSTZONE_HAL_API			0x5
+
+/* Secure Monitor mode APIs */
+#define MESON_TRUSTZONE_MON_TYPE_MASK			0xF00
+#define MESON_TRUSTZONE_MON_FUNC_MASK			0x0FF
+
+#define MESON_TRUSTZONE_MON_L2X0			0x100
+#define MESON_TRUSTZONE_MON_L2X0_CTRL_INDEX		0x101
+#define MESON_TRUSTZONE_MON_L2X0_AUXCTRL_INDEX		0x102
+#define MESON_TRUSTZONE_MON_L2X0_PREFETCH_INDEX		0x103
+#define MESON_TRUSTZONE_MON_L2X0_TAGLATENCY_INDEX	0x104
+#define MESON_TRUSTZONE_MON_L2X0_DATALATENCY_INDEX	0x105
+#define MESON_TRUSTZONE_MON_L2X0_FILTERSTART_INDEX	0x106
+#define MESON_TRUSTZONE_MON_L2X0_FILTEREND_INDEX	0x107
+#define MESON_TRUSTZONE_MON_L2X0_DEBUG_INDEX		0x108
+#define MESON_TRUSTZONE_MON_L2X0_POWER_INDEX		0x109
+
+#define MESON_TRUSTZONE_MON_CORE			0x200
+#define MESON_TRUSTZONE_MON_CORE_RD_CTRL_INDEX		0x201
+#define MESON_TRUSTZONE_MON_CORE_WR_CTRL_INDEX		0x202
+#define MESON_TRUSTZONE_MON_CORE_RD_STATUS0_INDEX	0x203
+#define MESON_TRUSTZONE_MON_CORE_WR_STATUS0_INDEX	0x204
+#define MESON_TRUSTZONE_MON_CORE_RD_STATUS1_INDEX	0x205
+#define MESON_TRUSTZONE_MON_CORE_WR_STATUS1_INDEX	0x206
+#define MESON_TRUSTZONE_MON_CORE_BOOTADDR_INDEX		0x207
+#define MESON_TRUSTZONE_MON_CORE_DDR_INDEX		0x208
+#define MESON_TRUSTZONE_MON_CORE_RD_SOC_REV1		0x209
+#define MESON_TRUSTZONE_MON_CORE_RD_SOC_REV2		0x20A
+
+#define MESON_TRUSTZONE_MON_SUSPEND_FIRMWARE		0x300
+#define MESON_TRUSTZONE_MON_SAVE_CPU_GIC		0x400
+
+#define MESON_TRUSTZONE_MON_RTC				0x500
+#define MESON_TRUSTZONE_MON_RTC_RD_REG_INDEX		0x501
+#define MESON_TRUSTZONE_MON_RTC_WR_REG_INDEX		0x502
+
+#define MESON_TRUSTZONE_MON_REG				0x600
+#define MESON_TRUSTZONE_MON_REG_RD_INDEX		0x601
+#define MESON_TRUSTZONE_MON_REG_WR_INDEX		0x602
+
+#define MESON_TRUSTZONE_MON_MEM				0x700
+#define MESON_TRUSTZONE_MON_MEM_BASE			0x701
+#define MESON_TRUSTZONE_MON_MEM_TOTAL_SIZE		0x702
+#define MESON_TRUSTZONE_MON_MEM_FLASH			0x703
+#define MESON_TRUSTZONE_MON_MEM_FLASH_SIZE		0x704
+#define MESON_TRUSTZONE_MON_MEM_GE2D			0x705
+
+/* Secure HAL APIs*/
+#define MESON_TRUSTZONE_HAL_API_EFUSE			0x100
+#define MESON_TRUSTZONE_HAL_API_EFUSE_CMD_READ		0x0
+#define MESON_TRUSTZONE_HAL_API_EFUSE_CMD_WRITE		0x1
+#define MESON_TRUSTZONE_HAL_API_EFUSE_CMD_VERIFY_IMG	0x3
+
+#define MESON_TRUSTZONE_HAL_API_STORAGE			0x200
+
+#define MESON_TRUSTZONE_HAL_API_MEMCONFIG		0x300
+#define MESON_TRUSTZONE_HAL_API_MEMCONFIG_GE2D		0x301
+
+void __init meson_mx_trustzone_firmware_init(void);
+void __init meson_mx_trustzone_firmware_reserve_mem(void);
diff --git a/drivers/clk/meson/Kconfig b/drivers/clk/meson/Kconfig
index fc002c155bc3..dc1beb51ff5d 100644
--- a/drivers/clk/meson/Kconfig
+++ b/drivers/clk/meson/Kconfig
@@ -49,6 +49,7 @@ config COMMON_CLK_MESON8B
 	default y
 	select COMMON_CLK_MESON_REGMAP
 	select COMMON_CLK_MESON_MPLL
+	select COMMON_CLK_MESON_PHASE
 	select COMMON_CLK_MESON_PLL
 	select MFD_SYSCON
 	select RESET_CONTROLLER
diff --git a/drivers/clk/meson/clk-cpu-dyndiv.c b/drivers/clk/meson/clk-cpu-dyndiv.c
index 36976927fe82..8778c149d26a 100644
--- a/drivers/clk/meson/clk-cpu-dyndiv.c
+++ b/drivers/clk/meson/clk-cpu-dyndiv.c
@@ -27,14 +27,13 @@ static unsigned long meson_clk_cpu_dyndiv_recalc_rate(struct clk_hw *hw,
 				   NULL, 0, data->div.width);
 }
 
-static long meson_clk_cpu_dyndiv_round_rate(struct clk_hw *hw,
-					    unsigned long rate,
-					    unsigned long *prate)
+static int meson_clk_cpu_dyndiv_determine_rate(struct clk_hw *hw,
+					       struct clk_rate_request *req)
 {
 	struct clk_regmap *clk = to_clk_regmap(hw);
 	struct meson_clk_cpu_dyndiv_data *data = meson_clk_cpu_dyndiv_data(clk);
 
-	return divider_round_rate(hw, rate, prate, NULL, data->div.width, 0);
+	return divider_determine_rate(hw, req, NULL, data->div.width, 0);
 }
 
 static int meson_clk_cpu_dyndiv_set_rate(struct clk_hw *hw, unsigned long rate,
@@ -63,7 +62,7 @@ static int meson_clk_cpu_dyndiv_set_rate(struct clk_hw *hw, unsigned long rate,
 
 const struct clk_ops meson_clk_cpu_dyndiv_ops = {
 	.recalc_rate = meson_clk_cpu_dyndiv_recalc_rate,
-	.round_rate = meson_clk_cpu_dyndiv_round_rate,
+	.determine_rate = meson_clk_cpu_dyndiv_determine_rate,
 	.set_rate = meson_clk_cpu_dyndiv_set_rate,
 };
 EXPORT_SYMBOL_GPL(meson_clk_cpu_dyndiv_ops);
diff --git a/drivers/clk/meson/clk-dualdiv.c b/drivers/clk/meson/clk-dualdiv.c
index c5ca23a5e3e8..feae49a8f6dc 100644
--- a/drivers/clk/meson/clk-dualdiv.c
+++ b/drivers/clk/meson/clk-dualdiv.c
@@ -86,18 +86,23 @@ __dualdiv_get_setting(unsigned long rate, unsigned long parent_rate,
 	return (struct meson_clk_dualdiv_param *)&table[best_i];
 }
 
-static long meson_clk_dualdiv_round_rate(struct clk_hw *hw, unsigned long rate,
-					 unsigned long *parent_rate)
+static int meson_clk_dualdiv_determine_rate(struct clk_hw *hw,
+					    struct clk_rate_request *req)
 {
 	struct clk_regmap *clk = to_clk_regmap(hw);
 	struct meson_clk_dualdiv_data *dualdiv = meson_clk_dualdiv_data(clk);
-	const struct meson_clk_dualdiv_param *setting =
-		__dualdiv_get_setting(rate, *parent_rate, dualdiv);
+	const struct meson_clk_dualdiv_param *setting;
 
-	if (!setting)
-		return meson_clk_dualdiv_recalc_rate(hw, *parent_rate);
+	setting = __dualdiv_get_setting(req->rate, req->best_parent_rate,
+					dualdiv);
+	if (setting)
+		req->rate = __dualdiv_param_to_rate(req->best_parent_rate,
+						    setting);
+	else
+		req->rate = meson_clk_dualdiv_recalc_rate(hw,
+							  req->best_parent_rate);
 
-	return __dualdiv_param_to_rate(*parent_rate, setting);
+	return 0;
 }
 
 static int meson_clk_dualdiv_set_rate(struct clk_hw *hw, unsigned long rate,
@@ -122,7 +127,7 @@ static int meson_clk_dualdiv_set_rate(struct clk_hw *hw, unsigned long rate,
 
 const struct clk_ops meson_clk_dualdiv_ops = {
 	.recalc_rate	= meson_clk_dualdiv_recalc_rate,
-	.round_rate	= meson_clk_dualdiv_round_rate,
+	.determine_rate	= meson_clk_dualdiv_determine_rate,
 	.set_rate	= meson_clk_dualdiv_set_rate,
 };
 EXPORT_SYMBOL_GPL(meson_clk_dualdiv_ops);
diff --git a/drivers/clk/meson/clk-mpll.c b/drivers/clk/meson/clk-mpll.c
index fc9df4860872..b843e101d1ba 100644
--- a/drivers/clk/meson/clk-mpll.c
+++ b/drivers/clk/meson/clk-mpll.c
@@ -77,26 +77,35 @@ static unsigned long mpll_recalc_rate(struct clk_hw *hw,
 {
 	struct clk_regmap *clk = to_clk_regmap(hw);
 	struct meson_clk_mpll_data *mpll = meson_clk_mpll_data(clk);
-	unsigned int sdm, n2;
+	unsigned int n2, sdm_en, sdm = 0;
 	long rate;
 
-	sdm = meson_parm_read(clk->map, &mpll->sdm);
+	sdm_en = meson_parm_read(clk->map, &mpll->sdm_en);
+	if (sdm_en)
+		sdm = meson_parm_read(clk->map, &mpll->sdm);
+
 	n2 = meson_parm_read(clk->map, &mpll->n2);
 
 	rate = rate_from_params(parent_rate, sdm, n2);
 	return rate < 0 ? 0 : rate;
 }
 
-static long mpll_round_rate(struct clk_hw *hw,
-			    unsigned long rate,
-			    unsigned long *parent_rate)
+static int mpll_determine_rate(struct clk_hw *hw, struct clk_rate_request *req)
 {
 	struct clk_regmap *clk = to_clk_regmap(hw);
 	struct meson_clk_mpll_data *mpll = meson_clk_mpll_data(clk);
 	unsigned int sdm, n2;
+	long rate;
+
+	params_from_rate(req->rate, req->best_parent_rate, &sdm, &n2,
+			 mpll->flags);
 
-	params_from_rate(rate, *parent_rate, &sdm, &n2, mpll->flags);
-	return rate_from_params(*parent_rate, sdm, n2);
+	rate = rate_from_params(req->best_parent_rate, sdm, n2);
+	if (rate < 0)
+		return rate;
+
+	req->rate = rate;
+	return 0;
 }
 
 static int mpll_set_rate(struct clk_hw *hw,
@@ -118,6 +127,9 @@ static int mpll_set_rate(struct clk_hw *hw,
 	/* Set the fractional part */
 	meson_parm_write(clk->map, &mpll->sdm, sdm);
 
+	/* Enable or disable the fractional part as needed */
+	meson_parm_write(clk->map, &mpll->sdm_en, sdm > 0 ? 1 : 0);
+
 	/* Set the integer divider part */
 	meson_parm_write(clk->map, &mpll->n2, n2);
 
@@ -138,9 +150,6 @@ static int mpll_init(struct clk_hw *hw)
 		regmap_multi_reg_write(clk->map, mpll->init_regs,
 				       mpll->init_count);
 
-	/* Enable the fractional part */
-	meson_parm_write(clk->map, &mpll->sdm_en, 1);
-
 	/* Set spread spectrum if possible */
 	if (MESON_PARM_APPLICABLE(&mpll->ssen)) {
 		unsigned int ss =
@@ -157,13 +166,13 @@ static int mpll_init(struct clk_hw *hw)
 
 const struct clk_ops meson_clk_mpll_ro_ops = {
 	.recalc_rate	= mpll_recalc_rate,
-	.round_rate	= mpll_round_rate,
+	.determine_rate	= mpll_determine_rate,
 };
 EXPORT_SYMBOL_GPL(meson_clk_mpll_ro_ops);
 
 const struct clk_ops meson_clk_mpll_ops = {
 	.recalc_rate	= mpll_recalc_rate,
-	.round_rate	= mpll_round_rate,
+	.determine_rate	= mpll_determine_rate,
 	.set_rate	= mpll_set_rate,
 	.init		= mpll_init,
 };
diff --git a/drivers/clk/meson/meson8b.c b/drivers/clk/meson/meson8b.c
index 827e78fb16a8..dbbfaf2efd62 100644
--- a/drivers/clk/meson/meson8b.c
+++ b/drivers/clk/meson/meson8b.c
@@ -18,6 +18,7 @@
 
 #include "meson8b.h"
 #include "clk-regmap.h"
+#include "clk-phase.h"
 #include "clk-pll.h"
 #include "clk-mpll.h"
 
@@ -606,7 +607,24 @@ static struct clk_regmap meson8b_mpll2 = {
 	},
 };
 
-static u32 mux_table_clk81[]	= { 6, 5, 7 };
+static struct clk_regmap meson8b_mpeg_rtc_osc_sel = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = HHI_MPEG_CLK_CNTL,
+		.mask = 0x1,
+		.shift = 9,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "mpeg_rtc_osc_sel",
+		.ops = &clk_regmap_mux_ro_ops,
+		.parent_data = (const struct clk_parent_data[]) {
+			{ .fw_name = "xtal", .index = -1, },
+			{ .fw_name = "rtc_32k", .index = -1, },
+		},
+		.num_parents = 2,
+	},
+};
+
+static u32 mux_table_clk81[] = { 0, 6, 5, 7 };
 static struct clk_regmap meson8b_mpeg_clk_sel = {
 	.data = &(struct clk_regmap_mux_data){
 		.offset = HHI_MPEG_CLK_CNTL,
@@ -623,11 +641,12 @@ static struct clk_regmap meson8b_mpeg_clk_sel = {
 		 * fclk_div4, fclk_div3, fclk_div5
 		 */
 		.parent_hws = (const struct clk_hw *[]) {
+			&meson8b_mpeg_rtc_osc_sel.hw,
 			&meson8b_fclk_div3.hw,
 			&meson8b_fclk_div4.hw,
 			&meson8b_fclk_div5.hw,
 		},
-		.num_parents = 3,
+		.num_parents = 4,
 	},
 };
 
@@ -2678,6 +2697,78 @@ static struct clk_regmap meson8b_cts_i958 = {
 	},
 };
 
+static u32 meson8_eth_clk_mux_table[] = { 7 };
+
+static struct clk_regmap meson8_eth_clk_sel = {
+	.data = &(struct clk_regmap_mux_data) {
+		.offset = HHI_ETH_CLK_CNTL,
+		.mask = 0x7,
+		.shift = 9,
+		.table = meson8_eth_clk_mux_table,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "eth_clk_sel",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = &(const struct clk_parent_data) {
+			/* TODO: all other parents are unknown */
+			.fw_name = "rmii_clk",
+		},
+		.num_parents = 1,
+	},
+};
+
+static struct clk_regmap meson8_eth_clk_div = {
+	.data = &(struct clk_regmap_div_data) {
+		.offset = HHI_ETH_CLK_CNTL,
+		.shift = 0,
+		.width = 8,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "eth_clk_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&meson8_eth_clk_sel.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap meson8_eth_clk_phase = {
+	.data = &(struct meson_clk_phase_data) {
+		.ph = {
+			.reg_off = HHI_ETH_CLK_CNTL,
+			.shift = 14,
+			.width = 1,
+		},
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "eth_clk_inverted",
+		.ops = &meson_clk_phase_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&meson8_eth_clk_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap meson8_eth_clk_gate = {
+	.data = &(struct clk_regmap_gate_data) {
+		.offset = HHI_ETH_CLK_CNTL,
+		.bit_idx = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "eth_clk_en",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&meson8_eth_clk_phase.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
 #define MESON_GATE(_name, _reg, _bit) \
 	MESON_PCLK(_name, _reg, _bit, &meson8b_clk81.hw)
 
@@ -2975,6 +3066,11 @@ static struct clk_hw_onecell_data meson8_hw_onecell_data = {
 		[CLKID_CTS_I958]	    = &meson8b_cts_i958.hw,
 		[CLKID_VID_PLL_LVDS_EN]	    = &meson8b_vid_pll_lvds_en.hw,
 		[CLKID_HDMI_PLL_DCO_IN]	    = &hdmi_pll_dco_in.hw,
+		[CLKID_ETH_CLK_SEL]	    = &meson8_eth_clk_sel.hw,
+		[CLKID_ETH_CLK_DIV]	    = &meson8_eth_clk_div.hw,
+		[CLKID_ETH_CLK_PHASE]	    = &meson8_eth_clk_phase.hw,
+		[CLKID_ETH_CLK]		    = &meson8_eth_clk_gate.hw,
+		[CLKID_MPEG_RTC_OSC_SEL]    = &meson8b_mpeg_rtc_osc_sel.hw,
 		[CLK_NR_CLKS]		    = NULL,
 	},
 	.num = CLK_NR_CLKS,
@@ -3194,6 +3290,7 @@ static struct clk_hw_onecell_data meson8b_hw_onecell_data = {
 		[CLKID_CTS_I958]	    = &meson8b_cts_i958.hw,
 		[CLKID_VID_PLL_LVDS_EN]	    = &meson8b_vid_pll_lvds_en.hw,
 		[CLKID_HDMI_PLL_DCO_IN]	    = &hdmi_pll_dco_in.hw,
+		[CLKID_MPEG_RTC_OSC_SEL]    = &meson8b_mpeg_rtc_osc_sel.hw,
 		[CLK_NR_CLKS]		    = NULL,
 	},
 	.num = CLK_NR_CLKS,
@@ -3415,6 +3512,7 @@ static struct clk_hw_onecell_data meson8m2_hw_onecell_data = {
 		[CLKID_CTS_I958]	    = &meson8b_cts_i958.hw,
 		[CLKID_VID_PLL_LVDS_EN]	    = &meson8b_vid_pll_lvds_en.hw,
 		[CLKID_HDMI_PLL_DCO_IN]	    = &hdmi_pll_dco_in.hw,
+		[CLKID_MPEG_RTC_OSC_SEL]    = &meson8b_mpeg_rtc_osc_sel.hw,
 		[CLK_NR_CLKS]		    = NULL,
 	},
 	.num = CLK_NR_CLKS,
@@ -3614,6 +3712,11 @@ static struct clk_regmap *const meson8b_clk_regmaps[] = {
 	&meson8b_cts_mclk_i958,
 	&meson8b_cts_i958,
 	&meson8b_vid_pll_lvds_en,
+	&meson8_eth_clk_sel,
+	&meson8_eth_clk_div,
+	&meson8_eth_clk_phase,
+	&meson8_eth_clk_gate,
+	&meson8b_mpeg_rtc_osc_sel,
 };
 
 static const struct meson8b_clk_reset_line {
diff --git a/drivers/clk/meson/meson8b.h b/drivers/clk/meson/meson8b.h
index ce62ed47cbfc..64a18dded5dc 100644
--- a/drivers/clk/meson/meson8b.h
+++ b/drivers/clk/meson/meson8b.h
@@ -43,6 +43,7 @@
 #define HHI_MALI_CLK_CNTL		0x1b0 /* 0x6c offset in data sheet */
 #define HHI_VPU_CLK_CNTL		0x1bc /* 0x6f offset in data sheet */
 #define HHI_HDMI_CLK_CNTL		0x1cc /* 0x73 offset in data sheet */
+#define HHI_ETH_CLK_CNTL		0x1d8 /* 0x76 offset in data sheet */
 #define HHI_VDEC_CLK_CNTL		0x1e0 /* 0x78 offset in data sheet */
 #define HHI_VDEC2_CLK_CNTL		0x1e4 /* 0x79 offset in data sheet */
 #define HHI_VDEC3_CLK_CNTL		0x1e8 /* 0x7a offset in data sheet */
@@ -184,8 +185,12 @@
 #define CLKID_VCLK2_EN		215
 #define CLKID_VID_PLL_LVDS_EN	216
 #define CLKID_HDMI_PLL_DCO_IN   217
+#define CLKID_ETH_CLK_SEL	218
+#define CLKID_ETH_CLK_DIV	219
+#define CLKID_ETH_CLK_PHASE	220
+#define CLKID_MPEG_RTC_OSC_SEL	222
 
-#define CLK_NR_CLKS		218
+#define CLK_NR_CLKS		223
 
 /*
  * include the CLKID and RESETID that have
diff --git a/drivers/clk/meson/sclk-div.c b/drivers/clk/meson/sclk-div.c
index 76d31c0a3342..d12c45c4c261 100644
--- a/drivers/clk/meson/sclk-div.c
+++ b/drivers/clk/meson/sclk-div.c
@@ -96,16 +96,17 @@ static int sclk_div_bestdiv(struct clk_hw *hw, unsigned long rate,
 	return bestdiv;
 }
 
-static long sclk_div_round_rate(struct clk_hw *hw, unsigned long rate,
-				unsigned long *prate)
+static int sclk_div_determine_rate(struct clk_hw *hw,
+				   struct clk_rate_request *req)
 {
 	struct clk_regmap *clk = to_clk_regmap(hw);
 	struct meson_sclk_div_data *sclk = meson_sclk_div_data(clk);
 	int div;
 
-	div = sclk_div_bestdiv(hw, rate, prate, sclk);
+	div = sclk_div_bestdiv(hw, req->rate, &req->best_parent_rate, sclk);
+	req->rate = DIV_ROUND_UP_ULL((u64)req->best_parent_rate, div);
 
-	return DIV_ROUND_UP_ULL((u64)*prate, div);
+	return 0;
 }
 
 static void sclk_apply_ratio(struct clk_regmap *clk,
@@ -237,7 +238,7 @@ static int sclk_div_init(struct clk_hw *hw)
 
 const struct clk_ops meson_sclk_div_ops = {
 	.recalc_rate	= sclk_div_recalc_rate,
-	.round_rate	= sclk_div_round_rate,
+	.determine_rate	= sclk_div_determine_rate,
 	.set_rate	= sclk_div_set_rate,
 	.enable		= sclk_div_enable,
 	.disable	= sclk_div_disable,
diff --git a/drivers/gpu/drm/meson/Kconfig b/drivers/gpu/drm/meson/Kconfig
index 823909da87db..2fe1e4cc44ad 100644
--- a/drivers/gpu/drm/meson/Kconfig
+++ b/drivers/gpu/drm/meson/Kconfig
@@ -10,6 +10,7 @@ config DRM_MESON
 	select REGMAP_MMIO
 	select MESON_CANVAS
 	select CEC_CORE if CEC_NOTIFIER
+	imply PHY_MESON_CVBS_DAC
 
 config DRM_MESON_DW_HDMI
 	tristate "HDMI Synopsys Controller support for Amlogic Meson Display"
@@ -17,3 +18,13 @@ config DRM_MESON_DW_HDMI
 	default y if DRM_MESON
 	select DRM_DW_HDMI
 	imply DRM_DW_HDMI_I2S_AUDIO
+
+config DRM_MESON_TRANSWITCH_HDMI
+	tristate "Amlogic Meson8/8b/8m2 TranSwitch HDMI 1.4 Controller support"
+	depends on ARM || COMPILE_TEST
+	depends on DRM_MESON
+	default y if DRM_MESON
+	select DRM_DISPLAY_HDMI_HELPER
+	select DRM_DISPLAY_HELPER
+	select REGMAP_MMIO
+	select SND_SOC_HDMI_CODEC if SND_SOC
diff --git a/drivers/gpu/drm/meson/Makefile b/drivers/gpu/drm/meson/Makefile
index 3afa31bdc950..817a5270aee6 100644
--- a/drivers/gpu/drm/meson/Makefile
+++ b/drivers/gpu/drm/meson/Makefile
@@ -6,3 +6,4 @@ meson-drm-y += meson_encoder_hdmi.o
 
 obj-$(CONFIG_DRM_MESON) += meson-drm.o
 obj-$(CONFIG_DRM_MESON_DW_HDMI) += meson_dw_hdmi.o
+obj-$(CONFIG_DRM_MESON_TRANSWITCH_HDMI) += meson_transwitch_hdmi.o
diff --git a/drivers/gpu/drm/meson/meson_drv.h b/drivers/gpu/drm/meson/meson_drv.h
index c62ee358456f..fe0a8f8762fd 100644
--- a/drivers/gpu/drm/meson/meson_drv.h
+++ b/drivers/gpu/drm/meson/meson_drv.h
@@ -7,22 +7,29 @@
 #ifndef __MESON_DRV_H
 #define __MESON_DRV_H
 
+#include <linux/clk.h>
 #include <linux/device.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
 #include <linux/regmap.h>
+#include <linux/reset.h>
 
 struct drm_crtc;
 struct drm_device;
 struct drm_plane;
 struct meson_drm;
 struct meson_afbcd_ops;
+struct phy;
+struct platform_device;
 
 enum vpu_compatible {
-	VPU_COMPATIBLE_GXBB = 0,
-	VPU_COMPATIBLE_GXL  = 1,
-	VPU_COMPATIBLE_GXM  = 2,
-	VPU_COMPATIBLE_G12A = 3,
+	VPU_COMPATIBLE_M8 = 0,
+	VPU_COMPATIBLE_M8B = 1,
+	VPU_COMPATIBLE_M8M2 = 2,
+	VPU_COMPATIBLE_GXBB = 3,
+	VPU_COMPATIBLE_GXL  = 4,
+	VPU_COMPATIBLE_GXM  = 5,
+	VPU_COMPATIBLE_G12A = 6,
 };
 
 enum {
@@ -40,6 +47,25 @@ struct meson_drm_soc_limits {
 	unsigned int max_hdmi_phy_freq;
 };
 
+enum vpu_bulk_clk_id {
+	VPU_VID_CLK_TMDS = 0,
+	VPU_VID_CLK_HDMI_TX_PIXEL,
+	VPU_VID_CLK_CTS_ENCP,
+	VPU_VID_CLK_CTS_ENCI,
+	VPU_VID_CLK_CTS_ENCT,
+	VPU_VID_CLK_CTS_ENCL,
+	VPU_VID_CLK_CTS_VDAC0,
+	VPU_VID_CLK_NUM
+};
+
+enum vpu_bulk_vid_pll_reset_id {
+	VPU_RESET_VID_PLL_PRE = 0,
+	VPU_RESET_VID_PLL_POST,
+	VPU_RESET_VID_PLL_SOFT_PRE,
+	VPU_RESET_VID_PLL_SOFT_POST,
+	VPU_RESET_VID_PLL_NUM
+};
+
 struct meson_drm {
 	struct device *dev;
 	enum vpu_compatible compat;
@@ -61,6 +87,21 @@ struct meson_drm {
 
 	const struct meson_drm_soc_limits *limits;
 
+	struct phy *cvbs_dac;
+	bool cvbs_dac_enabled;
+	struct platform_device *cvbs_dac_pdev;
+
+	struct clk_bulk_data intr_clks[3];
+	unsigned int num_intr_clks;
+	bool intr_clks_enabled;
+	struct clk_bulk_data vid_clks[VPU_VID_CLK_NUM];
+	bool vid_clk_rate_exclusive[VPU_VID_CLK_NUM];
+	struct clk *clk_venc;
+	bool clk_venc_enabled;
+	struct clk *clk_dac;
+	bool clk_dac_enabled;
+	struct reset_control_bulk_data vid_pll_resets[VPU_RESET_VID_PLL_NUM];
+
 	/* Components Data */
 	struct {
 		bool osd1_enabled;
diff --git a/drivers/gpu/drm/meson/meson_encoder_cvbs.c b/drivers/gpu/drm/meson/meson_encoder_cvbs.c
index 3f73b211fa8e..833f701fe271 100644
--- a/drivers/gpu/drm/meson/meson_encoder_cvbs.c
+++ b/drivers/gpu/drm/meson/meson_encoder_cvbs.c
@@ -11,6 +11,7 @@
 
 #include <linux/export.h>
 #include <linux/of_graph.h>
+#include <linux/phy/phy.h>
 
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_bridge.h>
@@ -24,12 +25,6 @@
 #include "meson_vclk.h"
 #include "meson_encoder_cvbs.h"
 
-/* HHI VDAC Registers */
-#define HHI_VDAC_CNTL0		0x2F4 /* 0xbd offset in data sheet */
-#define HHI_VDAC_CNTL0_G12A	0x2EC /* 0xbd offset in data sheet */
-#define HHI_VDAC_CNTL1		0x2F8 /* 0xbe offset in data sheet */
-#define HHI_VDAC_CNTL1_G12A	0x2F0 /* 0xbe offset in data sheet */
-
 struct meson_encoder_cvbs {
 	struct drm_encoder	encoder;
 	struct drm_bridge	bridge;
@@ -87,11 +82,28 @@ static int meson_encoder_cvbs_attach(struct drm_bridge *bridge,
 {
 	struct meson_encoder_cvbs *meson_encoder_cvbs =
 					bridge_to_meson_encoder_cvbs(bridge);
+	int ret;
+
+	ret = phy_init(meson_encoder_cvbs->priv->cvbs_dac);
+	if (ret)
+		return ret;
 
 	return drm_bridge_attach(bridge->encoder, meson_encoder_cvbs->next_bridge,
 				 &meson_encoder_cvbs->bridge, flags);
 }
 
+static void meson_encoder_cvbs_detach(struct drm_bridge *bridge)
+{
+	struct meson_encoder_cvbs *meson_encoder_cvbs =
+					bridge_to_meson_encoder_cvbs(bridge);
+	int ret;
+
+	ret = phy_exit(meson_encoder_cvbs->priv->cvbs_dac);
+	if (ret)
+		dev_err(meson_encoder_cvbs->priv->dev,
+			"Failed to exit the CVBS DAC\n");
+}
+
 static int meson_encoder_cvbs_get_modes(struct drm_bridge *bridge,
 					struct drm_connector *connector)
 {
@@ -148,6 +160,7 @@ static void meson_encoder_cvbs_atomic_enable(struct drm_bridge *bridge,
 	struct drm_connector_state *conn_state;
 	struct drm_crtc_state *crtc_state;
 	struct drm_connector *connector;
+	int ret;
 
 	connector = drm_atomic_get_new_connector_for_encoder(state, bridge->encoder);
 	if (WARN_ON(!connector))
@@ -177,16 +190,13 @@ static void meson_encoder_cvbs_atomic_enable(struct drm_bridge *bridge,
 	writel_bits_relaxed(VENC_VDAC_SEL_ATV_DMD, 0,
 			    priv->io_base + _REG(VENC_VDAC_DACSEL0));
 
-	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXBB)) {
-		regmap_write(priv->hhi, HHI_VDAC_CNTL0, 1);
-		regmap_write(priv->hhi, HHI_VDAC_CNTL1, 0);
-	} else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM) ||
-		 meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXL)) {
-		regmap_write(priv->hhi, HHI_VDAC_CNTL0, 0xf0001);
-		regmap_write(priv->hhi, HHI_VDAC_CNTL1, 0);
-	} else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
-		regmap_write(priv->hhi, HHI_VDAC_CNTL0_G12A, 0x906001);
-		regmap_write(priv->hhi, HHI_VDAC_CNTL1_G12A, 0);
+	if (!priv->cvbs_dac_enabled) {
+		ret = phy_power_on(priv->cvbs_dac);
+		if (ret)
+			dev_err(priv->dev,
+				"Failed to power on the CVBS DAC\n");
+		else
+			priv->cvbs_dac_enabled = true;
 	}
 }
 
@@ -196,19 +206,22 @@ static void meson_encoder_cvbs_atomic_disable(struct drm_bridge *bridge,
 	struct meson_encoder_cvbs *meson_encoder_cvbs =
 					bridge_to_meson_encoder_cvbs(bridge);
 	struct meson_drm *priv = meson_encoder_cvbs->priv;
+	int ret;
 
-	/* Disable CVBS VDAC */
-	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
-		regmap_write(priv->hhi, HHI_VDAC_CNTL0_G12A, 0);
-		regmap_write(priv->hhi, HHI_VDAC_CNTL1_G12A, 0);
-	} else {
-		regmap_write(priv->hhi, HHI_VDAC_CNTL0, 0);
-		regmap_write(priv->hhi, HHI_VDAC_CNTL1, 8);
-	}
+	if (!priv->cvbs_dac_enabled)
+		return;
+
+	ret = phy_power_off(priv->cvbs_dac);
+	if (ret)
+		dev_err(priv->dev,
+			"Failed to power off the CVBS DAC\n");
+	else
+		priv->cvbs_dac_enabled = false;
 }
 
 static const struct drm_bridge_funcs meson_encoder_cvbs_bridge_funcs = {
 	.attach = meson_encoder_cvbs_attach,
+	.detach = meson_encoder_cvbs_detach,
 	.mode_valid = meson_encoder_cvbs_mode_valid,
 	.get_modes = meson_encoder_cvbs_get_modes,
 	.atomic_enable = meson_encoder_cvbs_atomic_enable,
diff --git a/drivers/gpu/drm/meson/meson_encoder_hdmi.c b/drivers/gpu/drm/meson/meson_encoder_hdmi.c
index 53231bfdf7e2..950ccb1ec7cd 100644
--- a/drivers/gpu/drm/meson/meson_encoder_hdmi.c
+++ b/drivers/gpu/drm/meson/meson_encoder_hdmi.c
@@ -188,13 +188,13 @@ static void meson_encoder_hdmi_atomic_enable(struct drm_bridge *bridge,
 {
 	struct meson_encoder_hdmi *encoder_hdmi = bridge_to_meson_encoder_hdmi(bridge);
 	struct drm_atomic_state *state = bridge_state->base.state;
-	unsigned int ycrcb_map = VPU_HDMI_OUTPUT_CBYCR;
 	struct meson_drm *priv = encoder_hdmi->priv;
 	struct drm_connector_state *conn_state;
 	const struct drm_display_mode *mode;
 	struct drm_crtc_state *crtc_state;
 	struct drm_connector *connector;
 	bool yuv420_mode = false;
+	unsigned int ycrcb_map;
 	int vic;
 
 	connector = drm_atomic_get_new_connector_for_encoder(state, bridge->encoder);
@@ -215,11 +215,21 @@ static void meson_encoder_hdmi_atomic_enable(struct drm_bridge *bridge,
 
 	dev_dbg(priv->dev, "\"%s\" vic %d\n", mode->name, vic);
 
-	if (encoder_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYYVYY8_0_5X24) {
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2)) {
+		if (encoder_hdmi->output_bus_fmt == MEDIA_BUS_FMT_RGB888_1X24)
+			ycrcb_map = VPU_HDMI_OUTPUT_YCBCR;
+		else
+			ycrcb_map = VPU_HDMI_OUTPUT_CRYCB;
+	} else if (encoder_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYYVYY8_0_5X24) {
 		ycrcb_map = VPU_HDMI_OUTPUT_CRYCB;
 		yuv420_mode = true;
-	} else if (encoder_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYVY8_1X16)
+	} else if (encoder_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYVY8_1X16) {
 		ycrcb_map = VPU_HDMI_OUTPUT_CRYCB;
+	} else {
+		ycrcb_map = VPU_HDMI_OUTPUT_CBYCR;
+	}
 
 	/* VENC + VENC-DVI Mode setup */
 	meson_venc_hdmi_mode_set(priv, vic, ycrcb_map, yuv420_mode, mode);
@@ -227,17 +237,21 @@ static void meson_encoder_hdmi_atomic_enable(struct drm_bridge *bridge,
 	/* VCLK Set clock */
 	meson_encoder_hdmi_set_vclk(encoder_hdmi, mode);
 
-	if (encoder_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYYVYY8_0_5X24)
-		/* Setup YUV420 to HDMI-TX, no 10bit diphering */
-		writel_relaxed(2 | (2 << 2),
-			       priv->io_base + _REG(VPU_HDMI_FMT_CTRL));
-	else if (encoder_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYVY8_1X16)
-		/* Setup YUV422 to HDMI-TX, no 10bit diphering */
-		writel_relaxed(1 | (2 << 2),
-				priv->io_base + _REG(VPU_HDMI_FMT_CTRL));
-	else
-		/* Setup YUV444 to HDMI-TX, no 10bit diphering */
-		writel_relaxed(0, priv->io_base + _REG(VPU_HDMI_FMT_CTRL));
+	if (!meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) &&
+	    !meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) &&
+	    !meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2)) {
+		if (encoder_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYYVYY8_0_5X24)
+			/* Setup YUV420 to HDMI-TX, no 10bit diphering */
+			writel_relaxed(2 | (2 << 2),
+				       priv->io_base + _REG(VPU_HDMI_FMT_CTRL));
+		else if (encoder_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYVY8_1X16)
+			/* Setup YUV422 to HDMI-TX, no 10bit diphering */
+			writel_relaxed(1 | (2 << 2),
+				       priv->io_base + _REG(VPU_HDMI_FMT_CTRL));
+		else
+			/* Setup YUV444 to HDMI-TX, no 10bit diphering */
+			writel_relaxed(0, priv->io_base + _REG(VPU_HDMI_FMT_CTRL));
+	}
 
 	dev_dbg(priv->dev, "%s\n", priv->venc.hdmi_use_enci ? "VENCI" : "VENCP");
 
@@ -260,7 +274,11 @@ static void meson_encoder_hdmi_atomic_disable(struct drm_bridge *bridge,
 	writel_relaxed(0, priv->io_base + _REG(ENCP_VIDEO_EN));
 }
 
-static const u32 meson_encoder_hdmi_out_bus_fmts[] = {
+static const u32 meson8_encoder_hdmi_out_bus_fmts[] = {
+	MEDIA_BUS_FMT_YUV8_1X24,
+};
+
+static const u32 meson_gx_encoder_hdmi_out_bus_fmts[] = {
 	MEDIA_BUS_FMT_YUV8_1X24,
 	MEDIA_BUS_FMT_UYVY8_1X16,
 	MEDIA_BUS_FMT_UYYVYY8_0_5X24,
@@ -274,13 +292,27 @@ meson_encoder_hdmi_get_inp_bus_fmts(struct drm_bridge *bridge,
 					u32 output_fmt,
 					unsigned int *num_input_fmts)
 {
+	struct meson_encoder_hdmi *encoder_hdmi = bridge_to_meson_encoder_hdmi(bridge);
+	struct meson_drm *priv = encoder_hdmi->priv;
+	unsigned int num_out_bus_fmts;
+	const u32 *out_bus_fmts;
 	u32 *input_fmts = NULL;
 	int i;
 
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2)) {
+		num_out_bus_fmts = ARRAY_SIZE(meson8_encoder_hdmi_out_bus_fmts);
+		out_bus_fmts = meson8_encoder_hdmi_out_bus_fmts;
+	} else {
+		num_out_bus_fmts = ARRAY_SIZE(meson_gx_encoder_hdmi_out_bus_fmts);
+		out_bus_fmts = meson_gx_encoder_hdmi_out_bus_fmts;
+	}
+
 	*num_input_fmts = 0;
 
-	for (i = 0 ; i < ARRAY_SIZE(meson_encoder_hdmi_out_bus_fmts) ; ++i) {
-		if (output_fmt == meson_encoder_hdmi_out_bus_fmts[i]) {
+	for (i = 0 ; i < num_out_bus_fmts ; ++i) {
+		if (output_fmt == out_bus_fmts[i]) {
 			*num_input_fmts = 1;
 			input_fmts = kcalloc(*num_input_fmts,
 					     sizeof(*input_fmts),
@@ -432,8 +464,11 @@ int meson_encoder_hdmi_init(struct meson_drm *priv)
 
 	drm_connector_attach_max_bpc_property(meson_encoder_hdmi->connector, 8, 8);
 
-	/* Handle this here until handled by drm_bridge_connector_init() */
-	meson_encoder_hdmi->connector->ycbcr_420_allowed = true;
+	if (!meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) &&
+	    !meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) &&
+	    !meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2))
+		/* Handle this here until handled by drm_bridge_connector_init() */
+		meson_encoder_hdmi->connector->ycbcr_420_allowed = true;
 
 	pdev = of_find_device_by_node(remote);
 	of_node_put(remote);
diff --git a/drivers/gpu/drm/meson/meson_plane.c b/drivers/gpu/drm/meson/meson_plane.c
index 815dfe30492b..27e39577218c 100644
--- a/drivers/gpu/drm/meson/meson_plane.c
+++ b/drivers/gpu/drm/meson/meson_plane.c
@@ -200,8 +200,11 @@ static void meson_plane_atomic_update(struct drm_plane *plane,
 			priv->viu.osd1_ctrl_stat2 &= ~OSD_DPATH_MALI_AFBCD;
 	}
 
-	/* On GXBB, Use the old non-HDR RGB2YUV converter */
-	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXBB))
+	/* On GXBB and earlier, Use the old non-HDR RGB2YUV converter */
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXBB))
 		priv->viu.osd1_blk0_cfg[0] |= OSD_OUTPUT_COLOR_RGB;
 
 	if (priv->viu.osd1_afbcd &&
@@ -471,7 +474,20 @@ static const struct drm_plane_funcs meson_plane_funcs = {
 	.format_mod_supported   = meson_plane_format_mod_supported,
 };
 
-static const uint32_t supported_drm_formats[] = {
+/*
+ * X components (for example in DRM_FORMAT_XRGB8888 and DRM_FORMAT_XBGR8888)
+ * are not supported because these older SoC's are lacking the OSD_REPLACE_EN
+ * bit to replace the X alpha component with a static value, leaving the alpha
+ * component in an undefined state.
+ */
+static const uint32_t supported_drm_formats_m8[] = {
+	DRM_FORMAT_ARGB8888,
+	DRM_FORMAT_ABGR8888,
+	DRM_FORMAT_RGB888,
+	DRM_FORMAT_RGB565,
+};
+
+static const uint32_t supported_drm_formats_gx[] = {
 	DRM_FORMAT_ARGB8888,
 	DRM_FORMAT_ABGR8888,
 	DRM_FORMAT_XRGB8888,
@@ -533,6 +549,8 @@ int meson_plane_create(struct meson_drm *priv)
 {
 	struct meson_plane *meson_plane;
 	struct drm_plane *plane;
+	unsigned int num_drm_formats;
+	const uint32_t *drm_formats;
 	const uint64_t *format_modifiers = format_modifiers_default;
 	int ret;
 
@@ -549,10 +567,19 @@ int meson_plane_create(struct meson_drm *priv)
 	else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A))
 		format_modifiers = format_modifiers_afbc_g12a;
 
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2)) {
+		drm_formats = supported_drm_formats_m8;
+		num_drm_formats = ARRAY_SIZE(supported_drm_formats_m8);
+	} else {
+		drm_formats = supported_drm_formats_gx;
+		num_drm_formats = ARRAY_SIZE(supported_drm_formats_gx);
+	}
+
 	ret = drm_universal_plane_init(priv->drm, plane, 0xFF,
 					&meson_plane_funcs,
-					supported_drm_formats,
-					ARRAY_SIZE(supported_drm_formats),
+					drm_formats, num_drm_formats,
 					format_modifiers,
 					DRM_PLANE_TYPE_PRIMARY, "meson_primary_plane");
 	if (ret) {
diff --git a/drivers/gpu/drm/meson/meson_transwitch_hdmi.c b/drivers/gpu/drm/meson/meson_transwitch_hdmi.c
new file mode 100644
index 000000000000..619f5e9ac26d
--- /dev/null
+++ b/drivers/gpu/drm/meson/meson_transwitch_hdmi.c
@@ -0,0 +1,1578 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2021 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ *
+ * All registers and magic values are taken from Amlogic's GPL kernel sources:
+ *   Copyright (C) 2010 Amlogic, Inc.
+ */
+
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+
+#include <drm/display/drm_hdmi_helper.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_bridge.h>
+#include <drm/drm_connector.h>
+#include <drm/drm_device.h>
+#include <drm/drm_edid.h>
+#include <drm/drm_probe_helper.h>
+#include <drm/drm_print.h>
+
+#include <sound/hdmi-codec.h>
+
+#include <uapi/linux/media-bus-format.h>
+
+#include "meson_transwitch_hdmi.h"
+
+#define HDMI_ADDR_PORT					0x0
+#define HDMI_DATA_PORT					0x4
+#define HDMI_CTRL_PORT					0x8
+	#define HDMI_CTRL_PORT_APB3_ERR_EN		BIT(15)
+
+struct meson_txc_hdmi {
+	struct device			*dev;
+
+	struct regmap			*regmap;
+
+	struct clk			*pclk;
+	struct clk			*sys_clk;
+
+	struct phy			*phy;
+	bool				phy_is_on;
+
+	struct mutex			codec_mutex;
+	enum drm_connector_status	last_connector_status;
+	hdmi_codec_plugged_cb		codec_plugged_cb;
+	struct device			*codec_dev;
+
+	struct platform_device		*hdmi_codec_pdev;
+
+	struct drm_connector		*current_connector;
+
+	struct drm_bridge		bridge;
+	struct drm_bridge		*next_bridge;
+
+	bool				sink_is_hdmi;
+};
+
+#define bridge_to_meson_txc_hdmi(x) container_of(x, struct meson_txc_hdmi, bridge)
+
+static const struct regmap_range meson_txc_hdmi_regmap_ranges[] = {
+	regmap_reg_range(0x0000, 0x07ff),
+	regmap_reg_range(0x8000, 0x800c),
+};
+
+static const struct regmap_access_table meson_txc_hdmi_regmap_access = {
+	.yes_ranges = meson_txc_hdmi_regmap_ranges,
+	.n_yes_ranges = ARRAY_SIZE(meson_txc_hdmi_regmap_ranges),
+};
+
+static int meson_txc_hdmi_reg_read(void *context, unsigned int addr,
+				   unsigned int *data)
+{
+	void __iomem *base = context;
+
+	writel(addr, base + HDMI_ADDR_PORT);
+	writel(addr, base + HDMI_ADDR_PORT);
+
+	*data = readl(base + HDMI_DATA_PORT);
+
+	return 0;
+}
+
+static int meson_txc_hdmi_reg_write(void *context, unsigned int addr,
+				    unsigned int data)
+{
+	void __iomem *base = context;
+
+	writel(addr, base + HDMI_ADDR_PORT);
+	writel(addr, base + HDMI_ADDR_PORT);
+
+	writel(data, base + HDMI_DATA_PORT);
+
+	return 0;
+}
+
+static const struct regmap_config meson_txc_hdmi_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 16,
+	.reg_stride = 1,
+	.reg_read = meson_txc_hdmi_reg_read,
+	.reg_write = meson_txc_hdmi_reg_write,
+	.rd_table = &meson_txc_hdmi_regmap_access,
+	.wr_table = &meson_txc_hdmi_regmap_access,
+	.max_register = HDMI_OTHER_RX_PACKET_INTR_CLR,
+	.fast_io = true,
+};
+
+static void meson_txc_hdmi_write_infoframe(struct regmap *regmap,
+					   unsigned int tx_pkt_reg, u8 *buf,
+					   unsigned int len, bool enable)
+{
+	unsigned int i;
+
+	/* Write the data bytes by starting at register offset 1 */
+	for (i = HDMI_INFOFRAME_HEADER_SIZE; i < len; i++)
+		regmap_write(regmap,
+			     tx_pkt_reg + i - HDMI_INFOFRAME_HEADER_SIZE + 1,
+			     buf[i]);
+
+	/* Zero all remaining data bytes */
+	for (; i < 0x1c; i++)
+		regmap_write(regmap, tx_pkt_reg + i, 0x00);
+
+	/* Write the header (which we skipped above) */
+	regmap_write(regmap, tx_pkt_reg + 0x00, buf[3]);
+	regmap_write(regmap, tx_pkt_reg + 0x1c, buf[0]);
+	regmap_write(regmap, tx_pkt_reg + 0x1d, buf[1]);
+	regmap_write(regmap, tx_pkt_reg + 0x1e, buf[2]);
+
+	regmap_write(regmap, tx_pkt_reg + 0x1f, enable ? 0xff : 0x00);
+}
+
+static void meson_txc_hdmi_disable_infoframe(struct meson_txc_hdmi *priv,
+					     unsigned int tx_pkt_reg)
+{
+	u8 buf[HDMI_INFOFRAME_HEADER_SIZE] = { 0 };
+
+	meson_txc_hdmi_write_infoframe(priv->regmap, tx_pkt_reg, buf,
+				       HDMI_INFOFRAME_HEADER_SIZE, false);
+}
+
+static void meson_txc_hdmi_sys5_reset_assert(struct meson_txc_hdmi *priv)
+{
+	/* A comment in the vendor driver says: bit5,6 is converted */
+	regmap_write(priv->regmap, TX_SYS5_TX_SOFT_RESET_2,
+		     TX_SYS5_TX_SOFT_RESET_2_HDMI_CH3_RST_IN |
+		     TX_SYS5_TX_SOFT_RESET_2_HDMI_CH0_RST_IN);
+	usleep_range(10, 20);
+
+	regmap_write(priv->regmap, TX_SYS5_TX_SOFT_RESET_2,
+		     TX_SYS5_TX_SOFT_RESET_2_HDMI_CH2_RST_IN |
+		     TX_SYS5_TX_SOFT_RESET_2_HDMI_CH1_RST_IN);
+	usleep_range(10, 20);
+
+	regmap_write(priv->regmap, TX_SYS5_TX_SOFT_RESET_1,
+		     TX_SYS5_TX_SOFT_RESET_1_TX_PIXEL_RSTN |
+		     TX_SYS5_TX_SOFT_RESET_1_TX_TMDS_RSTN |
+		     TX_SYS5_TX_SOFT_RESET_1_TX_AUDIO_MASTER_RSTN |
+		     TX_SYS5_TX_SOFT_RESET_1_TX_AUDIO_RESAMPLE_RSTN |
+		     TX_SYS5_TX_SOFT_RESET_1_TX_I2S_RESET_RSTN |
+		     TX_SYS5_TX_SOFT_RESET_1_TX_DIG_RESET_N_CH2 |
+		     TX_SYS5_TX_SOFT_RESET_1_TX_DIG_RESET_N_CH1 |
+		     TX_SYS5_TX_SOFT_RESET_1_TX_DIG_RESET_N_CH0);
+	usleep_range(10, 20);
+}
+
+static void meson_txc_hdmi_sys5_reset_deassert(struct meson_txc_hdmi *priv)
+{
+	/* Release the resets except tmds_clk */
+	regmap_write(priv->regmap, TX_SYS5_TX_SOFT_RESET_1,
+		     TX_SYS5_TX_SOFT_RESET_1_TX_TMDS_RSTN);
+	usleep_range(10, 20);
+
+	/* Release the tmds_clk reset as well */
+	regmap_write(priv->regmap, TX_SYS5_TX_SOFT_RESET_1, 0x0);
+	usleep_range(10, 20);
+
+	regmap_write(priv->regmap, TX_SYS5_TX_SOFT_RESET_2,
+		     TX_SYS5_TX_SOFT_RESET_2_HDMI_CH2_RST_IN |
+		     TX_SYS5_TX_SOFT_RESET_2_HDMI_CH1_RST_IN |
+		     TX_SYS5_TX_SOFT_RESET_2_HDMI_SR_RST);
+	usleep_range(10, 20);
+
+	regmap_write(priv->regmap, TX_SYS5_TX_SOFT_RESET_2,
+		     TX_SYS5_TX_SOFT_RESET_2_HDMI_CH2_RST_IN |
+		     TX_SYS5_TX_SOFT_RESET_2_HDMI_CH1_RST_IN);
+	usleep_range(10, 20);
+}
+
+static void meson_txc_hdmi_config_hdcp_registers(struct meson_txc_hdmi *priv)
+{
+	regmap_write(priv->regmap, TX_HDCP_CONFIG0,
+		     FIELD_PREP(TX_HDCP_CONFIG0_ROM_ENCRYPT_OFF, 0x3));
+	regmap_write(priv->regmap, TX_HDCP_MEM_CONFIG, 0x0);
+	regmap_write(priv->regmap, TX_HDCP_ENCRYPT_BYTE, 0x0);
+
+	regmap_write(priv->regmap, TX_HDCP_MODE, TX_HDCP_MODE_CLEAR_AVMUTE);
+
+	regmap_write(priv->regmap, TX_HDCP_MODE, TX_HDCP_MODE_ESS_CONFIG);
+}
+
+static u8 meson_txc_hdmi_bus_fmt_to_color_depth(unsigned int bus_format)
+{
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_RGB888_1X24:
+	case MEDIA_BUS_FMT_YUV8_1X24:
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+		/* 8 bit */
+		return 0x0;
+
+	case MEDIA_BUS_FMT_RGB101010_1X30:
+	case MEDIA_BUS_FMT_YUV10_1X30:
+	case MEDIA_BUS_FMT_UYVY10_1X20:
+		/* 10 bit */
+		return 0x1;
+
+	case MEDIA_BUS_FMT_RGB121212_1X36:
+	case MEDIA_BUS_FMT_YUV12_1X36:
+	case MEDIA_BUS_FMT_UYVY12_1X24:
+		/* 12 bit */
+		return 0x2;
+
+	case MEDIA_BUS_FMT_RGB161616_1X48:
+	case MEDIA_BUS_FMT_YUV16_1X48:
+		/* 16 bit */
+		return 0x3;
+
+	default:
+		/* unknown, default to 8 bit */
+		return 0x0;
+	}
+}
+
+static u8 meson_txc_hdmi_bus_fmt_to_color_format(unsigned int bus_format)
+{
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_YUV8_1X24:
+	case MEDIA_BUS_FMT_YUV10_1X30:
+	case MEDIA_BUS_FMT_YUV12_1X36:
+	case MEDIA_BUS_FMT_YUV16_1X48:
+		/* Documented as YCbCr444 */
+		return 0x1;
+
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+	case MEDIA_BUS_FMT_UYVY10_1X20:
+	case MEDIA_BUS_FMT_UYVY12_1X24:
+		/* Documented as YCbCr422 */
+		return 0x3;
+
+	case MEDIA_BUS_FMT_RGB888_1X24:
+	case MEDIA_BUS_FMT_RGB101010_1X30:
+	case MEDIA_BUS_FMT_RGB121212_1X36:
+	case MEDIA_BUS_FMT_RGB161616_1X48:
+	default:
+		/* Documented as RGB444 */
+		return 0x0;
+	}
+}
+
+static void meson_txc_hdmi_config_color_space(struct meson_txc_hdmi *priv,
+					      unsigned int input_bus_format,
+					      unsigned int output_bus_format,
+					      enum hdmi_quantization_range quant_range,
+					      enum hdmi_colorimetry colorimetry)
+{
+	unsigned int regval;
+
+	regmap_write(priv->regmap, TX_VIDEO_DTV_MODE,
+		     FIELD_PREP(TX_VIDEO_DTV_MODE_COLOR_DEPTH,
+				meson_txc_hdmi_bus_fmt_to_color_depth(output_bus_format)));
+
+	regmap_write(priv->regmap, TX_VIDEO_DTV_OPTION_L,
+		     FIELD_PREP(TX_VIDEO_DTV_OPTION_L_OUTPUT_COLOR_FORMAT,
+				meson_txc_hdmi_bus_fmt_to_color_format(output_bus_format)) |
+		     FIELD_PREP(TX_VIDEO_DTV_OPTION_L_INPUT_COLOR_FORMAT,
+				meson_txc_hdmi_bus_fmt_to_color_format(input_bus_format)) |
+		     FIELD_PREP(TX_VIDEO_DTV_OPTION_L_OUTPUT_COLOR_DEPTH,
+				meson_txc_hdmi_bus_fmt_to_color_depth(output_bus_format)) |
+		     FIELD_PREP(TX_VIDEO_DTV_OPTION_L_INPUT_COLOR_DEPTH,
+				meson_txc_hdmi_bus_fmt_to_color_depth(input_bus_format)));
+
+	if (quant_range == HDMI_QUANTIZATION_RANGE_LIMITED)
+		regval = FIELD_PREP(TX_VIDEO_DTV_OPTION_H_OUTPUT_COLOR_RANGE,
+				    TX_VIDEO_DTV_OPTION_H_COLOR_RANGE_16_235) |
+			 FIELD_PREP(TX_VIDEO_DTV_OPTION_H_INPUT_COLOR_RANGE,
+				    TX_VIDEO_DTV_OPTION_H_COLOR_RANGE_16_235);
+	else
+		regval = FIELD_PREP(TX_VIDEO_DTV_OPTION_H_OUTPUT_COLOR_RANGE,
+				    TX_VIDEO_DTV_OPTION_H_COLOR_RANGE_0_255) |
+			 FIELD_PREP(TX_VIDEO_DTV_OPTION_H_INPUT_COLOR_RANGE,
+				    TX_VIDEO_DTV_OPTION_H_COLOR_RANGE_0_255);
+
+	regmap_write(priv->regmap, TX_VIDEO_DTV_OPTION_H, regval);
+
+	if (colorimetry == HDMI_COLORIMETRY_ITU_601) {
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_B0, 0x2f);
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_B1, 0x1d);
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_R0, 0x8b);
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_R1, 0x4c);
+
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_CB0, 0x18);
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_CB1, 0x58);
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_CR0, 0xd0);
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_CR1, 0xb6);
+	} else {
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_B0, 0x7b);
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_B1, 0x12);
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_R0, 0x6c);
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_R1, 0x36);
+
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_CB0, 0xf2);
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_CB1, 0x2f);
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_CR0, 0xd4);
+		regmap_write(priv->regmap, TX_VIDEO_CSC_COEFF_CR1, 0x77);
+	}
+}
+
+static void meson_txc_hdmi_config_serializer_clock(struct meson_txc_hdmi *priv,
+						   enum hdmi_colorimetry colorimetry)
+{
+	/* Serializer Internal clock setting */
+	if (colorimetry == HDMI_COLORIMETRY_ITU_601)
+		regmap_write(priv->regmap, TX_SYS1_PLL, 0x24);
+	else
+		regmap_write(priv->regmap, TX_SYS1_PLL, 0x22);
+
+#if 0
+	// TODO: not ported yet
+	if ((param->VIC==HDMI_1080p60)&&(param->color_depth==COLOR_30BIT)&&(hdmi_rd_reg(0x018)==0x22)) {
+		regmap_write(priv->regmap, TX_SYS1_PLL, 0x12);
+	}
+#endif
+}
+
+static void meson_txc_hdmi_reconfig_packet_setting(struct meson_txc_hdmi *priv,
+						   u8 cea_mode)
+{
+	u8 alloc_active2, alloc_eof1, alloc_sof1, alloc_sof2;
+
+	regmap_write(priv->regmap, TX_PACKET_CONTROL_1,
+		     FIELD_PREP(TX_PACKET_CONTROL_1_PACKET_START_LATENCY, 58));
+	regmap_write(priv->regmap, TX_PACKET_CONTROL_2,
+		     TX_PACKET_CONTROL_2_HORIZONTAL_GC_PACKET_TRANSPORT_EN);
+
+	switch (cea_mode) {
+	case 31:
+		/* 1920x1080p50 */
+		alloc_active2 = 0x12;
+		alloc_eof1 = 0x10;
+		alloc_sof1 = 0xb6;
+		alloc_sof2 = 0x11;
+		break;
+	case 93:
+		/* 3840x2160p24 */
+		alloc_active2 = 0x12;
+		alloc_eof1 = 0x47;
+		alloc_sof1 = 0xf8;
+		alloc_sof2 = 0x52;
+		break;
+	case 94:
+		/* 3840x2160p25 */
+		alloc_active2 = 0x12;
+		alloc_eof1 = 0x44;
+		alloc_sof1 = 0xda;
+		alloc_sof2 = 0x52;
+		break;
+	case 95:
+		/* 3840x2160p30 */
+		alloc_active2 = 0x0f;
+		alloc_eof1 = 0x3a;
+		alloc_sof1 = 0x60;
+		alloc_sof2 = 0x52;
+		break;
+	case 98:
+		/* 4096x2160p24 */
+		alloc_active2 = 0x12;
+		alloc_eof1 = 0x47;
+		alloc_sof1 = 0xf8;
+		alloc_sof2 = 0x52;
+		break;
+	default:
+		/* Disable the special packet settings only */
+		regmap_write(priv->regmap, TX_PACKET_ALLOC_ACTIVE_1, 0x00);
+		return;
+	}
+
+	/*
+	 * The vendor driver says: manually configure these register to get
+	 * stable video timings.
+	 */
+	regmap_write(priv->regmap, TX_PACKET_ALLOC_ACTIVE_1, 0x01);
+	regmap_write(priv->regmap, TX_PACKET_ALLOC_ACTIVE_2, alloc_active2);
+	regmap_write(priv->regmap, TX_PACKET_ALLOC_EOF_1, alloc_eof1);
+	regmap_write(priv->regmap, TX_PACKET_ALLOC_EOF_2, 0x12);
+	regmap_write(priv->regmap, TX_CORE_ALLOC_VSYNC_0, 0x01);
+	regmap_write(priv->regmap, TX_CORE_ALLOC_VSYNC_1, 0x00);
+	regmap_write(priv->regmap, TX_CORE_ALLOC_VSYNC_2, 0x0a);
+	regmap_write(priv->regmap, TX_PACKET_ALLOC_SOF_1, alloc_sof1);
+	regmap_write(priv->regmap, TX_PACKET_ALLOC_SOF_2, alloc_sof2);
+	regmap_update_bits(priv->regmap, TX_PACKET_CONTROL_1,
+			   TX_PACKET_CONTROL_1_FORCE_PACKET_TIMING,
+			   TX_PACKET_CONTROL_1_FORCE_PACKET_TIMING);
+}
+
+static void meson_txc_hdmi_set_avi_infoframe(struct meson_txc_hdmi *priv,
+					     struct drm_connector *conn,
+					     const struct drm_display_mode *mode,
+					     const struct drm_connector_state *conn_state,
+					     unsigned int output_bus_format,
+					     enum hdmi_quantization_range quant_range,
+					     enum hdmi_colorimetry colorimetry)
+{
+	u8 buf[HDMI_INFOFRAME_SIZE(AVI)], *video_code;
+	struct hdmi_avi_infoframe frame;
+	int ret;
+
+	ret = drm_hdmi_avi_infoframe_from_display_mode(&frame, conn, mode);
+	if (ret < 0) {
+		drm_err(priv->bridge.dev,
+			"Failed to setup AVI infoframe: %d\n", ret);
+		return;
+	}
+
+	switch (output_bus_format) {
+	case MEDIA_BUS_FMT_YUV8_1X24:
+	case MEDIA_BUS_FMT_YUV10_1X30:
+	case MEDIA_BUS_FMT_YUV12_1X36:
+	case MEDIA_BUS_FMT_YUV16_1X48:
+		frame.colorspace = HDMI_COLORSPACE_YUV444;
+		break;
+
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+	case MEDIA_BUS_FMT_UYVY10_1X20:
+	case MEDIA_BUS_FMT_UYVY12_1X24:
+		frame.colorspace = HDMI_COLORSPACE_YUV422;
+		break;
+
+	case MEDIA_BUS_FMT_RGB888_1X24:
+	case MEDIA_BUS_FMT_RGB101010_1X30:
+	case MEDIA_BUS_FMT_RGB121212_1X36:
+	case MEDIA_BUS_FMT_RGB161616_1X48:
+	default:
+		frame.colorspace = HDMI_COLORSPACE_RGB;
+		break;
+	}
+
+	drm_hdmi_avi_infoframe_colorimetry(&frame, conn_state);
+	drm_hdmi_avi_infoframe_quant_range(&frame, conn, mode, quant_range);
+	drm_hdmi_avi_infoframe_bars(&frame, conn_state);
+
+	ret = hdmi_avi_infoframe_pack(&frame, buf, sizeof(buf));
+	if (ret < 0) {
+		drm_err(priv->bridge.dev,
+			"Failed to pack AVI infoframe: %d\n", ret);
+		return;
+	}
+
+	video_code = &buf[HDMI_INFOFRAME_HEADER_SIZE + 3];
+	if (*video_code > 108) {
+		regmap_write(priv->regmap, TX_PKT_REG_EXCEPT0_BASE_ADDR,
+			     *video_code);
+		*video_code = 0x00;
+	} else {
+		regmap_write(priv->regmap, TX_PKT_REG_EXCEPT0_BASE_ADDR,
+			     0x00);
+	}
+
+	meson_txc_hdmi_write_infoframe(priv->regmap,
+				       TX_PKT_REG_AVI_INFO_BASE_ADDR, buf,
+				       sizeof(buf), true);
+}
+
+static void meson_txc_hdmi_set_vendor_infoframe(struct meson_txc_hdmi *priv,
+						struct drm_connector *conn,
+						const struct drm_display_mode *mode)
+{
+	u8 buf[HDMI_INFOFRAME_HEADER_SIZE + 6];
+	struct hdmi_vendor_infoframe frame;
+	int ret;
+
+	ret = drm_hdmi_vendor_infoframe_from_display_mode(&frame, conn, mode);
+	if (ret) {
+		drm_dbg(priv->bridge.dev,
+			"Failed to setup vendor infoframe: %d\n", ret);
+		return;
+	}
+
+	ret = hdmi_vendor_infoframe_pack(&frame, buf, sizeof(buf));
+	if (ret < 0) {
+		drm_err(priv->bridge.dev,
+			"Failed to pack vendor infoframe: %d\n", ret);
+		return;
+	}
+
+	meson_txc_hdmi_write_infoframe(priv->regmap,
+				       TX_PKT_REG_VEND_INFO_BASE_ADDR, buf,
+				       sizeof(buf), true);
+}
+
+static void meson_txc_hdmi_set_spd_infoframe(struct meson_txc_hdmi *priv)
+{
+	u8 buf[HDMI_INFOFRAME_SIZE(SPD)];
+	struct hdmi_spd_infoframe frame;
+	int ret;
+
+	ret = hdmi_spd_infoframe_init(&frame, "Amlogic", "Meson TXC HDMI");
+	if (ret < 0) {
+		drm_err(priv->bridge.dev,
+			"Failed to setup SPD infoframe: %d\n", ret);
+		return;
+	}
+
+	ret = hdmi_spd_infoframe_pack(&frame, buf, sizeof(buf));
+	if (ret < 0) {
+		drm_err(priv->bridge.dev,
+			"Failed to pack SDP infoframe: %d\n", ret);
+		return;
+	}
+
+	meson_txc_hdmi_write_infoframe(priv->regmap,
+				       TX_PKT_REG_SPD_INFO_BASE_ADDR, buf,
+				       sizeof(buf), true);
+}
+
+static void meson_txc_hdmi_handle_plugged_change(struct meson_txc_hdmi *priv)
+{
+	bool plugged;
+
+	plugged = priv->last_connector_status == connector_status_connected;
+
+	if (priv->codec_dev && priv->codec_plugged_cb)
+		priv->codec_plugged_cb(priv->codec_dev, plugged);
+}
+
+static int meson_txc_hdmi_bridge_attach(struct drm_bridge *bridge,
+					enum drm_bridge_attach_flags flags)
+{
+	struct meson_txc_hdmi *priv = bridge->driver_private;
+
+	if (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)) {
+		drm_err(bridge->dev,
+			"DRM_BRIDGE_ATTACH_NO_CONNECTOR flag is not set but needed\n");
+		return -EINVAL;
+	}
+
+	return drm_bridge_attach(bridge->encoder, priv->next_bridge, bridge,
+				 flags);
+}
+
+/* Can return a maximum of 11 possible output formats for a mode/connector */
+#define MAX_OUTPUT_SEL_FORMATS	11
+
+static u32 *
+meson_txc_hdmi_bridge_atomic_get_output_bus_fmts(struct drm_bridge *bridge,
+						 struct drm_bridge_state *bridge_state,
+						 struct drm_crtc_state *crtc_state,
+						 struct drm_connector_state *conn_state,
+						 unsigned int *num_output_fmts)
+{
+	struct drm_connector *conn = conn_state->connector;
+	struct drm_display_info *info = &conn->display_info;
+	u8 max_bpc = conn_state->max_requested_bpc;
+	unsigned int i = 0;
+	u32 *output_fmts;
+
+	*num_output_fmts = 0;
+
+	output_fmts = kcalloc(MAX_OUTPUT_SEL_FORMATS, sizeof(*output_fmts),
+			      GFP_KERNEL);
+	if (!output_fmts)
+		return NULL;
+
+	/* If we are the only bridge, avoid negotiating with ourselves */
+	if (list_is_singular(&bridge->encoder->bridge_chain)) {
+		*num_output_fmts = 1;
+		output_fmts[0] = MEDIA_BUS_FMT_FIXED;
+
+		return output_fmts;
+	}
+
+	/*
+	 * Order bus formats from 16bit to 8bit and from YUV422 to RGB
+	 * if supported. In any case the default RGB888 format is added
+	 */
+
+	if (max_bpc >= 16 && info->bpc == 16) {
+		if (info->color_formats & DRM_COLOR_FORMAT_YCBCR444)
+			output_fmts[i++] = MEDIA_BUS_FMT_YUV16_1X48;
+
+		output_fmts[i++] = MEDIA_BUS_FMT_RGB161616_1X48;
+	}
+
+	if (max_bpc >= 12 && info->bpc >= 12) {
+		if (info->color_formats & DRM_COLOR_FORMAT_YCBCR422)
+			output_fmts[i++] = MEDIA_BUS_FMT_UYVY12_1X24;
+
+		if (info->color_formats & DRM_COLOR_FORMAT_YCBCR444)
+			output_fmts[i++] = MEDIA_BUS_FMT_YUV12_1X36;
+
+		output_fmts[i++] = MEDIA_BUS_FMT_RGB121212_1X36;
+	}
+
+	if (max_bpc >= 10 && info->bpc >= 10) {
+		if (info->color_formats & DRM_COLOR_FORMAT_YCBCR422)
+			output_fmts[i++] = MEDIA_BUS_FMT_UYVY10_1X20;
+
+		if (info->color_formats & DRM_COLOR_FORMAT_YCBCR444)
+			output_fmts[i++] = MEDIA_BUS_FMT_YUV10_1X30;
+
+		output_fmts[i++] = MEDIA_BUS_FMT_RGB101010_1X30;
+	}
+
+	if (info->color_formats & DRM_COLOR_FORMAT_YCBCR422)
+		output_fmts[i++] = MEDIA_BUS_FMT_UYVY8_1X16;
+
+	if (info->color_formats & DRM_COLOR_FORMAT_YCBCR444)
+		output_fmts[i++] = MEDIA_BUS_FMT_YUV8_1X24;
+
+	/* Default 8bit RGB fallback */
+	output_fmts[i++] = MEDIA_BUS_FMT_RGB888_1X24;
+
+	*num_output_fmts = i;
+
+	return output_fmts;
+}
+
+/* Can return a maximum of 3 possible input formats for an output format */
+#define MAX_INPUT_SEL_FORMATS	3
+
+static u32 *
+meson_txc_hdmi_bridge_atomic_get_input_bus_fmts(struct drm_bridge *bridge,
+						struct drm_bridge_state *bridge_state,
+						struct drm_crtc_state *crtc_state,
+						struct drm_connector_state *conn_state,
+						u32 output_fmt,
+						unsigned int *num_input_fmts)
+{
+	u32 *input_fmts;
+	unsigned int i = 0;
+
+	*num_input_fmts = 0;
+
+	input_fmts = kcalloc(MAX_INPUT_SEL_FORMATS, sizeof(*input_fmts),
+			     GFP_KERNEL);
+	if (!input_fmts)
+		return NULL;
+
+	switch (output_fmt) {
+	/* If MEDIA_BUS_FMT_FIXED is tested, return default bus format */
+	case MEDIA_BUS_FMT_FIXED:
+		input_fmts[i++] = MEDIA_BUS_FMT_RGB888_1X24;
+		break;
+
+	/* 8bit */
+	case MEDIA_BUS_FMT_RGB888_1X24:
+		input_fmts[i++] = MEDIA_BUS_FMT_RGB888_1X24;
+		input_fmts[i++] = MEDIA_BUS_FMT_YUV8_1X24;
+		input_fmts[i++] = MEDIA_BUS_FMT_UYVY8_1X16;
+		break;
+	case MEDIA_BUS_FMT_YUV8_1X24:
+		input_fmts[i++] = MEDIA_BUS_FMT_YUV8_1X24;
+		input_fmts[i++] = MEDIA_BUS_FMT_UYVY8_1X16;
+		input_fmts[i++] = MEDIA_BUS_FMT_RGB888_1X24;
+		break;
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+		input_fmts[i++] = MEDIA_BUS_FMT_UYVY8_1X16;
+		input_fmts[i++] = MEDIA_BUS_FMT_YUV8_1X24;
+		input_fmts[i++] = MEDIA_BUS_FMT_RGB888_1X24;
+		break;
+
+	/* 10bit */
+	case MEDIA_BUS_FMT_RGB101010_1X30:
+		input_fmts[i++] = MEDIA_BUS_FMT_RGB101010_1X30;
+		input_fmts[i++] = MEDIA_BUS_FMT_YUV10_1X30;
+		input_fmts[i++] = MEDIA_BUS_FMT_UYVY10_1X20;
+		break;
+	case MEDIA_BUS_FMT_YUV10_1X30:
+		input_fmts[i++] = MEDIA_BUS_FMT_YUV10_1X30;
+		input_fmts[i++] = MEDIA_BUS_FMT_UYVY10_1X20;
+		input_fmts[i++] = MEDIA_BUS_FMT_RGB101010_1X30;
+		break;
+	case MEDIA_BUS_FMT_UYVY10_1X20:
+		input_fmts[i++] = MEDIA_BUS_FMT_UYVY10_1X20;
+		input_fmts[i++] = MEDIA_BUS_FMT_YUV10_1X30;
+		input_fmts[i++] = MEDIA_BUS_FMT_RGB101010_1X30;
+		break;
+
+	/* 12bit */
+	case MEDIA_BUS_FMT_RGB121212_1X36:
+		input_fmts[i++] = MEDIA_BUS_FMT_RGB121212_1X36;
+		input_fmts[i++] = MEDIA_BUS_FMT_YUV12_1X36;
+		input_fmts[i++] = MEDIA_BUS_FMT_UYVY12_1X24;
+		break;
+	case MEDIA_BUS_FMT_YUV12_1X36:
+		input_fmts[i++] = MEDIA_BUS_FMT_YUV12_1X36;
+		input_fmts[i++] = MEDIA_BUS_FMT_UYVY12_1X24;
+		input_fmts[i++] = MEDIA_BUS_FMT_RGB121212_1X36;
+		break;
+	case MEDIA_BUS_FMT_UYVY12_1X24:
+		input_fmts[i++] = MEDIA_BUS_FMT_UYVY12_1X24;
+		input_fmts[i++] = MEDIA_BUS_FMT_YUV12_1X36;
+		input_fmts[i++] = MEDIA_BUS_FMT_RGB121212_1X36;
+		break;
+
+	/* 16bit */
+	case MEDIA_BUS_FMT_RGB161616_1X48:
+		input_fmts[i++] = MEDIA_BUS_FMT_RGB161616_1X48;
+		input_fmts[i++] = MEDIA_BUS_FMT_YUV16_1X48;
+		break;
+	case MEDIA_BUS_FMT_YUV16_1X48:
+		input_fmts[i++] = MEDIA_BUS_FMT_YUV16_1X48;
+		input_fmts[i++] = MEDIA_BUS_FMT_RGB161616_1X48;
+		break;
+	}
+
+	*num_input_fmts = i;
+
+	if (*num_input_fmts == 0) {
+		kfree(input_fmts);
+		input_fmts = NULL;
+	}
+
+	return input_fmts;
+}
+
+static void meson_txc_hdmi_bridge_atomic_enable(struct drm_bridge *bridge,
+						struct drm_bridge_state *old_bridge_state)
+{
+	struct meson_txc_hdmi *priv = bridge_to_meson_txc_hdmi(bridge);
+	struct drm_atomic_state *state = old_bridge_state->base.state;
+	enum hdmi_quantization_range quant_range;
+	struct drm_connector_state *conn_state;
+	struct drm_bridge_state *bridge_state;
+	const struct drm_display_mode *mode;
+	enum hdmi_colorimetry colorimetry;
+	struct drm_crtc_state *crtc_state;
+	struct drm_connector *connector;
+	unsigned int i;
+	u8 cea_mode;
+
+	bridge_state = drm_atomic_get_new_bridge_state(state, bridge);
+
+	connector = drm_atomic_get_new_connector_for_encoder(state,
+							     bridge->encoder);
+	if (WARN_ON(!connector))
+		return;
+
+	conn_state = drm_atomic_get_new_connector_state(state, connector);
+	if (WARN_ON(!conn_state))
+		return;
+
+	crtc_state = drm_atomic_get_new_crtc_state(state, conn_state->crtc);
+	if (WARN_ON(!crtc_state))
+		return;
+
+	priv->current_connector = connector;
+
+	mode = &crtc_state->adjusted_mode;
+
+	cea_mode = drm_match_cea_mode(mode);
+
+	if (priv->sink_is_hdmi) {
+		quant_range = drm_default_rgb_quant_range(mode);
+
+		switch (cea_mode) {
+		case 2 ... 3:
+		case 6 ... 7:
+		case 17 ... 18:
+		case 21 ... 22:
+			colorimetry = HDMI_COLORIMETRY_ITU_601;
+			break;
+
+		default:
+			colorimetry = HDMI_COLORIMETRY_ITU_709;
+			break;
+		}
+
+		meson_txc_hdmi_set_avi_infoframe(priv, connector, mode,
+						 conn_state,
+						 bridge_state->output_bus_cfg.format,
+						 quant_range, colorimetry);
+		meson_txc_hdmi_set_vendor_infoframe(priv, connector, mode);
+		meson_txc_hdmi_set_spd_infoframe(priv);
+	} else {
+		quant_range = HDMI_QUANTIZATION_RANGE_FULL;
+		colorimetry = HDMI_COLORIMETRY_NONE;
+	}
+
+	meson_txc_hdmi_sys5_reset_assert(priv);
+
+	meson_txc_hdmi_config_hdcp_registers(priv);
+
+	if (cea_mode == 39)
+		regmap_write(priv->regmap, TX_VIDEO_DTV_TIMING, 0x0);
+	else
+		regmap_write(priv->regmap, TX_VIDEO_DTV_TIMING,
+			     TX_VIDEO_DTV_TIMING_DISABLE_VIC39_CORRECTION);
+
+	regmap_write(priv->regmap, TX_CORE_DATA_CAPTURE_2,
+		     TX_CORE_DATA_CAPTURE_2_INTERNAL_PACKET_ENABLE);
+	regmap_write(priv->regmap, TX_CORE_DATA_MONITOR_1,
+		     TX_CORE_DATA_MONITOR_1_LANE0 |
+		     FIELD_PREP(TX_CORE_DATA_MONITOR_1_SELECT_LANE0, 0x7));
+	regmap_write(priv->regmap, TX_CORE_DATA_MONITOR_2,
+		     FIELD_PREP(TX_CORE_DATA_MONITOR_2_MONITOR_SELECT, 0x2));
+
+	if (priv->sink_is_hdmi)
+		regmap_write(priv->regmap, TX_TMDS_MODE,
+			     TX_TMDS_MODE_FORCED_HDMI |
+			     TX_TMDS_MODE_HDMI_CONFIG);
+	else
+		regmap_write(priv->regmap, TX_TMDS_MODE,
+			     TX_TMDS_MODE_FORCED_HDMI);
+
+	regmap_write(priv->regmap, TX_SYS4_CONNECT_SEL_1, 0x0);
+
+	/*
+	 * Set tmds_clk pattern to be "0000011111" before being sent to AFE
+	 * clock channel.
+	 */
+	regmap_write(priv->regmap, TX_SYS4_CK_INV_VIDEO,
+		     TX_SYS4_CK_INV_VIDEO_TMDS_CLK_PATTERN);
+
+	regmap_write(priv->regmap, TX_SYS5_FIFO_CONFIG,
+		     TX_SYS5_FIFO_CONFIG_CLK_CHANNEL3_OUTPUT_ENABLE |
+		     TX_SYS5_FIFO_CONFIG_AFE_FIFO_CHANNEL2_ENABLE |
+		     TX_SYS5_FIFO_CONFIG_AFE_FIFO_CHANNEL1_ENABLE |
+		     TX_SYS5_FIFO_CONFIG_AFE_FIFO_CHANNEL0_ENABLE);
+
+	meson_txc_hdmi_config_color_space(priv,
+					  bridge_state->input_bus_cfg.format,
+					  bridge_state->output_bus_cfg.format,
+					  quant_range, colorimetry);
+
+	meson_txc_hdmi_sys5_reset_deassert(priv);
+
+	meson_txc_hdmi_config_serializer_clock(priv, colorimetry);
+	meson_txc_hdmi_reconfig_packet_setting(priv, cea_mode);
+
+	/* all resets need to be applied twice */
+	for (i = 0; i < 2; i++) {
+		regmap_write(priv->regmap, TX_SYS5_TX_SOFT_RESET_1,
+			     TX_SYS5_TX_SOFT_RESET_1_TX_PIXEL_RSTN |
+			     TX_SYS5_TX_SOFT_RESET_1_TX_TMDS_RSTN |
+			     TX_SYS5_TX_SOFT_RESET_1_TX_AUDIO_MASTER_RSTN |
+			     TX_SYS5_TX_SOFT_RESET_1_TX_AUDIO_RESAMPLE_RSTN |
+			     TX_SYS5_TX_SOFT_RESET_1_TX_I2S_RESET_RSTN |
+			     TX_SYS5_TX_SOFT_RESET_1_TX_DIG_RESET_N_CH2 |
+			     TX_SYS5_TX_SOFT_RESET_1_TX_DIG_RESET_N_CH1 |
+			     TX_SYS5_TX_SOFT_RESET_1_TX_DIG_RESET_N_CH0);
+		regmap_write(priv->regmap, TX_SYS5_TX_SOFT_RESET_2,
+			     TX_SYS5_TX_SOFT_RESET_2_HDMI_CH3_RST_IN |
+			     TX_SYS5_TX_SOFT_RESET_2_HDMI_CH2_RST_IN |
+			     TX_SYS5_TX_SOFT_RESET_2_HDMI_CH1_RST_IN |
+			     TX_SYS5_TX_SOFT_RESET_2_HDMI_CH0_RST_IN |
+			     TX_SYS5_TX_SOFT_RESET_2_HDMI_SR_RST |
+			     TX_SYS5_TX_SOFT_RESET_2_TX_DDC_HDCP_RSTN |
+			     TX_SYS5_TX_SOFT_RESET_2_TX_DDC_EDID_RSTN |
+			     TX_SYS5_TX_SOFT_RESET_2_TX_DIG_RESET_N_CH3);
+		usleep_range(5000, 10000);
+		regmap_write(priv->regmap, TX_SYS5_TX_SOFT_RESET_1, 0x00);
+		regmap_write(priv->regmap, TX_SYS5_TX_SOFT_RESET_2, 0x00);
+		usleep_range(5000, 10000);
+	}
+
+	if (!priv->phy_is_on) {
+		int ret;
+
+		ret = phy_power_on(priv->phy);
+		if (ret)
+			drm_err(bridge->dev, "Failed to turn on PHY\n");
+		else
+			priv->phy_is_on = true;
+	}
+}
+
+static void meson_txc_hdmi_bridge_atomic_disable(struct drm_bridge *bridge,
+						 struct drm_bridge_state *old_bridge_state)
+{
+	struct meson_txc_hdmi *priv = bridge_to_meson_txc_hdmi(bridge);
+
+	priv->current_connector = NULL;
+
+	if (priv->phy_is_on) {
+		int ret;
+
+		ret = phy_power_off(priv->phy);
+		if (ret)
+			drm_err(bridge->dev, "Failed to turn off PHY\n");
+		else
+			priv->phy_is_on = false;
+	}
+
+	meson_txc_hdmi_disable_infoframe(priv, TX_PKT_REG_AUDIO_INFO_BASE_ADDR);
+	meson_txc_hdmi_disable_infoframe(priv, TX_PKT_REG_AVI_INFO_BASE_ADDR);
+	meson_txc_hdmi_disable_infoframe(priv, TX_PKT_REG_EXCEPT0_BASE_ADDR);
+	meson_txc_hdmi_disable_infoframe(priv, TX_PKT_REG_VEND_INFO_BASE_ADDR);
+}
+
+static enum drm_mode_status
+meson_txc_hdmi_bridge_mode_valid(struct drm_bridge *bridge,
+				 const struct drm_display_info *info,
+				 const struct drm_display_mode *mode)
+{
+	return MODE_OK;
+}
+
+static enum drm_connector_status meson_txc_hdmi_bridge_detect(struct drm_bridge *bridge)
+{
+	struct meson_txc_hdmi *priv = bridge_to_meson_txc_hdmi(bridge);
+	enum drm_connector_status status;
+	unsigned int val;
+
+	regmap_read(priv->regmap, TX_HDCP_ST_EDID_STATUS, &val);
+	if (val & TX_HDCP_ST_EDID_STATUS_HPD_STATUS)
+		status = connector_status_connected;
+	else
+		status = connector_status_disconnected;
+
+	mutex_lock(&priv->codec_mutex);
+	if (priv->last_connector_status != status) {
+		priv->last_connector_status = status;
+		meson_txc_hdmi_handle_plugged_change(priv);
+	}
+	mutex_unlock(&priv->codec_mutex);
+
+	return status;
+}
+
+static int meson_txc_hdmi_get_edid_block(void *data, u8 *buf, unsigned int block,
+					 size_t len)
+{
+	unsigned int i, regval, start = block * EDID_LENGTH;
+	struct meson_txc_hdmi *priv = data;
+	int ret;
+
+	/* Start the DDC transaction */
+	regmap_update_bits(priv->regmap, TX_HDCP_EDID_CONFIG,
+			   TX_HDCP_EDID_CONFIG_SYS_TRIGGER_CONFIG, 0);
+	regmap_update_bits(priv->regmap, TX_HDCP_EDID_CONFIG,
+			   TX_HDCP_EDID_CONFIG_SYS_TRIGGER_CONFIG,
+			   TX_HDCP_EDID_CONFIG_SYS_TRIGGER_CONFIG);
+
+	ret = regmap_read_poll_timeout(priv->regmap,
+				       TX_HDCP_ST_EDID_STATUS,
+				       regval,
+				       (regval & TX_HDCP_ST_EDID_STATUS_EDID_DATA_READY),
+				       1000, 200000);
+
+	regmap_update_bits(priv->regmap, TX_HDCP_EDID_CONFIG,
+			   TX_HDCP_EDID_CONFIG_SYS_TRIGGER_CONFIG, 0);
+
+	if (ret)
+		return ret;
+
+	for (i = 0; i < len; i++) {
+		regmap_read(priv->regmap, TX_RX_EDID_OFFSET + start + i,
+			    &regval);
+		buf[i] = regval;
+	}
+
+	return 0;
+}
+
+static struct edid *meson_txc_hdmi_bridge_get_edid(struct drm_bridge *bridge,
+						   struct drm_connector *connector)
+{
+	struct meson_txc_hdmi *priv = bridge_to_meson_txc_hdmi(bridge);
+	struct edid *edid;
+
+	edid = drm_do_get_edid(connector, meson_txc_hdmi_get_edid_block, priv);
+	if (!edid) {
+		drm_dbg(priv->bridge.dev, "Failed to get EDID\n");
+		return NULL;
+	}
+
+	priv->sink_is_hdmi = drm_detect_hdmi_monitor(edid);
+
+	return edid;
+}
+
+static const struct drm_bridge_funcs meson_txc_hdmi_bridge_funcs = {
+	.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,
+	.atomic_reset = drm_atomic_helper_bridge_reset,
+	.attach = meson_txc_hdmi_bridge_attach,
+	.atomic_get_output_bus_fmts = meson_txc_hdmi_bridge_atomic_get_output_bus_fmts,
+	.atomic_get_input_bus_fmts = meson_txc_hdmi_bridge_atomic_get_input_bus_fmts,
+	.atomic_enable = meson_txc_hdmi_bridge_atomic_enable,
+	.atomic_disable = meson_txc_hdmi_bridge_atomic_disable,
+	.mode_valid = meson_txc_hdmi_bridge_mode_valid,
+	.detect = meson_txc_hdmi_bridge_detect,
+	.get_edid = meson_txc_hdmi_bridge_get_edid,
+};
+
+static int meson_txc_hdmi_parse_dt(struct meson_txc_hdmi *priv)
+{
+	struct device_node *endpoint, *remote;
+
+	endpoint = of_graph_get_endpoint_by_regs(priv->dev->of_node, 1, -1);
+	if (!endpoint) {
+		dev_err(priv->dev, "Missing endpoint in port@1\n");
+		return -ENODEV;
+	}
+
+	remote = of_graph_get_remote_port_parent(endpoint);
+	of_node_put(endpoint);
+	if (!remote) {
+		dev_err(priv->dev, "Endpoint in port@1 unconnected\n");
+		return -ENODEV;
+	}
+
+	if (!of_device_is_available(remote)) {
+		dev_err(priv->dev, "port@1 remote device is disabled\n");
+		of_node_put(remote);
+		return -ENODEV;
+	}
+
+	priv->next_bridge = of_drm_find_bridge(remote);
+	of_node_put(remote);
+	if (!priv->next_bridge)
+		return -EPROBE_DEFER;
+
+	return 0;
+}
+
+static int meson_txc_hdmi_hw_init(struct meson_txc_hdmi *priv)
+{
+	unsigned long ddc_i2c_bus_clk_hz = 500 * 1000;
+	unsigned long sys_clk_hz = 24 * 1000 * 1000;
+	int ret;
+
+	ret = phy_init(priv->phy);
+	if (ret) {
+		dev_err(priv->dev, "Failed to initialize the PHY: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_set_rate(priv->sys_clk, sys_clk_hz);
+	if (ret) {
+		dev_err(priv->dev, "Failed to set HDMI system clock to 24MHz\n");
+		goto err_phy_exit;
+	}
+
+	ret = clk_prepare_enable(priv->sys_clk);
+	if (ret) {
+		dev_err(priv->dev, "Failed to enable the sys clk\n");
+		goto err_phy_exit;
+	}
+
+	regmap_update_bits(priv->regmap, HDMI_OTHER_CTRL1,
+			   HDMI_OTHER_CTRL1_POWER_ON,
+			   HDMI_OTHER_CTRL1_POWER_ON);
+
+	regmap_write(priv->regmap, TX_HDMI_PHY_CONFIG0,
+		     TX_HDMI_PHY_CONFIG0_HDMI_COMMON_B7_B0);
+
+	regmap_write(priv->regmap, TX_HDCP_MODE, 0x40);
+
+	/*
+	 * The vendor driver comments that this is a setting for "Band-gap and
+	 * main-bias". 0x1d = power-up, 0x00 = power-down.
+	 */
+	regmap_write(priv->regmap, TX_SYS1_AFE_TEST, 0x1d);
+
+	meson_txc_hdmi_config_serializer_clock(priv, HDMI_COLORIMETRY_NONE);
+
+	/*
+	 * The vendor driver has a comment with the following information for
+	 * the magic value:
+	 * bit[2:0]=011: CK channel output TMDS CLOCK
+	 * bit[2:0]=101, ck channel output PHYCLCK
+	 */
+	regmap_write(priv->regmap, TX_SYS1_AFE_CONNECT, 0xfb);
+
+	/* Termination resistor calib value */
+	regmap_write(priv->regmap, TX_CORE_CALIB_VALUE, 0x0f);
+
+	/* HPD glitch filter */
+	regmap_write(priv->regmap, TX_HDCP_HPD_FILTER_L, 0xa0);
+	regmap_write(priv->regmap, TX_HDCP_HPD_FILTER_H, 0xa0);
+
+	/* Disable MEM power-down */
+	regmap_write(priv->regmap, TX_MEM_PD_REG0, 0x0);
+
+	regmap_write(priv->regmap, TX_HDCP_CONFIG3,
+		     FIELD_PREP(TX_HDCP_CONFIG3_DDC_I2C_BUS_CLOCK_TIME_DIVIDER,
+				(sys_clk_hz / ddc_i2c_bus_clk_hz) - 1));
+
+	/* Enable software controlled DDC transaction */
+	regmap_write(priv->regmap, TX_HDCP_EDID_CONFIG,
+		     TX_HDCP_EDID_CONFIG_FORCED_MEM_COPY_DONE |
+		     TX_HDCP_EDID_CONFIG_MEM_COPY_DONE_CONFIG);
+	regmap_write(priv->regmap, TX_CORE_EDID_CONFIG_MORE,
+		     TX_CORE_EDID_CONFIG_MORE_SYS_TRIGGER_CONFIG_SEMI_MANU);
+
+	/* mask (= disable) all interrupts */
+	regmap_write(priv->regmap, HDMI_OTHER_INTR_MASKN, 0x0);
+
+	/* clear any pending interrupt */
+	regmap_write(priv->regmap, HDMI_OTHER_INTR_STAT_CLR,
+		     HDMI_OTHER_INTR_STAT_CLR_EDID_RISING |
+		     HDMI_OTHER_INTR_STAT_CLR_HPD_FALLING |
+		     HDMI_OTHER_INTR_STAT_CLR_HPD_RISING);
+
+	return 0;
+
+err_phy_exit:
+	phy_exit(priv->phy);
+	return 0;
+}
+
+static void meson_txc_hdmi_hw_exit(struct meson_txc_hdmi *priv)
+{
+	int ret;
+
+	/* mask (= disable) all interrupts */
+	regmap_write(priv->regmap, HDMI_OTHER_INTR_MASKN,
+		     HDMI_OTHER_INTR_MASKN_TX_EDID_INT_RISE |
+		     HDMI_OTHER_INTR_MASKN_TX_HPD_INT_FALL |
+		     HDMI_OTHER_INTR_MASKN_TX_HPD_INT_RISE);
+
+	regmap_update_bits(priv->regmap, HDMI_OTHER_CTRL1,
+			   HDMI_OTHER_CTRL1_POWER_ON, 0);
+
+	clk_disable_unprepare(priv->sys_clk);
+
+	ret = phy_exit(priv->phy);
+	if (ret)
+		dev_err(priv->dev, "Failed to exit the PHY: %d\n", ret);
+}
+
+static u32 meson_txc_hdmi_hdmi_codec_calc_audio_n(struct hdmi_codec_params *hparms)
+{
+	u32 audio_n;
+
+	if ((hparms->sample_rate % 44100) == 0)
+		audio_n = (128 * hparms->sample_rate) / 900;
+	else
+		audio_n = (128 * hparms->sample_rate) / 1000;
+
+	if (hparms->cea.coding_type == HDMI_AUDIO_CODING_TYPE_EAC3 ||
+	    hparms->cea.coding_type == HDMI_AUDIO_CODING_TYPE_DTS_HD)
+		audio_n *= 4;
+
+	return audio_n;
+}
+
+static u8 meson_txc_hdmi_hdmi_codec_coding_type(struct hdmi_codec_params *hparms)
+{
+	switch (hparms->cea.coding_type) {
+	case HDMI_AUDIO_CODING_TYPE_MLP:
+		return TX_AUDIO_CONTROL_AUDIO_PACKET_TYPE_HBR_AUDIO_PACKET;
+	case HDMI_AUDIO_CODING_TYPE_DSD:
+		return TX_AUDIO_CONTROL_AUDIO_PACKET_TYPE_ONE_BIT_AUDIO;
+	case HDMI_AUDIO_CODING_TYPE_DST:
+		return TX_AUDIO_CONTROL_AUDIO_PACKET_TYPE_DST_AUDIO_PACKET;
+	default:
+		return TX_AUDIO_CONTROL_AUDIO_PACKET_TYPE_AUDIO_SAMPLE_PACKET;
+	}
+}
+
+static int meson_txc_hdmi_hdmi_codec_hw_params(struct device *dev, void *data,
+					       struct hdmi_codec_daifmt *fmt,
+					       struct hdmi_codec_params *hparms)
+{
+	u8 buf[HDMI_INFOFRAME_SIZE(AUDIO)];
+	struct meson_txc_hdmi *priv = data;
+	u16 audio_tx_format;
+	u32 audio_n;
+	int len, i;
+
+	if (hparms->cea.coding_type == HDMI_AUDIO_CODING_TYPE_MLP) {
+		/*
+		 * TODO: fixed CTS is not supported yet, it needs special
+		 * TX_SYS1_ACR_N_* settings
+		 */
+		return -EINVAL;
+	}
+
+	switch (hparms->sample_width) {
+	case 16:
+		audio_tx_format = FIELD_PREP(TX_AUDIO_FORMAT_BIT_WIDTH_MASK,
+					     TX_AUDIO_FORMAT_BIT_WIDTH_16);
+		break;
+
+	case 20:
+		audio_tx_format = FIELD_PREP(TX_AUDIO_FORMAT_BIT_WIDTH_MASK,
+					     TX_AUDIO_FORMAT_BIT_WIDTH_20);
+		break;
+
+	case 24:
+		audio_tx_format = FIELD_PREP(TX_AUDIO_FORMAT_BIT_WIDTH_MASK,
+					     TX_AUDIO_FORMAT_BIT_WIDTH_24);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt->fmt) {
+	case HDMI_I2S:
+		regmap_update_bits(priv->regmap, HDMI_OTHER_CTRL1,
+				   HDMI_OTHER_CTRL1_HDMI_AUDIO_CLOCK_ON,
+				   HDMI_OTHER_CTRL1_HDMI_AUDIO_CLOCK_ON);
+
+		audio_tx_format |= TX_AUDIO_FORMAT_SPDIF_OR_I2S |
+				   TX_AUDIO_FORMAT_I2S_ONE_BIT_OR_I2S |
+				   FIELD_PREP(TX_AUDIO_FORMAT_I2S_FORMAT, 0x2);
+
+		if (hparms->channels > 2)
+			audio_tx_format |= TX_AUDIO_FORMAT_I2S_2_OR_8_CH;
+
+		regmap_write(priv->regmap, TX_AUDIO_FORMAT, audio_tx_format);
+
+		regmap_write(priv->regmap, TX_AUDIO_I2S, TX_AUDIO_I2S_ENABLE);
+		regmap_write(priv->regmap, TX_AUDIO_SPDIF, 0x0);
+		break;
+
+	case HDMI_SPDIF:
+		regmap_update_bits(priv->regmap, HDMI_OTHER_CTRL1,
+				   HDMI_OTHER_CTRL1_HDMI_AUDIO_CLOCK_ON, 0x0);
+
+		if (hparms->cea.coding_type == HDMI_AUDIO_CODING_TYPE_STREAM)
+			audio_tx_format |= TX_AUDIO_FORMAT_SPDIF_CHANNEL_STATUS_FROM_DATA_OR_REG;
+
+		regmap_write(priv->regmap, TX_AUDIO_FORMAT, audio_tx_format);
+
+		regmap_write(priv->regmap, TX_AUDIO_I2S, 0x0);
+		regmap_write(priv->regmap, TX_AUDIO_SPDIF, TX_AUDIO_SPDIF_ENABLE);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	if (hparms->channels > 2)
+		regmap_write(priv->regmap, TX_AUDIO_HEADER,
+			     TX_AUDIO_HEADER_AUDIO_SAMPLE_PACKET_HEADER_LAYOUT1);
+	else
+		regmap_write(priv->regmap, TX_AUDIO_HEADER, 0x0);
+
+	regmap_write(priv->regmap, TX_AUDIO_SAMPLE,
+		     FIELD_PREP(TX_AUDIO_SAMPLE_CHANNEL_VALID,
+				BIT(hparms->channels) - 1));
+
+	audio_n = meson_txc_hdmi_hdmi_codec_calc_audio_n(hparms);
+
+	regmap_write(priv->regmap, TX_SYS1_ACR_N_0,
+		     FIELD_PREP(TX_SYS1_ACR_N_0_N_BYTE0,
+				(audio_n >> 0) & 0xff));
+	regmap_write(priv->regmap, TX_SYS1_ACR_N_1,
+		     FIELD_PREP(TX_SYS1_ACR_N_1_N_BYTE1,
+				(audio_n >> 8) & 0xff));
+	regmap_update_bits(priv->regmap, TX_SYS1_ACR_N_2,
+			   TX_SYS1_ACR_N_2_N_UPPER_NIBBLE,
+			   FIELD_PREP(TX_SYS1_ACR_N_2_N_UPPER_NIBBLE,
+				      (audio_n >> 16) & 0xf));
+
+	regmap_write(priv->regmap, TX_SYS0_ACR_CTS_0, 0x0);
+	regmap_write(priv->regmap, TX_SYS0_ACR_CTS_1, 0x0);
+	regmap_write(priv->regmap, TX_SYS0_ACR_CTS_2,
+		     TX_SYS0_ACR_CTS_2_FORCE_ARC_STABLE);
+
+	regmap_write(priv->regmap, TX_AUDIO_CONTROL,
+		     TX_AUDIO_CONTROL_AUTO_AUDIO_FIFO_CLEAR |
+		     FIELD_PREP(TX_AUDIO_CONTROL_AUDIO_PACKET_TYPE_MASK,
+				meson_txc_hdmi_hdmi_codec_coding_type(hparms)) |
+		     TX_AUDIO_CONTROL_AUDIO_SAMPLE_PACKET_FLAT);
+
+	len = hdmi_audio_infoframe_pack(&hparms->cea, buf, sizeof(buf));
+	if (len < 0)
+		return len;
+
+	meson_txc_hdmi_write_infoframe(priv->regmap,
+				       TX_PKT_REG_AUDIO_INFO_BASE_ADDR,
+				       buf, len, true);
+
+	for (i = 0; i < ARRAY_SIZE(hparms->iec.status); i++) {
+		unsigned char sub1, sub2;
+
+		sub1 = sub2 = hparms->iec.status[i];
+
+		if (i == 2) {
+			sub1 |= FIELD_PREP(IEC958_AES2_CON_CHANNEL, 1);
+			sub2 |= FIELD_PREP(IEC958_AES2_CON_CHANNEL, 2);
+		}
+
+		regmap_write(priv->regmap, TX_IEC60958_SUB1_OFFSET + i, sub1);
+		regmap_write(priv->regmap, TX_IEC60958_SUB2_OFFSET + i, sub2);
+	}
+
+	return 0;
+}
+
+static int meson_txc_hdmi_hdmi_codec_audio_startup(struct device *dev,
+						   void *data)
+{
+	struct meson_txc_hdmi *priv = data;
+
+	regmap_update_bits(priv->regmap, TX_PACKET_CONTROL_2,
+			   TX_PACKET_CONTROL_2_AUDIO_REQUEST_DISABLE, 0x0);
+
+	/* reset audio master and sample */
+	regmap_write(priv->regmap, TX_SYS5_TX_SOFT_RESET_1,
+		     TX_SYS5_TX_SOFT_RESET_1_TX_AUDIO_RESAMPLE_RSTN |
+		     TX_SYS5_TX_SOFT_RESET_1_TX_AUDIO_MASTER_RSTN);
+	regmap_write(priv->regmap, TX_SYS5_TX_SOFT_RESET_1, 0x0);
+
+	regmap_write(priv->regmap, TX_AUDIO_CONTROL_MORE,
+		     TX_AUDIO_CONTROL_MORE_ENABLE);
+
+	regmap_write(priv->regmap, TX_AUDIO_FIFO,
+		     FIELD_PREP(TX_AUDIO_FIFO_FIFO_DEPTH_MASK,
+				TX_AUDIO_FIFO_FIFO_DEPTH_512) |
+		     FIELD_PREP(TX_AUDIO_FIFO_CRITICAL_THRESHOLD_MASK,
+			        TX_AUDIO_FIFO_CRITICAL_THRESHOLD_DEPTH_DIV16) |
+		     FIELD_PREP(TX_AUDIO_FIFO_NORMAL_THRESHOLD_MASK,
+			        TX_AUDIO_FIFO_NORMAL_THRESHOLD_DEPTH_DIV8));
+
+	regmap_write(priv->regmap, TX_AUDIO_LIPSYNC, 0x0);
+
+	regmap_write(priv->regmap, TX_SYS1_ACR_N_2,
+		     FIELD_PREP(TX_SYS1_ACR_N_2_N_MEAS_TOLERANCE, 0x3));
+
+	return 0;
+}
+
+static void meson_txc_hdmi_hdmi_codec_audio_shutdown(struct device *dev,
+						     void *data)
+{
+	struct meson_txc_hdmi *priv = data;
+
+	meson_txc_hdmi_disable_infoframe(priv, TX_PKT_REG_AUDIO_INFO_BASE_ADDR);
+
+	regmap_write(priv->regmap, TX_AUDIO_CONTROL_MORE, 0x0);
+	regmap_update_bits(priv->regmap, HDMI_OTHER_CTRL1,
+			   HDMI_OTHER_CTRL1_HDMI_AUDIO_CLOCK_ON, 0x0);
+
+	regmap_update_bits(priv->regmap, TX_PACKET_CONTROL_2,
+			   TX_PACKET_CONTROL_2_AUDIO_REQUEST_DISABLE,
+			   TX_PACKET_CONTROL_2_AUDIO_REQUEST_DISABLE);
+}
+
+static int meson_txc_hdmi_hdmi_codec_mute_stream(struct device *dev,
+						 void *data,
+						 bool enable, int direction)
+{
+	struct meson_txc_hdmi *priv = data;
+
+	regmap_write(priv->regmap, TX_AUDIO_PACK,
+		     enable ? 0 : TX_AUDIO_PACK_AUDIO_SAMPLE_PACKETS_ENABLE);
+
+	return 0;
+}
+
+static int meson_txc_hdmi_hdmi_codec_get_eld(struct device *dev, void *data,
+					     uint8_t *buf, size_t len)
+{
+	struct meson_txc_hdmi *priv = data;
+
+	if (priv->current_connector)
+		memcpy(buf, priv->current_connector->eld,
+		       min_t(size_t, MAX_ELD_BYTES, len));
+	else
+		memset(buf, 0, len);
+
+	return 0;
+}
+
+static int meson_txc_hdmi_hdmi_codec_get_dai_id(struct snd_soc_component *component,
+						struct device_node *endpoint)
+{
+	struct of_endpoint of_ep;
+	int ret;
+
+	ret = of_graph_parse_endpoint(endpoint, &of_ep);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * HDMI sound should be located as reg = <2>
+	 * Then, it is sound port 0
+	 */
+	if (of_ep.port == 2)
+		return 0;
+
+	return -EINVAL;
+}
+
+static int meson_txc_hdmi_hdmi_codec_hook_plugged_cb(struct device *dev,
+						     void *data,
+						     hdmi_codec_plugged_cb fn,
+						     struct device *codec_dev)
+{
+	struct meson_txc_hdmi *priv = data;
+
+	mutex_lock(&priv->codec_mutex);
+	priv->codec_plugged_cb = fn;
+	priv->codec_dev = codec_dev;
+	meson_txc_hdmi_handle_plugged_change(priv);
+	mutex_unlock(&priv->codec_mutex);
+
+	return 0;
+}
+
+static struct hdmi_codec_ops meson_txc_hdmi_hdmi_codec_ops = {
+	.hw_params		= meson_txc_hdmi_hdmi_codec_hw_params,
+	.audio_startup		= meson_txc_hdmi_hdmi_codec_audio_startup,
+	.audio_shutdown		= meson_txc_hdmi_hdmi_codec_audio_shutdown,
+	.mute_stream		= meson_txc_hdmi_hdmi_codec_mute_stream,
+	.get_eld		= meson_txc_hdmi_hdmi_codec_get_eld,
+	.get_dai_id		= meson_txc_hdmi_hdmi_codec_get_dai_id,
+	.hook_plugged_cb	= meson_txc_hdmi_hdmi_codec_hook_plugged_cb,
+};
+
+static int meson_txc_hdmi_hdmi_codec_init(struct meson_txc_hdmi *priv)
+{
+	struct hdmi_codec_pdata pdata = {
+		.ops			= &meson_txc_hdmi_hdmi_codec_ops,
+		.i2s			= 1,
+		.spdif			= 1,
+		.max_i2s_channels	= 8,
+		.data			= priv,
+	};
+
+	priv->hdmi_codec_pdev = platform_device_register_data(priv->dev,
+							      HDMI_CODEC_DRV_NAME,
+							      PLATFORM_DEVID_AUTO,
+							      &pdata, sizeof(pdata));
+	return PTR_ERR_OR_ZERO(priv->hdmi_codec_pdev);
+}
+
+static int meson_txc_hdmi_bind(struct device *dev, struct device *master,
+			       void *data)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct meson_txc_hdmi *priv;
+	void __iomem *base;
+	u32 regval;
+	int ret;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->dev = dev;
+
+	mutex_init(&priv->codec_mutex);
+
+	dev_set_drvdata(dev, priv);
+
+	base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	priv->regmap = devm_regmap_init(dev, NULL, base,
+					&meson_txc_hdmi_regmap_config);
+	if (IS_ERR(priv->regmap))
+		return PTR_ERR(priv->regmap);
+
+	priv->pclk = devm_clk_get(dev, "pclk");
+	if (IS_ERR(priv->pclk)) {
+		ret = PTR_ERR(priv->pclk);
+		return dev_err_probe(dev, ret, "Failed to get the pclk\n");
+	}
+
+	priv->sys_clk = devm_clk_get(dev, "sys");
+	if (IS_ERR(priv->sys_clk)) {
+		ret = PTR_ERR(priv->sys_clk);
+		return dev_err_probe(dev, ret,
+				     "Failed to get the sys clock\n");
+	}
+
+	priv->phy = devm_phy_get(dev, "hdmi");
+	if (IS_ERR(priv->phy)) {
+		ret = PTR_ERR(priv->phy);
+		return dev_err_probe(dev, ret, "Failed to get the HDMI PHY\n");
+	}
+
+	ret = meson_txc_hdmi_parse_dt(priv);
+	if (ret)
+		return ret;
+
+	ret = clk_prepare_enable(priv->pclk);
+	if (ret) {
+		dev_err_probe(dev, ret, "Failed to enable the pclk\n");
+		return ret;
+	}
+
+	regval = readl(base + HDMI_CTRL_PORT);
+	regval |= HDMI_CTRL_PORT_APB3_ERR_EN;
+	writel(regval, base + HDMI_CTRL_PORT);
+
+	ret = meson_txc_hdmi_hw_init(priv);
+	if (ret)
+		goto err_disable_clk;
+
+	ret = meson_txc_hdmi_hdmi_codec_init(priv);
+	if (ret)
+		goto err_hw_exit;
+
+	priv->bridge.driver_private = priv;
+	priv->bridge.funcs = &meson_txc_hdmi_bridge_funcs;
+	priv->bridge.ops = DRM_BRIDGE_OP_DETECT | DRM_BRIDGE_OP_EDID;
+	priv->bridge.of_node = dev->of_node;
+	priv->bridge.interlace_allowed = true;
+
+	drm_bridge_add(&priv->bridge);
+
+	return 0;
+
+err_hw_exit:
+	meson_txc_hdmi_hw_exit(priv);
+err_disable_clk:
+	clk_disable_unprepare(priv->pclk);
+	return ret;
+}
+
+static void meson_txc_hdmi_unbind(struct device *dev, struct device *master,
+				  void *data)
+{
+	struct meson_txc_hdmi *priv = dev_get_drvdata(dev);
+
+	platform_device_unregister(priv->hdmi_codec_pdev);
+
+	drm_bridge_remove(&priv->bridge);
+
+	meson_txc_hdmi_hw_exit(priv);
+
+	clk_disable_unprepare(priv->pclk);
+}
+
+static const struct component_ops meson_txc_hdmi_component_ops = {
+	.bind = meson_txc_hdmi_bind,
+	.unbind = meson_txc_hdmi_unbind,
+};
+
+static int meson_txc_hdmi_probe(struct platform_device *pdev)
+{
+	return component_add(&pdev->dev, &meson_txc_hdmi_component_ops);
+}
+
+static int meson_txc_hdmi_remove(struct platform_device *pdev)
+{
+	component_del(&pdev->dev, &meson_txc_hdmi_component_ops);
+
+	return 0;
+}
+
+static const struct of_device_id meson_txc_hdmi_of_table[] = {
+	{ .compatible = "amlogic,meson8-hdmi-tx" },
+	{ .compatible = "amlogic,meson8b-hdmi-tx" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, meson_txc_hdmi_of_table);
+
+static struct platform_driver meson_txc_hdmi_platform_driver = {
+	.probe		= meson_txc_hdmi_probe,
+	.remove		= meson_txc_hdmi_remove,
+	.driver		= {
+		.name		= "meson-transwitch-hdmi",
+		.of_match_table	= meson_txc_hdmi_of_table,
+	},
+};
+module_platform_driver(meson_txc_hdmi_platform_driver);
+
+MODULE_AUTHOR("Martin Blumenstingl <martin.blumenstingl@googlemail.com>");
+MODULE_DESCRIPTION("Amlogic Meson8 and Meson8b TranSwitch HDMI 1.4 TX driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/meson/meson_transwitch_hdmi.h b/drivers/gpu/drm/meson/meson_transwitch_hdmi.h
new file mode 100644
index 000000000000..14929475c0c8
--- /dev/null
+++ b/drivers/gpu/drm/meson/meson_transwitch_hdmi.h
@@ -0,0 +1,536 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2021 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ *
+ * All registers and magic values are taken from Amlogic's GPL kernel sources:
+ *   Copyright (C) 2010 Amlogic, Inc.
+ */
+
+#include <linux/bitfield.h>
+#include <linux/bits.h>
+
+#ifndef __MESON_TRANSWITCH_HDMI_H__
+#define __MESON_TRANSWITCH_HDMI_H__
+
+/* HDMI TX register */
+
+// System config 0
+#define TX_SYS0_AFE_SIGNAL						0x0000
+#define TX_SYS0_AFE_LOOP						0x0001
+#define TX_SYS0_ACR_CTS_0						0x0002
+	#define TX_SYS0_ACR_CTS_0_AUDIO_CTS_BYTE0		GENMASK(7, 0)
+#define TX_SYS0_ACR_CTS_1						0x0003
+	#define TX_SYS0_ACR_CTS_1_AUDIO_CTS_BYTE1		GENMASK(7, 0)
+#define TX_SYS0_ACR_CTS_2						0x0004
+	#define TX_SYS0_ACR_CTS_2_FORCE_ARC_STABLE			BIT(5)
+#define TX_SYS0_BIST_CONTROL						0x0005
+	#define TX_SYS0_BIST_CONTROL_AFE_BIST_ENABLE			BIT(7)
+	#define TX_SYS0_BIST_CONTROL_TMDS_SHIFT_PATTERN_SELECT		BIT(6)
+	#define TX_SYS0_BIST_CONTROL_TMDS_PRBS_PATTERN_SELECT	GENMASK(5, 4)
+	#define TX_SYS0_BIST_CONTROL_TMDS_REPEAT_BIST_PATTERN	GENMASK(2, 0)
+
+#define TX_SYS0_BIST_DATA_0						0x0006
+#define TX_SYS0_BIST_DATA_1						0x0007
+#define TX_SYS0_BIST_DATA_2						0x0008
+#define TX_SYS0_BIST_DATA_3						0x0009
+#define TX_SYS0_BIST_DATA_4						0x000A
+#define TX_SYS0_BIST_DATA_5						0x000B
+#define TX_SYS0_BIST_DATA_6						0x000C
+#define TX_SYS0_BIST_DATA_7						0x000D
+#define TX_SYS0_BIST_DATA_8						0x000E
+#define TX_SYS0_BIST_DATA_9						0x000F
+
+// system config 1
+#define TX_HDMI_PHY_CONFIG0						0x0010
+	#define TX_HDMI_PHY_CONFIG0_HDMI_COMMON_B7_B0		GENMASK(7, 0)
+#define TX_HDMI_PHY_CONFIG1						0x0010
+	#define TX_HDMI_PHY_CONFIG1_HDMI_COMMON_B11_B8		GENMASK(3, 0)
+	#define TX_HDMI_PHY_CONFIG1_HDMI_CTL_REG_B3_B0		GENMASK(7, 4)
+#define TX_HDMI_PHY_CONFIG2						0x0012
+    #define TX_HDMI_PHY_CONFIG_HDMI_CTL_REG_B11_B4		GENMASK(7, 0)
+#define TX_HDMI_PHY_CONFIG3						0x0013
+	#define TX_HDMI_PHY_CONFIG3_HDMI_L2H_CTL		GENMASK(3, 0)
+	#define TX_HDMI_PHY_CONFIG3_HDMI_MDR_PU			GENMASK(7, 4)
+#define TX_HDMI_PHY_CONFIG4						0x0014
+	#define TX_HDMI_PHY_CONFIG4_HDMI_LF_PD				BIT(0)
+	#define TX_HDMI_PHY_CONFIG4_HDMI_PHY_CLK_EN			BIT(1)
+	#define TX_HDMI_PHY_CONFIG4_HDMI_MODE			GENMASK(3, 2)
+	#define TX_HDMI_PHY_CONFIG4_HDMI_MODE_NORMAL			0x0
+	#define TX_HDMI_PHY_CONFIG4_HDMI_MODE_CLK_CH3_EQUAL_CH0		0x1
+	#define TX_HDMI_PHY_CONFIG4_HDMI_MODE_ALTERNATE_HIGH_LOW	0x2
+	#define TX_HDMI_PHY_CONFIG4_HDMI_MODE_ALTERNATE_LOW_HIGH	0x3
+	#define TX_HDMI_PHY_CONFIG4_HDMI_PREM_CTL		GENMASK(7, 4)
+#define TX_HDMI_PHY_CONFIG5						0x0015
+	#define TX_HDMI_PHY_CONFIG5_HDMI_VCM_CTL		GENMASK(7, 5)
+	#define TX_HDMI_PHY_CONFIG5_HDMI_PREFCTL		GENMASK(2, 0)
+#define TX_HDMI_PHY_CONFIG6						0x0016
+	#define TX_HDMI_PHY_CONFIG6_HDMI_RTERM_CTL		GENMASK(3, 0)
+	#define TX_HDMI_PHY_CONFIG6_HDMI_SWING_CTL		GENMASK(7, 4)
+#define TX_SYS1_AFE_TEST						0x0017
+#define TX_SYS1_PLL							0x0018
+#define TX_SYS1_TUNE							0x0019
+#define TX_SYS1_AFE_CONNECT						0x001A
+
+#define TX_SYS1_ACR_N_0							0x001C
+	#define TX_SYS1_ACR_N_0_N_BYTE0				GENMASK(7, 0)
+#define TX_SYS1_ACR_N_1							0x001D
+	#define TX_SYS1_ACR_N_1_N_BYTE1				GENMASK(7, 0)
+#define TX_SYS1_ACR_N_2							0x001E
+	#define TX_SYS1_ACR_N_2_N_MEAS_TOLERANCE		GENMASK(7, 4)
+	#define TX_SYS1_ACR_N_2_N_UPPER_NIBBLE			GENMASK(3, 0)
+#define TX_SYS1_PRBS_DATA						0x001F
+	#define TX_SYS1_PRBS_DATA_PRBS_MODE			GENMASK(1, 0)
+	#define TX_SYS1_PRBS_DATA_PRBS_MODE_11				0x0
+	#define TX_SYS1_PRBS_DATA_PRBS_MODE_15				0x1
+	#define TX_SYS1_PRBS_DATA_PRBS_MODE_7				0x2
+	#define TX_SYS1_PRBS_DATA_PRBS_MODE_31				0x3
+
+// HDCP CONFIG
+#define TX_HDCP_ECC_CONFIG						0x0024
+#define TX_HDCP_CRC_CONFIG						0x0025
+#define TX_HDCP_EDID_CONFIG						0x0026
+	#define TX_HDCP_EDID_CONFIG_FORCED_SYS_TRIGGER			BIT(7)
+	#define TX_HDCP_EDID_CONFIG_SYS_TRIGGER_CONFIG			BIT(6)
+	#define TX_HDCP_EDID_CONFIG_MEM_ACC_SEQ_MODE			BIT(5)
+	#define TX_HDCP_EDID_CONFIG_MEM_ACC_SEQ_START			BIT(4)
+	#define TX_HDCP_EDID_CONFIG_FORCED_MEM_COPY_DONE		BIT(3)
+	#define TX_HDCP_EDID_CONFIG_MEM_COPY_DONE_CONFIG		BIT(2)
+	#define TX_HDCP_EDID_CONFIG_SYS_TRIGGER_CONFIG_SEMI_MANU	BIT(1)
+
+#define TX_HDCP_MEM_CONFIG						0x0027
+	#define TX_HDCP_MEM_CONFIG_READ_DECRYPT				BIT(3)
+
+#define TX_HDCP_HPD_FILTER_L						0x0028
+#define TX_HDCP_HPD_FILTER_H						0x0029
+#define TX_HDCP_ENCRYPT_BYTE						0x002A
+#define TX_HDCP_CONFIG0							0x002B
+	#define TX_HDCP_CONFIG0_ROM_ENCRYPT_OFF			GENMASK(4, 3)
+
+#define TX_HDCP_CONFIG1							0x002C
+#define TX_HDCP_CONFIG2							0x002D
+#define TX_HDCP_CONFIG3							0x002E
+	#define TX_HDCP_CONFIG3_DDC_I2C_BUS_CLOCK_TIME_DIVIDER	GENMASK(7, 0)
+
+#define TX_HDCP_MODE							0x002F
+	#define TX_HDCP_MODE_CP_DESIRED					BIT(7)
+	#define TX_HDCP_MODE_ESS_CONFIG					BIT(6)
+	#define TX_HDCP_MODE_SET_AVMUTE					BIT(5)
+	#define TX_HDCP_MODE_CLEAR_AVMUTE				BIT(4)
+	#define TX_HDCP_MODE_HDCP_1_1					BIT(3)
+	#define TX_HDCP_MODE_VSYNC_HSYNC_FORCED_POLARITY_SELECT		BIT(2)
+	#define TX_HDCP_MODE_FORCED_VSYNC_POLARITY			BIT(1)
+	#define TX_HDCP_MODE_FORCED_HSYNC_POLARITY			BIT(0)
+
+// Video config, part 1
+#define TX_VIDEO_ACTIVE_PIXELS_0					0x0030
+#define TX_VIDEO_ACTIVE_PIXELS_1					0x0031
+#define TX_VIDEO_FRONT_PIXELS						0x0032
+#define TX_VIDEO_HSYNC_PIXELS						0x0033
+#define TX_VIDEO_BACK_PIXELS						0x0034
+#define TX_VIDEO_ACTIVE_LINES_0						0x0035
+#define TX_VIDEO_ACTIVE_LINES_1						0x0036
+#define TX_VIDEO_EOF_LINES						0x0037
+#define TX_VIDEO_VSYNC_LINES						0x0038
+#define TX_VIDEO_SOF_LINES						0x0039
+#define TX_VIDEO_DTV_TIMING						0x003A
+	#define TX_VIDEO_DTV_TIMING_FORCE_DTV_TIMING_AUTO		BIT(7)
+	#define TX_VIDEO_DTV_TIMING_FORCE_VIDEO_SCAN			BIT(6)
+	#define TX_VIDEO_DTV_TIMING_FORCE_VIDEO_FIELD			BIT(5)
+	#define TX_VIDEO_DTV_TIMING_DISABLE_VIC39_CORRECTION		BIT(4)
+
+#define TX_VIDEO_DTV_MODE						0x003B
+	#define TX_VIDEO_DTV_MODE_FORCED_DEFAULT_PHASE			BIT(7)
+	#define TX_VIDEO_DTV_MODE_COLOR_DEPTH			GENMASK(1, 0)
+
+#define TX_VIDEO_DTV_FORMAT0						0x003C
+#define TX_VIDEO_DTV_FORMAT1						0x003D
+#define TX_VIDEO_PIXEL_PACK						0x003F
+// video config, part 2
+#define TX_VIDEO_CSC_COEFF_B0						0x0040
+#define TX_VIDEO_CSC_COEFF_B1						0x0041
+#define TX_VIDEO_CSC_COEFF_R0						0x0042
+#define TX_VIDEO_CSC_COEFF_R1						0x0043
+#define TX_VIDEO_CSC_COEFF_CB0						0x0044
+#define TX_VIDEO_CSC_COEFF_CB1						0x0045
+#define TX_VIDEO_CSC_COEFF_CR0						0x0046
+#define TX_VIDEO_CSC_COEFF_CR1						0x0047
+#define TX_VIDEO_DTV_OPTION_L						0x0048
+	#define TX_VIDEO_DTV_OPTION_L_OUTPUT_COLOR_FORMAT	GENMASK(7, 6)
+	#define TX_VIDEO_DTV_OPTION_L_INPUT_COLOR_FORMAT	GENMASK(5, 4)
+	#define TX_VIDEO_DTV_OPTION_L_OUTPUT_COLOR_DEPTH	GENMASK(3, 2)
+	#define TX_VIDEO_DTV_OPTION_L_INPUT_COLOR_DEPTH		GENMASK(1, 0)
+
+#define TX_VIDEO_DTV_OPTION_H						0x0049
+	#define TX_VIDEO_DTV_OPTION_H_COLOR_RANGE_16_235		0x0
+	#define TX_VIDEO_DTV_OPTION_H_COLOR_RANGE_16_240		0x1
+	#define TX_VIDEO_DTV_OPTION_H_COLOR_RANGE_1_254			0x2
+	#define TX_VIDEO_DTV_OPTION_H_COLOR_RANGE_0_255			0x3
+	#define TX_VIDEO_DTV_OPTION_H_OUTPUT_COLOR_RANGE	GENMASK(3, 2)
+	#define TX_VIDEO_DTV_OPTION_H_INPUT_COLOR_RANGE		GENMASK(1, 0)
+
+#define TX_VIDEO_DTV_FILTER						0x004A
+#define TX_VIDEO_DTV_DITHER						0x004B
+#define TX_VIDEO_DTV_DEDITHER						0x004C
+#define TX_VIDEO_PROC_CONFIG0						0x004E
+#define TX_VIDEO_PROC_CONFIG1						0x004F
+
+// Audio config
+#define TX_AUDIO_FORMAT							0x0058
+	#define TX_AUDIO_FORMAT_SPDIF_OR_I2S				BIT(7)
+	#define TX_AUDIO_FORMAT_I2S_2_OR_8_CH				BIT(6)
+	#define TX_AUDIO_FORMAT_I2S_FORMAT			GENMASK(5, 4)
+	#define TX_AUDIO_FORMAT_BIT_WIDTH_MASK			GENMASK(3, 2)
+	#define TX_AUDIO_FORMAT_BIT_WIDTH_16				0x1
+	#define TX_AUDIO_FORMAT_BIT_WIDTH_20				0x2
+	#define TX_AUDIO_FORMAT_BIT_WIDTH_24				0x3
+	#define TX_AUDIO_FORMAT_WS_POLARITY				BIT(1)
+	#define TX_AUDIO_FORMAT_I2S_ONE_BIT_OR_I2S			BIT(0)
+	#define TX_AUDIO_FORMAT_SPDIF_CHANNEL_STATUS_FROM_DATA_OR_REG	BIT(0)
+
+#define TX_AUDIO_SPDIF							0x0059
+	#define TX_AUDIO_SPDIF_ENABLE					BIT(0)
+#define TX_AUDIO_I2S							0x005A
+	#define TX_AUDIO_I2S_ENABLE					BIT(0)
+#define TX_AUDIO_FIFO							0x005B
+	#define TX_AUDIO_FIFO_FIFO_DEPTH_MASK			GENMASK(7, 4)
+	#define TX_AUDIO_FIFO_FIFO_DEPTH_512				0x4
+	#define TX_AUDIO_FIFO_CRITICAL_THRESHOLD_MASK		GENMASK(3, 2)
+	#define TX_AUDIO_FIFO_CRITICAL_THRESHOLD_DEPTH_DIV16		0x2
+	#define TX_AUDIO_FIFO_NORMAL_THRESHOLD_MASK		GENMASK(1, 0)
+	#define TX_AUDIO_FIFO_NORMAL_THRESHOLD_DEPTH_DIV8		0x1
+#define TX_AUDIO_LIPSYNC						0x005C
+	#define TX_AUDIO_LIPSYNC_NORMALIZED_LIPSYNC_PARAM	GENMASK(7, 0)
+#define TX_AUDIO_CONTROL						0x005D
+	#define TX_AUDIO_CONTROL_FORCED_AUDIO_FIFO_CLEAR		BIT(7)
+	#define TX_AUDIO_CONTROL_AUTO_AUDIO_FIFO_CLEAR			BIT(6)
+	#define TX_AUDIO_CONTROL_AUDIO_PACKET_TYPE_MASK		GENMASK(5, 4)
+	#define TX_AUDIO_CONTROL_AUDIO_PACKET_TYPE_AUDIO_SAMPLE_PACKET	0x0
+	#define TX_AUDIO_CONTROL_AUDIO_PACKET_TYPE_ONE_BIT_AUDIO	0x1
+	#define TX_AUDIO_CONTROL_AUDIO_PACKET_TYPE_HBR_AUDIO_PACKET	0x2
+	#define TX_AUDIO_CONTROL_AUDIO_PACKET_TYPE_DST_AUDIO_PACKET	0x3
+	#define TX_AUDIO_CONTROL_AUDIO_SAMPLE_PACKET_VALID		BIT(2)
+	#define TX_AUDIO_CONTROL_AUDIO_SAMPLE_PACKET_USER		BIT(1)
+	#define TX_AUDIO_CONTROL_AUDIO_SAMPLE_PACKET_FLAT		BIT(0)
+#define TX_AUDIO_HEADER							0x005E
+	#define TX_AUDIO_HEADER_AUDIO_SAMPLE_PACKET_HEADER_LAYOUT1	BIT(7)
+	#define TX_AUDIO_HEADER_SET_NORMAL_DOUBLE_IN_DST_PACKET_HEADER	BIT(6)
+#define TX_AUDIO_SAMPLE							0x005F
+	#define TX_AUDIO_SAMPLE_CHANNEL_VALID			GENMASK(7, 0)
+#define TX_AUDIO_VALID							0x0060
+#define TX_AUDIO_USER							0x0061
+#define TX_AUDIO_PACK							0x0062
+	#define TX_AUDIO_PACK_AUDIO_SAMPLE_PACKETS_ENABLE		BIT(0)
+#define TX_AUDIO_CONTROL_MORE						0x0064
+	#define TX_AUDIO_CONTROL_MORE_ENABLE				BIT(0)
+
+// tmds config
+#define TX_TMDS_MODE							0x0068
+	#define TX_TMDS_MODE_FORCED_HDMI				BIT(7)
+	#define TX_TMDS_MODE_HDMI_CONFIG				BIT(6)
+	#define TX_TMDS_MODE_BIT_SWAP					BIT(3)
+	#define TX_TMDS_MODE_CHANNEL_SWAP			GENMASK(2, 0)
+
+#define TX_TMDS_CONFIG0							0x006C
+#define TX_TMDS_CONFIG1							0x006D
+
+// packet config
+#define TX_PACKET_ALLOC_ACTIVE_1					0x0078
+#define TX_PACKET_ALLOC_ACTIVE_2					0x0079
+#define TX_PACKET_ALLOC_EOF_1						0x007A
+#define TX_PACKET_ALLOC_EOF_2						0x007B
+#define TX_PACKET_ALLOC_SOF_1						0x007C
+#define TX_PACKET_ALLOC_SOF_2						0x007D
+#define TX_PACKET_CONTROL_1						0x007E
+	#define TX_PACKET_CONTROL_1_FORCE_PACKET_TIMING			BIT(7)
+	#define TX_PACKET_CONTROL_1_PACKET_ALLOC_MODE			BIT(6)
+	#define TX_PACKET_CONTROL_1_PACKET_START_LATENCY	GENMASK(5, 0)
+
+#define TX_PACKET_CONTROL_2						0x007F
+	#define TX_PACKET_CONTROL_2_AUDIO_REQUEST_DISABLE		BIT(3)
+	#define TX_PACKET_CONTROL_2_HORIZONTAL_GC_PACKET_TRANSPORT_EN	BIT(1)
+
+#define TX_CORE_EDID_CONFIG_MORE					0x0080
+	#define TX_CORE_EDID_CONFIG_MORE_KEEP_EDID_ERROR		BIT(1)
+	#define TX_CORE_EDID_CONFIG_MORE_SYS_TRIGGER_CONFIG_SEMI_MANU	BIT(0)
+
+#define TX_CORE_ALLOC_VSYNC_0						0x0081
+#define TX_CORE_ALLOC_VSYNC_1						0x0082
+#define TX_CORE_ALLOC_VSYNC_2						0x0083
+#define TX_MEM_PD_REG0							0x0084
+
+// core config
+#define TX_CORE_DATA_CAPTURE_1						0x00F0
+#define TX_CORE_DATA_CAPTURE_2						0x00F1
+	#define TX_CORE_DATA_CAPTURE_2_AUDIO_SOURCE_SELECT	GENMASK(7, 6)
+	#define TX_CORE_DATA_CAPTURE_2_EXTERNAL_PACKET_ENABLE		BIT(5)
+	#define TX_CORE_DATA_CAPTURE_2_INTERNAL_PACKET_ENABLE		BIT(4)
+	#define TX_CORE_DATA_CAPTURE_2_AFE_FIFO_SRC_LANE1	GENMASK(3, 2)
+	#define TX_CORE_DATA_CAPTURE_2_AFE_FIFO_SRC_LANE0	GENMASK(1, 0)
+
+#define TX_CORE_DATA_MONITOR_1						0x00F2
+	#define TX_CORE_DATA_MONITOR_1_LANE1				BIT(7)
+	#define TX_CORE_DATA_MONITOR_1_SELECT_LANE1		GENMASK(6, 4)
+	#define TX_CORE_DATA_MONITOR_1_LANE0				BIT(3)
+	#define TX_CORE_DATA_MONITOR_1_SELECT_LANE0		GENMASK(2, 0)
+
+#define TX_CORE_DATA_MONITOR_2						0x00F3
+	#define TX_CORE_DATA_MONITOR_2_MONITOR_SELECT		GENMASK(2, 0)
+
+#define TX_CORE_CALIB_MODE						0x00F4
+#define TX_CORE_CALIB_SAMPLE_DELAY					0x00F5
+#define TX_CORE_CALIB_VALUE_AUTO					0x00F6
+#define TX_CORE_CALIB_VALUE						0x00F7
+
+// system config 4
+#define TX_SYS4_TX_CKI_DDR						0x00A0
+#define TX_SYS4_TX_CKO_DDR						0x00A1
+#define TX_SYS4_RX_CKI_DDR						0x00A2
+#define TX_SYS4_RX_CKO_DDR						0x00A3
+#define TX_SYS4_CONNECT_SEL_0						0x00A4
+#define TX_SYS4_CONNECT_SEL_1						0x00A5
+	#define TX_SYS4_CONNECT_SEL_1_TX_CONNECT_SEL_UPPER_CHANNEL_DATA	BIT(6)
+
+#define TX_SYS4_CONNECT_SEL_2						0x00A6
+#define TX_SYS4_CONNECT_SEL_3						0x00A7
+#define TX_SYS4_CK_INV_VIDEO						0x00A8
+	#define TX_SYS4_CK_INV_VIDEO_TMDS_CLK_PATTERN			BIT(4)
+#define TX_SYS4_CK_INV_AUDIO						0x00A9
+#define TX_SYS4_CK_INV_AFE						0x00AA
+#define TX_SYS4_CK_INV_CH01						0x00AB
+#define TX_SYS4_CK_INV_CH2						0x00AC
+#define TX_SYS4_CK_CEC							0x00AD
+#define TX_SYS4_CK_SOURCE_1						0x00AE
+#define TX_SYS4_CK_SOURCE_2						0x00AF
+
+#define TX_IEC60958_SUB1_OFFSET						0x00B0
+#define TX_IEC60958_SUB2_OFFSET						0x00C8
+
+// system config 5
+#define TX_SYS5_TX_SOFT_RESET_1						0x00E0
+	#define TX_SYS5_TX_SOFT_RESET_1_TX_PIXEL_RSTN			BIT(7)
+	#define TX_SYS5_TX_SOFT_RESET_1_TX_TMDS_RSTN			BIT(6)
+	#define TX_SYS5_TX_SOFT_RESET_1_TX_AUDIO_MASTER_RSTN		BIT(5)
+	#define TX_SYS5_TX_SOFT_RESET_1_TX_AUDIO_RESAMPLE_RSTN		BIT(4)
+	#define TX_SYS5_TX_SOFT_RESET_1_TX_I2S_RESET_RSTN		BIT(3)
+	#define TX_SYS5_TX_SOFT_RESET_1_TX_DIG_RESET_N_CH2		BIT(2)
+	#define TX_SYS5_TX_SOFT_RESET_1_TX_DIG_RESET_N_CH1		BIT(1)
+	#define TX_SYS5_TX_SOFT_RESET_1_TX_DIG_RESET_N_CH0		BIT(0)
+
+#define TX_SYS5_TX_SOFT_RESET_2						0x00E1
+	#define TX_SYS5_TX_SOFT_RESET_2_HDMI_CH3_RST_IN			BIT(7)
+	#define TX_SYS5_TX_SOFT_RESET_2_HDMI_CH2_RST_IN			BIT(6)
+	#define TX_SYS5_TX_SOFT_RESET_2_HDMI_CH1_RST_IN			BIT(5)
+	#define TX_SYS5_TX_SOFT_RESET_2_HDMI_CH0_RST_IN			BIT(4)
+	#define TX_SYS5_TX_SOFT_RESET_2_HDMI_SR_RST			BIT(3)
+	#define TX_SYS5_TX_SOFT_RESET_2_TX_DDC_HDCP_RSTN		BIT(2)
+	#define TX_SYS5_TX_SOFT_RESET_2_TX_DDC_EDID_RSTN		BIT(1)
+	#define TX_SYS5_TX_SOFT_RESET_2_TX_DIG_RESET_N_CH3		BIT(0)
+
+#define TX_SYS5_RX_SOFT_RESET_1						0x00E2
+#define TX_SYS5_RX_SOFT_RESET_2						0x00E3
+#define TX_SYS5_RX_SOFT_RESET_3						0x00E4
+#define TX_SYS5_SSTL_BIDIR_IN						0x00E5
+#define TX_SYS5_SSTL_IN							0x00E6
+#define TX_SYS5_SSTL_DIFF_IN						0x00E7
+#define TX_SYS5_FIFO_CONFIG						0x00E8
+	#define TX_SYS5_FIFO_CONFIG_AFE_FIFO_CHANNEL2_BYPASS		BIT(6)
+	#define TX_SYS5_FIFO_CONFIG_AFE_FIFO_CHANNEL1_BYPASS		BIT(5)
+	#define TX_SYS5_FIFO_CONFIG_AFE_FIFO_CHANNEL0_BYPASS		BIT(4)
+	#define TX_SYS5_FIFO_CONFIG_CLK_CHANNEL3_OUTPUT_ENABLE		BIT(3)
+	#define TX_SYS5_FIFO_CONFIG_AFE_FIFO_CHANNEL2_ENABLE		BIT(2)
+	#define TX_SYS5_FIFO_CONFIG_AFE_FIFO_CHANNEL1_ENABLE		BIT(1)
+	#define TX_SYS5_FIFO_CONFIG_AFE_FIFO_CHANNEL0_ENABLE		BIT(0)
+
+#define TX_SYS5_FIFO_SAMP01_CFG						0x00E9
+#define TX_SYS5_FIFO_SAMP23_CFG						0x00EA
+#define TX_SYS5_CONNECT_FIFO_CFG					0x00EB
+#define TX_SYS5_IO_CALIB_CONTROL					0x00EC
+#define TX_SYS5_SSTL_BIDIR_OUT						0x00ED
+#define TX_SYS5_SSTL_OUT						0x00EE
+#define TX_SYS5_SSTL_DIFF_OUT						0x00EF
+
+// HDCP shadow register
+#define TX_HDCP_SHW_BKSV_0						0x0100
+#define TX_HDCP_SHW_BKSV_1						0x0101
+#define TX_HDCP_SHW_BKSV_2						0x0102
+#define TX_HDCP_SHW_BKSV_3						0x0103
+#define TX_HDCP_SHW_BKSV_4						0x0104
+#define TX_HDCP_SHW_RI1_0						0x0108
+#define TX_HDCP_SHW_RI1_1						0x0109
+#define TX_HDCP_SHW_PJ1							0x010A
+#define TX_HDCP_SHW_AKSV_0						0x0110
+#define TX_HDCP_SHW_AKSV_1						0x0111
+#define TX_HDCP_SHW_AKSV_2						0x0112
+#define TX_HDCP_SHW_AKSV_3						0x0113
+#define TX_HDCP_SHW_AKSV_4						0x0114
+#define TX_HDCP_SHW_AINFO						0x0115
+#define TX_HDCP_SHW_AN_0						0x0118
+#define TX_HDCP_SHW_AN_1						0x0119
+#define TX_HDCP_SHW_AN_2						0x011A
+#define TX_HDCP_SHW_AN_3						0x011B
+#define TX_HDCP_SHW_AN_4						0x011C
+#define TX_HDCP_SHW_AN_5						0x011D
+#define TX_HDCP_SHW_AN_6						0x011E
+#define TX_HDCP_SHW_AN_7						0x011F
+#define TX_HDCP_SHW_V1_H0_0						0x0120
+#define TX_HDCP_SHW_V1_H0_1						0x0121
+#define TX_HDCP_SHW_V1_H0_2						0x0122
+#define TX_HDCP_SHW_V1_H0_3						0x0123
+#define TX_HDCP_SHW_V1_H1_0						0x0124
+#define TX_HDCP_SHW_V1_H1_1						0x0125
+#define TX_HDCP_SHW_V1_H1_2						0x0126
+#define TX_HDCP_SHW_V1_H1_3						0x0127
+#define TX_HDCP_SHW_V1_H2_0						0x0128
+#define TX_HDCP_SHW_V1_H2_1						0x0129
+#define TX_HDCP_SHW_V1_H2_2						0x012A
+#define TX_HDCP_SHW_V1_H2_3						0x012B
+#define TX_HDCP_SHW_V1_H3_0						0x012C
+#define TX_HDCP_SHW_V1_H3_1						0x012D
+#define TX_HDCP_SHW_V1_H3_2						0x012E
+#define TX_HDCP_SHW_V1_H3_3						0x012F
+#define TX_HDCP_SHW_V1_H4_0						0x0130
+#define TX_HDCP_SHW_V1_H4_1						0x0131
+#define TX_HDCP_SHW_V1_H4_2						0x0132
+#define TX_HDCP_SHW_V1_H4_3						0x0133
+#define TX_HDCP_SHW_BCAPS						0x0140
+#define TX_HDCP_SHW_BSTATUS_0						0x0141
+#define TX_HDCP_SHW_BSTATUS_1						0x0142
+#define TX_HDCP_SHW_KSV_FIFO						0x0143
+
+// system status 0
+#define TX_SYSST0_CONNECT_FIFO						0x0180
+#define TX_SYSST0_PLL_MONITOR						0x0181
+#define TX_SYSST0_AFE_FIFO						0x0182
+#define TX_SYSST0_ROM_STATUS						0x018F
+
+// hdcp status
+#define TX_HDCP_ST_AUTHENTICATION					0x0190
+#define TX_HDCP_ST_FRAME_COUNT						0x0191
+#define TX_HDCP_ST_STATUS_0						0x0192
+#define TX_HDCP_ST_STATUS_1						0x0193
+#define TX_HDCP_ST_STATUS_2						0x0194
+#define TX_HDCP_ST_STATUS_3						0x0195
+#define TX_HDCP_ST_EDID_STATUS						0x0196
+	#define TX_HDCP_ST_EDID_STATUS_SYSTEM_STATUS		GENMASK(7, 6)
+	#define TX_HDCP_ST_EDID_STATUS_SYSTEM_STATUS_NO_SINK_ATTACHED	0x0
+	#define TX_HDCP_ST_EDID_STATUS_SYSTEM_STATUS_READING_EDID	0x1
+	#define TX_HDCP_ST_EDID_STATUS_SYSTEM_STATUS_DVI_MODE		0x2
+	#define TX_HDCP_ST_EDID_STATUS_SYSTEM_STATUS_HDMI_MODE		0x3
+	#define TX_HDCP_ST_EDID_STATUS_EDID_DATA_READY			BIT(4)
+	#define TX_HDCP_ST_EDID_STATUS_HPD_STATUS			BIT(1)
+
+#define TX_HDCP_ST_MEM_STATUS						0x0197
+#define TX_HDCP_ST_ST_MODE						0x019F
+
+// video status
+#define TX_VIDEO_ST_ACTIVE_PIXELS_1					0x01A0
+#define TX_VIDEO_ST_ACTIVE_PIXELS_2					0x01A1
+#define TX_VIDEO_ST_FRONT_PIXELS					0x01A2
+#define TX_VIDEO_ST_HSYNC_PIXELS					0x01A3
+#define TX_VIDEO_ST_BACK_PIXELS						0x01A4
+#define TX_VIDEO_ST_ACTIVE_LINES_1					0x01A5
+#define TX_VIDEO_ST_ACTIVE_LINES_2					0x01A6
+#define TX_VIDEO_ST_EOF_LINES						0x01A7
+#define TX_VIDEO_ST_VSYNC_LINES						0x01A8
+#define TX_VIDEO_ST_SOF_LINES						0x01A9
+#define TX_VIDEO_ST_DTV_TIMING						0x01AA
+#define TX_VIDEO_ST_DTV_MODE						0x01AB
+// audio status
+#define TX_VIDEO_ST_AUDIO_STATUS					0x01AC
+#define TX_AFE_STATUS_0							0x01AE
+#define TX_AFE_STATUS_1							0x01AF
+
+#define TX_IEC60958_ST_SUB1_OFFSET					0x01B0
+#define TX_IEC60958_ST_SUB2_OFFSET					0x01C8
+
+// system status 1
+#define TX_SYSST1_CALIB_BIT_RESULT_0					0x01E0
+#define TX_SYSST1_CALIB_BIT_RESULT_1					0x01E1
+//HDMI_STATUS_OUT[7:0]
+#define TX_HDMI_PHY_READBACK_0						0x01E2
+//HDMI_COMP_OUT[4]
+//HDMI_STATUS_OUT[11:8]
+#define TX_HDMI_PHY_READBACK_1						0x01E3
+#define TX_SYSST1_CALIB_BIT_RESULT_4					0x01E4
+#define TX_SYSST1_CALIB_BIT_RESULT_5					0x01E5
+#define TX_SYSST1_CALIB_BIT_RESULT_6					0x01E6
+#define TX_SYSST1_CALIB_BIT_RESULT_7					0x01E7
+#define TX_SYSST1_CALIB_BUS_RESULT_0					0x01E8
+#define TX_SYSST1_CALIB_BUS_RESULT_1					0x01E9
+#define TX_SYSST1_CALIB_BUS_RESULT_2					0x01EA
+#define TX_SYSST1_CALIB_BUS_RESULT_3					0x01EB
+#define TX_SYSST1_CALIB_BUS_RESULT_4					0x01EC
+#define TX_SYSST1_CALIB_BUS_RESULT_5					0x01ED
+#define TX_SYSST1_CALIB_BUS_RESULT_6					0x01EE
+#define TX_SYSST1_CALIB_BUS_RESULT_7					0x01EF
+
+// Packet status
+#define TX_PACKET_ST_REQUEST_STATUS_1					0x01F0
+#define TX_PACKET_ST_REQUEST_STATUS_2					0x01F1
+#define TX_PACKET_ST_REQUEST_MISSED_1					0x01F2
+#define TX_PACKET_ST_REQUEST_MISSED_2					0x01F3
+#define TX_PACKET_ST_ENCODE_STATUS_0					0x01F4
+#define TX_PACKET_ST_ENCODE_STATUS_1					0x01F5
+#define TX_PACKET_ST_ENCODE_STATUS_2					0x01F6
+#define TX_PACKET_ST_TIMER_STATUS					0x01F7
+
+// tmds status
+#define TX_TMDS_ST_CLOCK_METER_1					0x01F8
+#define TX_TMDS_ST_CLOCK_METER_2					0x01F9
+#define TX_TMDS_ST_CLOCK_METER_3					0x01FA
+#define TX_TMDS_ST_TMDS_STATUS_1					0x01FC
+#define TX_TMDS_ST_TMDS_STATUS_2					0x01FD
+#define TX_TMDS_ST_TMDS_STATUS_3					0x01FE
+#define TX_TMDS_ST_TMDS_STATUS_4					0x01FF
+
+// Packet register
+#define TX_PKT_REG_SPD_INFO_BASE_ADDR					0x0200
+#define TX_PKT_REG_VEND_INFO_BASE_ADDR					0x0220
+#define TX_PKT_REG_MPEG_INFO_BASE_ADDR					0x0240
+#define TX_PKT_REG_AVI_INFO_BASE_ADDR					0x0260
+#define TX_PKT_REG_AUDIO_INFO_BASE_ADDR					0x0280
+#define TX_PKT_REG_ACP_INFO_BASE_ADDR					0x02A0
+#define TX_PKT_REG_ISRC1_BASE_ADDR					0x02C0
+#define TX_PKT_REG_ISRC2_BASE_ADDR					0x02E0
+#define TX_PKT_REG_EXCEPT0_BASE_ADDR					0x0300
+#define TX_PKT_REG_EXCEPT1_BASE_ADDR					0x0320
+#define TX_PKT_REG_EXCEPT2_BASE_ADDR					0x0340
+#define TX_PKT_REG_EXCEPT3_BASE_ADDR					0x0360
+#define TX_PKT_REG_EXCEPT4_BASE_ADDR					0x0380
+#define TX_PKT_REG_GAMUT_P0_BASE_ADDR					0x03A0
+#define TX_PKT_REG_GAMUT_P1_1_BASE_ADDR					0x03C0
+#define TX_PKT_REG_GAMUT_P1_2_BASE_ADDR					0x03E0
+
+#define TX_RX_EDID_OFFSET						0x0600
+
+/* HDMI OTHER registers */
+
+#define HDMI_OTHER_CTRL0						0x8000
+#define HDMI_OTHER_CTRL1						0x8001
+	#define HDMI_OTHER_CTRL1_POWER_ON				BIT(15)
+	#define HDMI_OTHER_CTRL1_HDMI_AUDIO_CLOCK_ON			BIT(13)
+
+#define HDMI_OTHER_STATUS0						0x8002
+#define HDMI_OTHER_CTRL2						0x8003
+#define HDMI_OTHER_INTR_MASKN						0x8004
+	#define HDMI_OTHER_INTR_MASKN_TX_EDID_INT_RISE			BIT(2)
+	#define HDMI_OTHER_INTR_MASKN_TX_HPD_INT_FALL			BIT(1)
+	#define HDMI_OTHER_INTR_MASKN_TX_HPD_INT_RISE			BIT(0)
+
+#define HDMI_OTHER_INTR_STAT						0x8005
+	#define HDMI_OTHER_INTR_STAT_EDID_RISING			BIT(2)
+	#define HDMI_OTHER_INTR_STAT_HPD_FALLING			BIT(1)
+	#define HDMI_OTHER_INTR_STAT_HPD_RISING				BIT(0)
+
+#define HDMI_OTHER_INTR_STAT_CLR					0x8006
+	#define HDMI_OTHER_INTR_STAT_CLR_EDID_RISING			BIT(2)
+	#define HDMI_OTHER_INTR_STAT_CLR_HPD_FALLING			BIT(1)
+	#define HDMI_OTHER_INTR_STAT_CLR_HPD_RISING			BIT(0)
+
+#define HDMI_OTHER_AVI_INTR_MASKN0					0x8008
+#define HDMI_OTHER_AVI_INTR_MASKN1					0x8009
+#define HDMI_OTHER_RX_AINFO_INTR_MASKN0					0x800a
+#define HDMI_OTHER_RX_AINFO_INTR_MASKN1					0x800b
+#define HDMI_OTHER_RX_PACKET_INTR_CLR					0x800c
+
+#endif /* __MESON_TRANSWITCH_HDMI_H__ */
diff --git a/drivers/gpu/drm/meson/meson_vclk.c b/drivers/gpu/drm/meson/meson_vclk.c
index 2a82119eb58e..a2c1bf1aed77 100644
--- a/drivers/gpu/drm/meson/meson_vclk.c
+++ b/drivers/gpu/drm/meson/meson_vclk.c
@@ -732,6 +732,11 @@ meson_vclk_dmt_supported_freq(struct meson_drm *priv, unsigned int freq)
 			return MODE_CLOCK_HIGH;
 	}
 
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2))
+		return MODE_OK;
+
 	if (meson_hdmi_pll_find_params(priv, freq, &m, &frac, &od))
 		return MODE_OK;
 
@@ -784,6 +789,11 @@ meson_vclk_vic_supported_freq(struct meson_drm *priv, unsigned int phy_freq,
 			return MODE_CLOCK_HIGH;
 	}
 
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2))
+		return MODE_OK;
+
 	for (i = 0 ; params[i].pixel_freq ; ++i) {
 		DRM_DEBUG_DRIVER("i = %d pixel_freq = %d alt = %d\n",
 				 i, params[i].pixel_freq,
@@ -1024,6 +1034,128 @@ static void meson_vclk_set(struct meson_drm *priv, unsigned int pll_base_freq,
 	regmap_update_bits(priv->hhi, HHI_VID_CLK_CNTL, VCLK_EN, VCLK_EN);
 }
 
+static int meson_vclk_set_rate_exclusive(struct meson_drm *priv,
+					 enum vpu_bulk_clk_id clk_id,
+					 unsigned int rate_khz)
+{
+	struct clk *clk = priv->vid_clks[clk_id].clk;
+	int ret;
+
+	ret = clk_set_rate_exclusive(clk, rate_khz * 1000UL);
+	if (ret)
+		return ret;
+
+	priv->vid_clk_rate_exclusive[clk_id] = true;
+
+	return 0;
+}
+
+static void meson_vclk_disable_ccf(struct meson_drm *priv)
+{
+	unsigned int i;
+
+	/* allow all clocks to be changed in _enable again */
+	for (i = 0; i < VPU_VID_CLK_NUM; i++) {
+		if (!priv->vid_clk_rate_exclusive[i])
+			continue;
+
+		clk_rate_exclusive_put(priv->vid_clks[i].clk);
+		priv->vid_clk_rate_exclusive[i] = false;
+	}
+
+	if (priv->clk_dac_enabled) {
+		clk_disable(priv->clk_dac);
+		priv->clk_dac_enabled = false;
+	}
+
+	if (priv->clk_venc_enabled) {
+		clk_disable(priv->clk_venc);
+		priv->clk_venc_enabled = false;
+	}
+}
+
+static int meson_vclk_enable_ccf(struct meson_drm *priv, unsigned int target,
+				 bool hdmi_use_enci, unsigned int phy_freq,
+				 unsigned int dac_freq, unsigned int venc_freq)
+{
+	enum vpu_bulk_clk_id venc_clk_id, dac_clk_id;
+	int ret;
+
+	if (target == MESON_VCLK_TARGET_CVBS || hdmi_use_enci)
+		venc_clk_id = VPU_VID_CLK_CTS_ENCI;
+	else
+		venc_clk_id = VPU_VID_CLK_CTS_ENCP;
+
+	if (target == MESON_VCLK_TARGET_CVBS)
+		dac_clk_id = VPU_VID_CLK_CTS_VDAC0;
+	else
+		dac_clk_id = VPU_VID_CLK_HDMI_TX_PIXEL;
+
+	/*
+	 * The TMDS clock also updates the PLL. Protect the PLL rate so all
+	 * following clocks are derived from the PLL setting which matches the
+	 * TMDS clock.
+	 */
+	ret = meson_vclk_set_rate_exclusive(priv, VPU_VID_CLK_TMDS, phy_freq);
+	if (ret) {
+		dev_err(priv->dev, "Failed to set TMDS clock to %ukHz: %d\n",
+			phy_freq, ret);
+		goto out_enable_clocks;
+	}
+
+	/*
+	 * The DAC clock may be derived from a parent of the VENC clock so we
+	 * must protect the VENC clock from changing it's rate. This works
+	 * because the DAC freq can be divided by the VENC clock.
+	 */
+	ret = meson_vclk_set_rate_exclusive(priv, venc_clk_id, venc_freq);
+	if (ret) {
+		dev_warn(priv->dev,
+			 "Failed to set VENC clock to %ukHz while TMDS clock is %ukHz: %d\n",
+			 venc_freq, phy_freq, ret);
+		goto out_enable_clocks;
+	}
+
+	priv->clk_venc = priv->vid_clks[venc_clk_id].clk;
+
+	/*
+	 * after changing any of the VID_PLL_* clocks (which can happen when
+	 * update the VENC clock rate) we need to assert and then de-assert the
+	 * VID_DIVIDER_CNTL_* reset lines.
+	 */
+	reset_control_bulk_assert(VPU_RESET_VID_PLL_NUM, priv->vid_pll_resets);
+	reset_control_bulk_deassert(VPU_RESET_VID_PLL_NUM, priv->vid_pll_resets);
+
+	ret = meson_vclk_set_rate_exclusive(priv, dac_clk_id, dac_freq);
+	if (ret) {
+		dev_warn(priv->dev,
+			 "Failed to set pixel clock to %ukHz while TMDS clock is %ukHz: %d\n",
+			 dac_freq, phy_freq, ret);
+		goto out_enable_clocks;
+	}
+
+	priv->clk_dac = priv->vid_clks[dac_clk_id].clk;
+
+out_enable_clocks:
+	ret = clk_enable(priv->clk_venc);
+	if (ret)
+		dev_err(priv->dev,
+			"Failed to re-enable the VENC clock at %ukHz: %d\n",
+			venc_freq, ret);
+	else
+		priv->clk_venc_enabled = true;
+
+	ret = clk_enable(priv->clk_dac);
+	if (ret)
+		dev_err(priv->dev,
+			"Failed to re-enable the pixel clock at %ukHz: %d\n",
+			dac_freq, ret);
+	else
+		priv->clk_dac_enabled = true;
+
+	return ret;
+}
+
 void meson_vclk_setup(struct meson_drm *priv, unsigned int target,
 		      unsigned int phy_freq, unsigned int vclk_freq,
 		      unsigned int venc_freq, unsigned int dac_freq,
@@ -1034,6 +1166,20 @@ void meson_vclk_setup(struct meson_drm *priv, unsigned int target,
 	unsigned int hdmi_tx_div;
 	unsigned int venc_div;
 
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2)) {
+		/* CVBS video clocks are generated off a 1296MHz base clock */
+		if (target == MESON_VCLK_TARGET_CVBS)
+			phy_freq = 1296000;
+
+		dev_err(priv->dev, "%s(target: %u, phy: %u, dac: %u, venc: %u, hdmi_use_enci: %u)\n", __func__, target, phy_freq, dac_freq, venc_freq, hdmi_use_enci);
+		meson_vclk_disable_ccf(priv);
+		meson_vclk_enable_ccf(priv, target, hdmi_use_enci, phy_freq,
+				      dac_freq, venc_freq);
+		return;
+	}
+
 	if (target == MESON_VCLK_TARGET_CVBS) {
 		meson_venci_cvbs_clock_config(priv);
 		return;
diff --git a/drivers/gpu/drm/meson/meson_venc.c b/drivers/gpu/drm/meson/meson_venc.c
index 3c55ed003359..009882bda7b9 100644
--- a/drivers/gpu/drm/meson/meson_venc.c
+++ b/drivers/gpu/drm/meson/meson_venc.c
@@ -60,10 +60,6 @@
 
 /* HHI Registers */
 #define HHI_GCLK_MPEG2		0x148 /* 0x52 offset in data sheet */
-#define HHI_VDAC_CNTL0		0x2F4 /* 0xbd offset in data sheet */
-#define HHI_VDAC_CNTL0_G12A	0x2EC /* 0xbb offset in data sheet */
-#define HHI_VDAC_CNTL1		0x2F8 /* 0xbe offset in data sheet */
-#define HHI_VDAC_CNTL1_G12A	0x2F0 /* 0xbc offset in data sheet */
 #define HHI_HDMI_PHY_CNTL0	0x3a0 /* 0xe8 offset in data sheet */
 
 struct meson_cvbs_enci_mode meson_cvbs_enci_pal = {
@@ -1749,31 +1745,47 @@ void meson_venc_enable_vsync(struct meson_drm *priv)
 {
 	writel_relaxed(VENC_INTCTRL_ENCI_LNRST_INT_EN,
 		       priv->io_base + _REG(VENC_INTCTRL));
-	regmap_update_bits(priv->hhi, HHI_GCLK_MPEG2, BIT(25), BIT(25));
+
+	if (priv->intr_clks[0].clk) {
+		if (!priv->intr_clks_enabled) {
+			int ret;
+
+			ret = clk_bulk_enable(priv->num_intr_clks,
+					      priv->intr_clks);
+			if (ret)
+				dev_err(priv->dev,
+					"Failed to enable the interrupt clocks\n");
+			else
+				priv->intr_clks_enabled = true;
+		}
+	} else {
+		regmap_update_bits(priv->hhi, HHI_GCLK_MPEG2, BIT(25), BIT(25));
+	}
 }
 
 void meson_venc_disable_vsync(struct meson_drm *priv)
 {
-	regmap_update_bits(priv->hhi, HHI_GCLK_MPEG2, BIT(25), 0);
+	if (priv->intr_clks[0].clk) {
+		if (priv->intr_clks_enabled) {
+			clk_bulk_disable(priv->num_intr_clks,
+					 priv->intr_clks);
+			priv->intr_clks_enabled = false;
+		}
+	} else {
+		regmap_update_bits(priv->hhi, HHI_GCLK_MPEG2, BIT(25), 0);
+	}
+
 	writel_relaxed(0, priv->io_base + _REG(VENC_INTCTRL));
 }
 
 void meson_venc_init(struct meson_drm *priv)
 {
-	/* Disable CVBS VDAC */
-	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
-		regmap_write(priv->hhi, HHI_VDAC_CNTL0_G12A, 0);
-		regmap_write(priv->hhi, HHI_VDAC_CNTL1_G12A, 8);
-	} else {
-		regmap_write(priv->hhi, HHI_VDAC_CNTL0, 0);
-		regmap_write(priv->hhi, HHI_VDAC_CNTL1, 8);
-	}
-
 	/* Power Down Dacs */
 	writel_relaxed(0xff, priv->io_base + _REG(VENC_VDAC_SETTING));
 
 	/* Disable HDMI PHY */
-	regmap_write(priv->hhi, HHI_HDMI_PHY_CNTL0, 0);
+	if (priv->hhi)
+		regmap_write(priv->hhi, HHI_HDMI_PHY_CNTL0, 0);
 
 	/* Disable HDMI */
 	writel_bits_relaxed(VPU_HDMI_ENCI_DATA_TO_HDMI |
diff --git a/drivers/gpu/drm/meson/meson_viu.c b/drivers/gpu/drm/meson/meson_viu.c
index cd399b0b7181..464b777834a2 100644
--- a/drivers/gpu/drm/meson/meson_viu.c
+++ b/drivers/gpu/drm/meson/meson_viu.c
@@ -436,9 +436,22 @@ void meson_viu_init(struct meson_drm *priv)
 
 	/* Initialize OSD1 fifo control register */
 	reg = VIU_OSD_DDR_PRIORITY_URGENT |
-		VIU_OSD_FIFO_DEPTH_VAL(32) | /* fifo_depth_val: 32*8=256 */
-		VIU_OSD_WORDS_PER_BURST(4) | /* 4 words in 1 burst */
-		VIU_OSD_FIFO_LIMITS(2);      /* fifo_lim: 2*16=32 */
+	      VIU_OSD_FIFO_DEPTH_VAL(32) | /* fifo_depth_val: 32*8=256 */
+	      VIU_OSD_WORDS_PER_BURST(4) | /* 4 words in 1 burst */
+	      VIU_OSD_FIFO_LIMITS(2);      /* fifo_lim: 2*16=32 */
+
+	/*
+	 * When using AFBC on newer SoCs the AFBC encoder has to be reset. To
+	 * leave time for that we need hold more lines to avoid glitches.
+	 * On the 32-bit SoCs however we need to hold fewer lines because
+	 * otherwise screen tearing can occur (for example in kmscube).
+	 */
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2))
+		reg |= VIU_OSD_HOLD_FIFO_LINES(12);
+	else
+		reg |= VIU_OSD_HOLD_FIFO_LINES(31);
 
 	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A))
 		reg |= (VIU_OSD_BURST_LENGTH_32 | VIU_OSD_HOLD_FIFO_LINES(31));
@@ -448,13 +461,17 @@ void meson_viu_init(struct meson_drm *priv)
 	writel_relaxed(reg, priv->io_base + _REG(VIU_OSD1_FIFO_CTRL_STAT));
 	writel_relaxed(reg, priv->io_base + _REG(VIU_OSD2_FIFO_CTRL_STAT));
 
-	/* Set OSD alpha replace value */
-	writel_bits_relaxed(0xff << OSD_REPLACE_SHIFT,
-			    0xff << OSD_REPLACE_SHIFT,
-			    priv->io_base + _REG(VIU_OSD1_CTRL_STAT2));
-	writel_bits_relaxed(0xff << OSD_REPLACE_SHIFT,
-			    0xff << OSD_REPLACE_SHIFT,
-			    priv->io_base + _REG(VIU_OSD2_CTRL_STAT2));
+	if (!meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) &&
+	    !meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) &&
+	    !meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2)) {
+		/* Set OSD alpha replace value */
+		writel_bits_relaxed(0xff << OSD_REPLACE_SHIFT,
+				    0xff << OSD_REPLACE_SHIFT,
+				    priv->io_base + _REG(VIU_OSD1_CTRL_STAT2));
+		writel_bits_relaxed(0xff << OSD_REPLACE_SHIFT,
+				    0xff << OSD_REPLACE_SHIFT,
+				    priv->io_base + _REG(VIU_OSD2_CTRL_STAT2));
+	}
 
 	/* Disable VD1 AFBC */
 	/* di_mif0_en=0 mif0_to_vpp_en=0 di_mad_en=0 and afbc vd1 set=0*/
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 5e19a961c34d..845a1e5c8871 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -443,6 +443,7 @@ config MMC_MESON_GX
 	tristate "Amlogic S905/GX*/AXG SD/MMC Host Controller support"
 	depends on ARCH_MESON|| COMPILE_TEST
 	depends on COMMON_CLK
+	select REGMAP_MMIO
 	help
 	  This selects support for the Amlogic SD/MMC Host Controller
 	  found on the S905/GX*/AXG family of SoCs.  This controller is
@@ -469,6 +470,7 @@ config MMC_MESON_MX_SDIO
 	depends on ARCH_MESON || COMPILE_TEST
 	depends on COMMON_CLK
 	depends on OF_ADDRESS
+	select REGMAP_MMIO
 	help
 	  This selects support for the SD/MMC Host Controller on
 	  Amlogic Meson6, Meson8 and Meson8b SoCs.
diff --git a/drivers/mmc/host/meson-gx-mmc.c b/drivers/mmc/host/meson-gx-mmc.c
index 0f39f86bd0c2..ec678b3785a3 100644
--- a/drivers/mmc/host/meson-gx-mmc.c
+++ b/drivers/mmc/host/meson-gx-mmc.c
@@ -22,6 +22,7 @@
 #include <linux/io.h>
 #include <linux/clk.h>
 #include <linux/clk-provider.h>
+#include <linux/regmap.h>
 #include <linux/regulator/consumer.h>
 #include <linux/reset.h>
 #include <linux/interrupt.h>
@@ -154,7 +155,8 @@ struct meson_host {
 	struct	mmc_host	*mmc;
 	struct	mmc_command	*cmd;
 
-	void __iomem *regs;
+	struct regmap *regmap;
+
 	struct clk *core_clk;
 	struct clk *mux_clk;
 	struct clk *mmc_clk;
@@ -168,7 +170,6 @@ struct meson_host {
 
 	unsigned int bounce_buf_size;
 	void *bounce_buf;
-	void __iomem *bounce_iomem_buf;
 	dma_addr_t bounce_dma_addr;
 	struct sd_emmc_desc *descs;
 	dma_addr_t descs_dma_addr;
@@ -324,8 +325,6 @@ static void meson_mmc_post_req(struct mmc_host *mmc, struct mmc_request *mrq,
  */
 static void meson_mmc_clk_gate(struct meson_host *host)
 {
-	u32 cfg;
-
 	if (host->pins_clk_gate) {
 		pinctrl_select_state(host->pinctrl, host->pins_clk_gate);
 	} else {
@@ -333,23 +332,18 @@ static void meson_mmc_clk_gate(struct meson_host *host)
 		 * If the pinmux is not provided - default to the classic and
 		 * unsafe method
 		 */
-		cfg = readl(host->regs + SD_EMMC_CFG);
-		cfg |= CFG_STOP_CLOCK;
-		writel(cfg, host->regs + SD_EMMC_CFG);
+		regmap_update_bits(host->regmap, SD_EMMC_CFG, CFG_STOP_CLOCK,
+				   CFG_STOP_CLOCK);
 	}
 }
 
 static void meson_mmc_clk_ungate(struct meson_host *host)
 {
-	u32 cfg;
-
 	if (host->pins_clk_gate)
 		pinctrl_select_default_state(host->dev);
 
 	/* Make sure the clock is not stopped in the controller */
-	cfg = readl(host->regs + SD_EMMC_CFG);
-	cfg &= ~CFG_STOP_CLOCK;
-	writel(cfg, host->regs + SD_EMMC_CFG);
+	regmap_update_bits(host->regmap, SD_EMMC_CFG, CFG_STOP_CLOCK, 0);
 }
 
 static int meson_mmc_clk_set(struct meson_host *host, unsigned long rate,
@@ -357,7 +351,6 @@ static int meson_mmc_clk_set(struct meson_host *host, unsigned long rate,
 {
 	struct mmc_host *mmc = host->mmc;
 	int ret;
-	u32 cfg;
 
 	/* Same request - bail-out */
 	if (host->ddr == ddr && host->req_rate == rate)
@@ -373,18 +366,16 @@ static int meson_mmc_clk_set(struct meson_host *host, unsigned long rate,
 		return 0;
 
 	/* Stop the clock during rate change to avoid glitches */
-	cfg = readl(host->regs + SD_EMMC_CFG);
-	cfg |= CFG_STOP_CLOCK;
-	writel(cfg, host->regs + SD_EMMC_CFG);
+	regmap_update_bits(host->regmap, SD_EMMC_CFG, CFG_STOP_CLOCK,
+			   CFG_STOP_CLOCK);
 
 	if (ddr) {
 		/* DDR modes require higher module clock */
 		rate <<= 1;
-		cfg |= CFG_DDR;
+		regmap_update_bits(host->regmap, SD_EMMC_CFG, CFG_DDR, CFG_DDR);
 	} else {
-		cfg &= ~CFG_DDR;
+		regmap_update_bits(host->regmap, SD_EMMC_CFG, CFG_DDR, 0);
 	}
-	writel(cfg, host->regs + SD_EMMC_CFG);
 	host->ddr = ddr;
 
 	ret = clk_set_rate(host->mmc_clk, rate);
@@ -418,7 +409,7 @@ static int meson_mmc_clk_set(struct meson_host *host, unsigned long rate,
  * generating the MMC clock.  Use the clock framework to create and
  * manage these clocks.
  */
-static int meson_mmc_clk_init(struct meson_host *host)
+static int meson_mmc_clk_init(struct meson_host *host, void __iomem *regs)
 {
 	struct clk_init_data init;
 	struct clk_mux *mux;
@@ -437,7 +428,7 @@ static int meson_mmc_clk_init(struct meson_host *host)
 	clk_reg |= FIELD_PREP(CLK_RX_PHASE_MASK, CLK_PHASE_0);
 	if (host->mmc->caps & MMC_CAP_SDIO_IRQ)
 		clk_reg |= CLK_IRQ_SDIO_SLEEP(host);
-	writel(clk_reg, host->regs + SD_EMMC_CLOCK);
+	regmap_write(host->regmap, SD_EMMC_CLOCK, clk_reg);
 
 	/* get the mux parents */
 	for (i = 0; i < MUX_CLK_NUM_PARENTS; i++) {
@@ -465,7 +456,7 @@ static int meson_mmc_clk_init(struct meson_host *host)
 	init.parent_names = mux_parent_names;
 	init.num_parents = MUX_CLK_NUM_PARENTS;
 
-	mux->reg = host->regs + SD_EMMC_CLOCK;
+	mux->reg = regs + SD_EMMC_CLOCK;
 	mux->shift = __ffs(CLK_SRC_MASK);
 	mux->mask = CLK_SRC_MASK >> mux->shift;
 	mux->hw.init = &init;
@@ -487,7 +478,7 @@ static int meson_mmc_clk_init(struct meson_host *host)
 	init.parent_names = clk_parent;
 	init.num_parents = 1;
 
-	div->reg = host->regs + SD_EMMC_CLOCK;
+	div->reg = regs + SD_EMMC_CLOCK;
 	div->shift = __ffs(CLK_DIV_MASK);
 	div->width = __builtin_popcountl(CLK_DIV_MASK);
 	div->hw.init = &init;
@@ -508,21 +499,15 @@ static int meson_mmc_clk_init(struct meson_host *host)
 
 static void meson_mmc_disable_resampling(struct meson_host *host)
 {
-	unsigned int val = readl(host->regs + host->data->adjust);
-
-	val &= ~ADJUST_ADJ_EN;
-	writel(val, host->regs + host->data->adjust);
+	regmap_update_bits(host->regmap, host->data->adjust, ADJUST_ADJ_EN, 0);
 }
 
 static void meson_mmc_reset_resampling(struct meson_host *host)
 {
-	unsigned int val;
-
 	meson_mmc_disable_resampling(host);
 
-	val = readl(host->regs + host->data->adjust);
-	val &= ~ADJUST_ADJ_DELAY_MASK;
-	writel(val, host->regs + host->data->adjust);
+	regmap_update_bits(host->regmap, host->data->adjust, ADJUST_ADJ_DELAY_MASK,
+			   0);
 }
 
 static int meson_mmc_resampling_tuning(struct mmc_host *mmc, u32 opcode)
@@ -535,19 +520,21 @@ static int meson_mmc_resampling_tuning(struct mmc_host *mmc, u32 opcode)
 	max_dly = DIV_ROUND_UP(clk_get_rate(host->mux_clk),
 			       clk_get_rate(host->mmc_clk));
 
-	val = readl(host->regs + host->data->adjust);
-	val |= ADJUST_ADJ_EN;
-	writel(val, host->regs + host->data->adjust);
+	regmap_update_bits(host->regmap, host->data->adjust, ADJUST_ADJ_EN,
+			   ADJUST_ADJ_EN);
 
-	if (mmc_doing_retune(mmc))
+	if (mmc_doing_retune(mmc)) {
+		regmap_read(host->regmap, host->data->adjust, &val);
 		dly = FIELD_GET(ADJUST_ADJ_DELAY_MASK, val) + 1;
-	else
+	} else {
 		dly = 0;
+	}
 
 	for (i = 0; i < max_dly; i++) {
-		val &= ~ADJUST_ADJ_DELAY_MASK;
-		val |= FIELD_PREP(ADJUST_ADJ_DELAY_MASK, (dly + i) % max_dly);
-		writel(val, host->regs + host->data->adjust);
+		regmap_update_bits(host->regmap, host->data->adjust,
+				   ADJUST_ADJ_DELAY_MASK,
+				   FIELD_PREP(ADJUST_ADJ_DELAY_MASK,
+					      (dly + i) % max_dly));
 
 		ret = mmc_send_tuning(mmc, opcode, NULL);
 		if (!ret) {
@@ -652,10 +639,8 @@ static void meson_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 		bus_width = CFG_BUS_WIDTH_4;
 	}
 
-	val = readl(host->regs + SD_EMMC_CFG);
-	val &= ~CFG_BUS_WIDTH_MASK;
-	val |= FIELD_PREP(CFG_BUS_WIDTH_MASK, bus_width);
-	writel(val, host->regs + SD_EMMC_CFG);
+	regmap_update_bits(host->regmap, SD_EMMC_CFG, CFG_BUS_WIDTH_MASK,
+			   FIELD_PREP(CFG_BUS_WIDTH_MASK, bus_width));
 
 	meson_mmc_check_resampling(host, ios);
 	err = meson_mmc_prepare_ios_clock(host, ios);
@@ -681,7 +666,7 @@ static void meson_mmc_set_blksz(struct mmc_host *mmc, unsigned int blksz)
 	struct meson_host *host = mmc_priv(mmc);
 	u32 cfg, blksz_old;
 
-	cfg = readl(host->regs + SD_EMMC_CFG);
+	regmap_read(host->regmap, SD_EMMC_CFG, &cfg);
 	blksz_old = FIELD_GET(CFG_BLK_LEN_MASK, cfg);
 
 	if (!is_power_of_2(blksz))
@@ -696,9 +681,8 @@ static void meson_mmc_set_blksz(struct mmc_host *mmc, unsigned int blksz)
 	dev_dbg(host->dev, "%s: update blk_len %d -> %d\n", __func__,
 		blksz_old, blksz);
 
-	cfg &= ~CFG_BLK_LEN_MASK;
-	cfg |= FIELD_PREP(CFG_BLK_LEN_MASK, blksz);
-	writel(cfg, host->regs + SD_EMMC_CFG);
+	regmap_update_bits(host->regmap, SD_EMMC_CFG, CFG_BLK_LEN_MASK,
+			   FIELD_PREP(CFG_BLK_LEN_MASK, blksz));
 }
 
 static void meson_mmc_set_response_bits(struct mmc_command *cmd, u32 *cmd_cfg)
@@ -724,7 +708,6 @@ static void meson_mmc_desc_chain_transfer(struct mmc_host *mmc, u32 cmd_cfg)
 	struct sd_emmc_desc *desc = host->descs;
 	struct mmc_data *data = host->cmd->data;
 	struct scatterlist *sg;
-	u32 start;
 	int i;
 
 	if (data->flags & MMC_DATA_WRITE)
@@ -752,8 +735,8 @@ static void meson_mmc_desc_chain_transfer(struct mmc_host *mmc, u32 cmd_cfg)
 	desc[data->sg_count - 1].cmd_cfg |= CMD_CFG_END_OF_CHAIN;
 
 	dma_wmb(); /* ensure descriptor is written before kicked */
-	start = host->descs_dma_addr | START_DESC_BUSY;
-	writel(start, host->regs + SD_EMMC_START);
+	regmap_write(host->regmap, SD_EMMC_START,
+		     host->descs_dma_addr | START_DESC_BUSY);
 }
 
 /* local sg copy for dram_access_quirk */
@@ -774,28 +757,19 @@ static void meson_mmc_copy_buffer(struct meson_host *host, struct mmc_data *data
 	sg_miter_start(&miter, sgl, nents, sg_flags);
 
 	while ((offset < buflen) && sg_miter_next(&miter)) {
-		unsigned int buf_offset = 0;
-		unsigned int len, left;
 		u32 *buf = miter.addr;
+		unsigned int len;
 
-		len = min(miter.length, buflen - offset);
-		left = len;
+		len = min(miter.length, buflen - offset) / sizeof(u32);
 
-		if (to_buffer) {
-			do {
-				writel(*buf++, host->bounce_iomem_buf + offset + buf_offset);
-
-				buf_offset += 4;
-				left -= 4;
-			} while (left);
-		} else {
-			do {
-				*buf++ = readl(host->bounce_iomem_buf + offset + buf_offset);
-
-				buf_offset += 4;
-				left -= 4;
-			} while (left);
-		}
+		if (to_buffer)
+			regmap_bulk_write(host->regmap,
+					  SD_EMMC_SRAM_DATA_BUF_OFF + offset,
+					  buf, len);
+		else
+			regmap_bulk_read(host->regmap,
+					 SD_EMMC_SRAM_DATA_BUF_OFF + offset,
+					 buf, len);
 
 		offset += len;
 	}
@@ -862,11 +836,11 @@ static void meson_mmc_start_cmd(struct mmc_host *mmc, struct mmc_command *cmd)
 
 	/* Last descriptor */
 	cmd_cfg |= CMD_CFG_END_OF_CHAIN;
-	writel(cmd_cfg, host->regs + SD_EMMC_CMD_CFG);
-	writel(cmd_data, host->regs + SD_EMMC_CMD_DAT);
-	writel(0, host->regs + SD_EMMC_CMD_RSP);
+	regmap_write(host->regmap, SD_EMMC_CMD_CFG, cmd_cfg);
+	regmap_write(host->regmap, SD_EMMC_CMD_DAT, cmd_data);
+	regmap_write(host->regmap, SD_EMMC_CMD_RSP, 0);
 	wmb(); /* ensure descriptor is written before kicked */
-	writel(cmd->arg, host->regs + SD_EMMC_CMD_ARG);
+	regmap_write(host->regmap, SD_EMMC_CMD_ARG, cmd->arg);
 }
 
 static int meson_mmc_validate_dram_access(struct mmc_host *mmc, struct mmc_data *data)
@@ -916,7 +890,7 @@ static void meson_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
 		meson_mmc_pre_req(mmc, mrq);
 
 	/* Stop execution */
-	writel(0, host->regs + SD_EMMC_START);
+	regmap_write(host->regmap, SD_EMMC_START, 0);
 
 	meson_mmc_start_cmd(mmc, mrq->sbc ?: mrq->cmd);
 }
@@ -926,12 +900,12 @@ static void meson_mmc_read_resp(struct mmc_host *mmc, struct mmc_command *cmd)
 	struct meson_host *host = mmc_priv(mmc);
 
 	if (cmd->flags & MMC_RSP_136) {
-		cmd->resp[0] = readl(host->regs + SD_EMMC_CMD_RSP3);
-		cmd->resp[1] = readl(host->regs + SD_EMMC_CMD_RSP2);
-		cmd->resp[2] = readl(host->regs + SD_EMMC_CMD_RSP1);
-		cmd->resp[3] = readl(host->regs + SD_EMMC_CMD_RSP);
+		regmap_read(host->regmap, SD_EMMC_CMD_RSP3, &cmd->resp[0]);
+		regmap_read(host->regmap, SD_EMMC_CMD_RSP2, &cmd->resp[1]);
+		regmap_read(host->regmap, SD_EMMC_CMD_RSP1, &cmd->resp[2]);
+		regmap_read(host->regmap, SD_EMMC_CMD_RSP, &cmd->resp[3]);
 	} else if (cmd->flags & MMC_RSP_PRESENT) {
-		cmd->resp[0] = readl(host->regs + SD_EMMC_CMD_RSP);
+		regmap_read(host->regmap, SD_EMMC_CMD_RSP, &cmd->resp[0]);
 	}
 }
 
@@ -942,7 +916,7 @@ static void __meson_mmc_enable_sdio_irq(struct mmc_host *mmc, int enable)
 
 	if (enable)
 		reg_irqen |= IRQ_SDIO;
-	writel(reg_irqen, host->regs + SD_EMMC_IRQ_EN);
+	regmap_write(host->regmap, SD_EMMC_IRQ_EN, reg_irqen);
 }
 
 static irqreturn_t meson_mmc_irq(int irq, void *dev_id)
@@ -954,7 +928,7 @@ static irqreturn_t meson_mmc_irq(int irq, void *dev_id)
 
 	if (host->mmc->caps & MMC_CAP_SDIO_IRQ)
 		irq_mask |= IRQ_SDIO;
-	raw_status = readl(host->regs + SD_EMMC_STATUS);
+	regmap_read(host->regmap, SD_EMMC_STATUS, &raw_status);
 	status = raw_status & irq_mask;
 
 	if (!status) {
@@ -968,7 +942,7 @@ static irqreturn_t meson_mmc_irq(int irq, void *dev_id)
 		return IRQ_NONE;
 
 	/* ack all raised interrupts */
-	writel(status, host->regs + SD_EMMC_STATUS);
+	regmap_write(host->regmap, SD_EMMC_STATUS, status);
 
 	cmd = host->cmd;
 
@@ -1012,13 +986,10 @@ static irqreturn_t meson_mmc_irq(int irq, void *dev_id)
 	}
 
 out:
-	if (cmd->error) {
+	if (cmd->error)
 		/* Stop desc in case of errors */
-		u32 start = readl(host->regs + SD_EMMC_START);
-
-		start &= ~START_DESC_BUSY;
-		writel(start, host->regs + SD_EMMC_START);
-	}
+		regmap_update_bits(host->regmap, SD_EMMC_START,
+				   START_DESC_BUSY, 0);
 
 	return ret;
 }
@@ -1035,9 +1006,9 @@ static int meson_mmc_wait_desc_stop(struct meson_host *host)
 	 * IRQs after we have called mmc_request_done() which is bad.
 	 */
 
-	return readl_poll_timeout(host->regs + SD_EMMC_STATUS, status,
-				  !(status & (STATUS_BUSY | STATUS_DESC_BUSY)),
-				  100, 5000);
+	return regmap_read_poll_timeout(host->regmap, SD_EMMC_STATUS, status,
+					!(status & (STATUS_BUSY | STATUS_DESC_BUSY)),
+					100, 5000);
 }
 
 static irqreturn_t meson_mmc_irq_thread(int irq, void *dev_id)
@@ -1103,7 +1074,7 @@ static void meson_mmc_cfg_init(struct meson_host *host)
 	/* abort chain on R/W errors */
 	cfg |= CFG_ERR_ABORT;
 
-	writel(cfg, host->regs + SD_EMMC_CFG);
+	regmap_write(host->regmap, SD_EMMC_CFG, cfg);
 }
 
 static int meson_mmc_card_busy(struct mmc_host *mmc)
@@ -1111,7 +1082,7 @@ static int meson_mmc_card_busy(struct mmc_host *mmc)
 	struct meson_host *host = mmc_priv(mmc);
 	u32 regval;
 
-	regval = readl(host->regs + SD_EMMC_STATUS);
+	regmap_read(host->regmap, SD_EMMC_STATUS, &regval);
 
 	/* We are only interrested in lines 0 to 3, so mask the other ones */
 	return !(FIELD_GET(STATUS_DATI, regval) & 0xf);
@@ -1169,11 +1140,19 @@ static const struct mmc_host_ops meson_mmc_ops = {
 	.ack_sdio_irq	= meson_mmc_ack_sdio_irq,
 };
 
+static const struct regmap_config meson_gx_mmc_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 32,
+	.reg_stride = 4,
+	.max_register = 0x7ff,
+};
+
 static int meson_mmc_probe(struct platform_device *pdev)
 {
 	struct resource *res;
 	struct meson_host *host;
 	struct mmc_host *mmc;
+	void __iomem *regs;
 	int ret;
 
 	mmc = mmc_alloc_host(sizeof(struct meson_host), &pdev->dev);
@@ -1220,9 +1199,9 @@ static int meson_mmc_probe(struct platform_device *pdev)
 	}
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	host->regs = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(host->regs)) {
-		ret = PTR_ERR(host->regs);
+	regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(regs)) {
+		ret = PTR_ERR(regs);
 		goto free_host;
 	}
 
@@ -1252,11 +1231,16 @@ static int meson_mmc_probe(struct platform_device *pdev)
 		goto free_host;
 	}
 
+	host->regmap = devm_regmap_init_mmio(&pdev->dev, regs,
+					     &meson_gx_mmc_regmap_config);
+	if (IS_ERR(host->regmap))
+		return PTR_ERR(host->regmap);
+
 	ret = clk_prepare_enable(host->core_clk);
 	if (ret)
 		goto free_host;
 
-	ret = meson_mmc_clk_init(host);
+	ret = meson_mmc_clk_init(host, regs);
 	if (ret)
 		goto err_core_clk;
 
@@ -1264,12 +1248,12 @@ static int meson_mmc_probe(struct platform_device *pdev)
 	meson_mmc_cfg_init(host);
 
 	/* Stop execution */
-	writel(0, host->regs + SD_EMMC_START);
+	regmap_write(host->regmap, SD_EMMC_START, 0);
 
 	/* clear, ack and enable interrupts */
-	writel(0, host->regs + SD_EMMC_IRQ_EN);
-	writel(IRQ_EN_MASK, host->regs + SD_EMMC_STATUS);
-	writel(IRQ_EN_MASK, host->regs + SD_EMMC_IRQ_EN);
+	regmap_write(host->regmap, SD_EMMC_IRQ_EN, 0);
+	regmap_write(host->regmap, SD_EMMC_STATUS, IRQ_EN_MASK);
+	regmap_write(host->regmap, SD_EMMC_IRQ_EN, IRQ_EN_MASK);
 
 	ret = request_threaded_irq(host->irq, meson_mmc_irq,
 				   meson_mmc_irq_thread, IRQF_ONESHOT,
@@ -1308,7 +1292,6 @@ static int meson_mmc_probe(struct platform_device *pdev)
 		 * instead of the DDR memory
 		 */
 		host->bounce_buf_size = SD_EMMC_SRAM_DATA_BUF_LEN;
-		host->bounce_iomem_buf = host->regs + SD_EMMC_SRAM_DATA_BUF_OFF;
 		host->bounce_dma_addr = res->start + SD_EMMC_SRAM_DATA_BUF_OFF;
 	} else {
 		/* data bounce buffer */
@@ -1356,7 +1339,7 @@ static int meson_mmc_remove(struct platform_device *pdev)
 	mmc_remove_host(host->mmc);
 
 	/* disable interrupts */
-	writel(0, host->regs + SD_EMMC_IRQ_EN);
+	regmap_write(host->regmap, SD_EMMC_IRQ_EN, 0);
 	free_irq(host->irq, host);
 
 	clk_disable_unprepare(host->mmc_clk);
diff --git a/drivers/mmc/host/meson-mx-sdio.c b/drivers/mmc/host/meson-mx-sdio.c
index 3a19a05ef55a..618a6826498d 100644
--- a/drivers/mmc/host/meson-mx-sdio.c
+++ b/drivers/mmc/host/meson-mx-sdio.c
@@ -19,6 +19,7 @@
 #include <linux/ioport.h>
 #include <linux/platform_device.h>
 #include <linux/of_platform.h>
+#include <linux/regmap.h>
 #include <linux/timer.h>
 #include <linux/types.h>
 
@@ -108,7 +109,7 @@ struct meson_mx_mmc_host {
 	struct clk_fixed_factor		fixed_factor;
 	struct clk			*fixed_factor_clk;
 
-	void __iomem			*base;
+	struct regmap			*regmap;
 	int				irq;
 	spinlock_t			irq_lock;
 
@@ -122,22 +123,10 @@ struct meson_mx_mmc_host {
 	int				error;
 };
 
-static void meson_mx_mmc_mask_bits(struct mmc_host *mmc, char reg, u32 mask,
-				   u32 val)
-{
-	struct meson_mx_mmc_host *host = mmc_priv(mmc);
-	u32 regval;
-
-	regval = readl(host->base + reg);
-	regval &= ~mask;
-	regval |= (val & mask);
-
-	writel(regval, host->base + reg);
-}
-
 static void meson_mx_mmc_soft_reset(struct meson_mx_mmc_host *host)
 {
-	writel(MESON_MX_SDIO_IRQC_SOFT_RESET, host->base + MESON_MX_SDIO_IRQC);
+	regmap_write(host->regmap, MESON_MX_SDIO_IRQC,
+		     MESON_MX_SDIO_IRQC_SOFT_RESET);
 	udelay(2);
 }
 
@@ -158,7 +147,7 @@ static void meson_mx_mmc_start_cmd(struct mmc_host *mmc,
 	struct meson_mx_mmc_host *host = mmc_priv(mmc);
 	unsigned int pack_size;
 	unsigned long irqflags, timeout;
-	u32 mult, send = 0, ext = 0;
+	u32 send = 0, ext = 0;
 
 	host->cmd = cmd;
 
@@ -215,25 +204,24 @@ static void meson_mx_mmc_start_cmd(struct mmc_host *mmc,
 
 	spin_lock_irqsave(&host->irq_lock, irqflags);
 
-	mult = readl(host->base + MESON_MX_SDIO_MULT);
-	mult &= ~MESON_MX_SDIO_MULT_PORT_SEL_MASK;
-	mult |= FIELD_PREP(MESON_MX_SDIO_MULT_PORT_SEL_MASK, host->slot_id);
-	mult |= BIT(31);
-	writel(mult, host->base + MESON_MX_SDIO_MULT);
+	regmap_update_bits(host->regmap, MESON_MX_SDIO_MULT,
+			   MESON_MX_SDIO_MULT_PORT_SEL_MASK | BIT(31),
+			   FIELD_PREP(MESON_MX_SDIO_MULT_PORT_SEL_MASK,
+				      host->slot_id) | BIT(31));
 
 	/* enable the CMD done interrupt */
-	meson_mx_mmc_mask_bits(mmc, MESON_MX_SDIO_IRQC,
-			       MESON_MX_SDIO_IRQC_ARC_CMD_INT_EN,
-			       MESON_MX_SDIO_IRQC_ARC_CMD_INT_EN);
+	regmap_update_bits(host->regmap, MESON_MX_SDIO_IRQC,
+			   MESON_MX_SDIO_IRQC_ARC_CMD_INT_EN,
+			   MESON_MX_SDIO_IRQC_ARC_CMD_INT_EN);
 
 	/* clear pending interrupts */
-	meson_mx_mmc_mask_bits(mmc, MESON_MX_SDIO_IRQS,
-			       MESON_MX_SDIO_IRQS_CMD_INT,
-			       MESON_MX_SDIO_IRQS_CMD_INT);
+	regmap_update_bits(host->regmap, MESON_MX_SDIO_IRQS,
+			   MESON_MX_SDIO_IRQS_CMD_INT,
+			   MESON_MX_SDIO_IRQS_CMD_INT);
 
-	writel(cmd->arg, host->base + MESON_MX_SDIO_ARGU);
-	writel(ext, host->base + MESON_MX_SDIO_EXT);
-	writel(send, host->base + MESON_MX_SDIO_SEND);
+	regmap_write(host->regmap, MESON_MX_SDIO_ARGU, cmd->arg);
+	regmap_write(host->regmap, MESON_MX_SDIO_EXT, ext);
+	regmap_write(host->regmap, MESON_MX_SDIO_SEND, send);
 
 	spin_unlock_irqrestore(&host->irq_lock, irqflags);
 
@@ -263,14 +251,14 @@ static void meson_mx_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 
 	switch (ios->bus_width) {
 	case MMC_BUS_WIDTH_1:
-		meson_mx_mmc_mask_bits(mmc, MESON_MX_SDIO_CONF,
-				       MESON_MX_SDIO_CONF_BUS_WIDTH, 0);
+		regmap_update_bits(host->regmap, MESON_MX_SDIO_CONF,
+				   MESON_MX_SDIO_CONF_BUS_WIDTH, 0);
 		break;
 
 	case MMC_BUS_WIDTH_4:
-		meson_mx_mmc_mask_bits(mmc, MESON_MX_SDIO_CONF,
-				       MESON_MX_SDIO_CONF_BUS_WIDTH,
-				       MESON_MX_SDIO_CONF_BUS_WIDTH);
+		regmap_update_bits(host->regmap, MESON_MX_SDIO_CONF,
+				   MESON_MX_SDIO_CONF_BUS_WIDTH,
+				   MESON_MX_SDIO_CONF_BUS_WIDTH);
 		break;
 
 	case MMC_BUS_WIDTH_8:
@@ -351,8 +339,8 @@ static void meson_mx_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	host->mrq = mrq;
 
 	if (mrq->data)
-		writel(sg_dma_address(mrq->data->sg),
-		       host->base + MESON_MX_SDIO_ADDR);
+		regmap_write(host->regmap, MESON_MX_SDIO_ADDR,
+			     sg_dma_address(mrq->data->sg));
 
 	if (mrq->sbc)
 		meson_mx_mmc_start_cmd(mmc, mrq->sbc);
@@ -364,24 +352,26 @@ static void meson_mx_mmc_read_response(struct mmc_host *mmc,
 				       struct mmc_command *cmd)
 {
 	struct meson_mx_mmc_host *host = mmc_priv(mmc);
-	u32 mult;
-	int i, resp[4];
+	unsigned int i, resp[4];
 
-	mult = readl(host->base + MESON_MX_SDIO_MULT);
-	mult |= MESON_MX_SDIO_MULT_WR_RD_OUT_INDEX;
-	mult &= ~MESON_MX_SDIO_MULT_RESP_READ_INDEX_MASK;
-	mult |= FIELD_PREP(MESON_MX_SDIO_MULT_RESP_READ_INDEX_MASK, 0);
-	writel(mult, host->base + MESON_MX_SDIO_MULT);
+	regmap_update_bits(host->regmap, MESON_MX_SDIO_MULT,
+			   MESON_MX_SDIO_MULT_WR_RD_OUT_INDEX |
+			   MESON_MX_SDIO_MULT_RESP_READ_INDEX_MASK,
+			   MESON_MX_SDIO_MULT_WR_RD_OUT_INDEX |
+			   FIELD_PREP(MESON_MX_SDIO_MULT_RESP_READ_INDEX_MASK,
+				      0));
 
 	if (cmd->flags & MMC_RSP_136) {
 		for (i = 0; i <= 3; i++)
-			resp[3 - i] = readl(host->base + MESON_MX_SDIO_ARGU);
+			regmap_read(host->regmap, MESON_MX_SDIO_ARGU,
+				    &resp[3 - i]);
+
 		cmd->resp[0] = (resp[0] << 8) | ((resp[1] >> 24) & 0xff);
 		cmd->resp[1] = (resp[1] << 8) | ((resp[2] >> 24) & 0xff);
 		cmd->resp[2] = (resp[2] << 8) | ((resp[3] >> 24) & 0xff);
 		cmd->resp[3] = (resp[3] << 8);
 	} else if (cmd->flags & MMC_RSP_PRESENT) {
-		cmd->resp[0] = readl(host->base + MESON_MX_SDIO_ARGU);
+		regmap_read(host->regmap, MESON_MX_SDIO_ARGU, &cmd->resp[0]);
 	}
 }
 
@@ -422,8 +412,8 @@ static irqreturn_t meson_mx_mmc_irq(int irq, void *data)
 
 	spin_lock(&host->irq_lock);
 
-	irqs = readl(host->base + MESON_MX_SDIO_IRQS);
-	send = readl(host->base + MESON_MX_SDIO_SEND);
+	regmap_read(host->regmap, MESON_MX_SDIO_IRQS, &irqs);
+	regmap_read(host->regmap, MESON_MX_SDIO_SEND, &send);
 
 	if (irqs & MESON_MX_SDIO_IRQS_CMD_INT)
 		ret = meson_mx_mmc_process_cmd_irq(host, irqs, send);
@@ -431,7 +421,7 @@ static irqreturn_t meson_mx_mmc_irq(int irq, void *data)
 		ret = IRQ_HANDLED;
 
 	/* finally ACK all pending interrupts */
-	writel(irqs, host->base + MESON_MX_SDIO_IRQS);
+	regmap_write(host->regmap, MESON_MX_SDIO_IRQS, irqs);
 
 	spin_unlock(&host->irq_lock);
 
@@ -469,14 +459,13 @@ static void meson_mx_mmc_timeout(struct timer_list *t)
 {
 	struct meson_mx_mmc_host *host = from_timer(host, t, cmd_timeout);
 	unsigned long irqflags;
-	u32 irqc;
+	u32 irqs, argu;
 
 	spin_lock_irqsave(&host->irq_lock, irqflags);
 
 	/* disable the CMD interrupt */
-	irqc = readl(host->base + MESON_MX_SDIO_IRQC);
-	irqc &= ~MESON_MX_SDIO_IRQC_ARC_CMD_INT_EN;
-	writel(irqc, host->base + MESON_MX_SDIO_IRQC);
+	regmap_update_bits(host->regmap, MESON_MX_SDIO_IRQC,
+			   MESON_MX_SDIO_IRQC_ARC_CMD_INT_EN, 0);
 
 	spin_unlock_irqrestore(&host->irq_lock, irqflags);
 
@@ -487,10 +476,12 @@ static void meson_mx_mmc_timeout(struct timer_list *t)
 	if (!host->cmd)
 		return;
 
+	regmap_read(host->regmap, MESON_MX_SDIO_IRQS, &irqs);
+	regmap_read(host->regmap, MESON_MX_SDIO_ARGU, &argu);
+
 	dev_dbg(mmc_dev(host->mmc),
 		"Timeout on CMD%u (IRQS = 0x%08x, ARGU = 0x%08x)\n",
-		host->cmd->opcode, readl(host->base + MESON_MX_SDIO_IRQS),
-		readl(host->base + MESON_MX_SDIO_ARGU));
+		host->cmd->opcode, irqs, argu);
 
 	host->cmd->error = -ETIMEDOUT;
 
@@ -577,7 +568,8 @@ static int meson_mx_mmc_add_host(struct meson_mx_mmc_host *host)
 	return 0;
 }
 
-static int meson_mx_mmc_register_clks(struct meson_mx_mmc_host *host)
+static int meson_mx_mmc_register_clks(struct meson_mx_mmc_host *host,
+				      void __iomem *base)
 {
 	struct clk_init_data init;
 	const char *clk_div_parent, *clk_fixed_factor_parent;
@@ -612,7 +604,7 @@ static int meson_mx_mmc_register_clks(struct meson_mx_mmc_host *host)
 	init.flags = CLK_SET_RATE_PARENT;
 	init.parent_names = &clk_div_parent;
 	init.num_parents = 1;
-	host->cfg_div.reg = host->base + MESON_MX_SDIO_CONF;
+	host->cfg_div.reg = base + MESON_MX_SDIO_CONF;
 	host->cfg_div.shift = MESON_MX_SDIO_CONF_CMD_CLK_DIV_SHIFT;
 	host->cfg_div.width = MESON_MX_SDIO_CONF_CMD_CLK_DIV_WIDTH;
 	host->cfg_div.hw.init = &init;
@@ -626,14 +618,26 @@ static int meson_mx_mmc_register_clks(struct meson_mx_mmc_host *host)
 	return 0;
 }
 
+static const struct regmap_config meson_mx_sdio_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 32,
+	.reg_stride = 4,
+	.max_register = MESON_MX_SDIO_EXT,
+};
+
 static int meson_mx_mmc_probe(struct platform_device *pdev)
 {
 	struct platform_device *slot_pdev;
 	struct mmc_host *mmc;
 	struct meson_mx_mmc_host *host;
+	void __iomem *base;
 	int ret, irq;
 	u32 conf;
 
+	base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
 	slot_pdev = meson_mx_mmc_slot_pdev(&pdev->dev);
 	if (!slot_pdev)
 		return -ENODEV;
@@ -655,9 +659,10 @@ static int meson_mx_mmc_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, host);
 
-	host->base = devm_platform_ioremap_resource(pdev, 0);
-	if (IS_ERR(host->base)) {
-		ret = PTR_ERR(host->base);
+	host->regmap = devm_regmap_init_mmio(&pdev->dev, base,
+					     &meson_mx_sdio_regmap_config);
+	if (IS_ERR(host->regmap)) {
+		ret = PTR_ERR(host->regmap);
 		goto error_free_mmc;
 	}
 
@@ -686,7 +691,7 @@ static int meson_mx_mmc_probe(struct platform_device *pdev)
 		goto error_free_mmc;
 	}
 
-	ret = meson_mx_mmc_register_clks(host);
+	ret = meson_mx_mmc_register_clks(host, base);
 	if (ret)
 		goto error_free_mmc;
 
@@ -707,7 +712,7 @@ static int meson_mx_mmc_probe(struct platform_device *pdev)
 	conf |= FIELD_PREP(MESON_MX_SDIO_CONF_M_ENDIAN_MASK, 0x3);
 	conf |= FIELD_PREP(MESON_MX_SDIO_CONF_WRITE_NWR_MASK, 0x2);
 	conf |= FIELD_PREP(MESON_MX_SDIO_CONF_WRITE_CRC_OK_STATUS_MASK, 0x2);
-	writel(conf, host->base + MESON_MX_SDIO_CONF);
+	regmap_write(host->regmap, MESON_MX_SDIO_CONF, conf);
 
 	meson_mx_mmc_soft_reset(host);
 
diff --git a/drivers/mtd/nand/raw/meson_nand.c b/drivers/mtd/nand/raw/meson_nand.c
index 5ee01231ac4c..aacf73b45485 100644
--- a/drivers/mtd/nand/raw/meson_nand.c
+++ b/drivers/mtd/nand/raw/meson_nand.c
@@ -133,6 +133,7 @@ struct meson_nand_ecc {
 
 struct meson_nfc_data {
 	const struct nand_ecc_caps *ecc_caps;
+	bool has_emmc_clk_reg;
 };
 
 struct meson_nfc_param {
@@ -155,7 +156,6 @@ struct nand_timing {
 struct meson_nfc {
 	struct nand_controller controller;
 	struct clk *core_clk;
-	struct clk *device_clk;
 	struct clk *nand_clk;
 	struct clk_divider nand_divider;
 
@@ -215,7 +215,7 @@ static int meson_nand_calc_ecc_bytes(int step_size, int strength)
 	return ecc_bytes;
 }
 
-NAND_ECC_CAPS_SINGLE(meson_gxl_ecc_caps,
+NAND_ECC_CAPS_SINGLE(meson8_ecc_caps,
 		     meson_nand_calc_ecc_bytes, 1024, 8, 24, 30, 40, 50, 60);
 NAND_ECC_CAPS_SINGLE(meson_axg_ecc_caps,
 		     meson_nand_calc_ecc_bytes, 1024, 8);
@@ -1012,50 +1012,41 @@ static int meson_nfc_clk_init(struct meson_nfc *nfc)
 		return PTR_ERR(nfc->core_clk);
 	}
 
-	nfc->device_clk = devm_clk_get(nfc->dev, "device");
-	if (IS_ERR(nfc->device_clk)) {
-		dev_err(nfc->dev, "failed to get device clock\n");
-		return PTR_ERR(nfc->device_clk);
+	if (nfc->data->has_emmc_clk_reg) {
+		init.name = devm_kasprintf(nfc->dev,
+					GFP_KERNEL, "%s#div",
+					dev_name(nfc->dev));
+		init.ops = &clk_divider_ops;
+		nfc_divider_parent_data[0].fw_name = "device";
+		init.parent_data = nfc_divider_parent_data;
+		init.num_parents = 1;
+		nfc->nand_divider.reg = nfc->reg_clk;
+		nfc->nand_divider.shift = CLK_DIV_SHIFT;
+		nfc->nand_divider.width = CLK_DIV_WIDTH;
+		nfc->nand_divider.hw.init = &init;
+		nfc->nand_divider.flags = CLK_DIVIDER_ONE_BASED |
+					  CLK_DIVIDER_ROUND_CLOSEST |
+					  CLK_DIVIDER_ALLOW_ZERO;
+
+		nfc->nand_clk = devm_clk_register(nfc->dev, &nfc->nand_divider.hw);
+		if (IS_ERR(nfc->nand_clk))
+			return PTR_ERR(nfc->nand_clk);
+
+		/* init SD_EMMC_CLOCK to sane defaults w/min clock rate */
+		writel(CLK_SELECT_NAND | readl(nfc->reg_clk), nfc->reg_clk);
+	} else {
+		nfc->nand_clk = devm_clk_get(nfc->dev, "nand");
+		if (IS_ERR(nfc->nand_clk))
+			return dev_err_probe(nfc->dev, PTR_ERR(nfc->nand_clk),
+					     "failed to get the NAND clock\n");
 	}
 
-	init.name = devm_kasprintf(nfc->dev,
-				   GFP_KERNEL, "%s#div",
-				   dev_name(nfc->dev));
-	if (!init.name)
-		return -ENOMEM;
-
-	init.ops = &clk_divider_ops;
-	nfc_divider_parent_data[0].fw_name = "device";
-	init.parent_data = nfc_divider_parent_data;
-	init.num_parents = 1;
-	nfc->nand_divider.reg = nfc->reg_clk;
-	nfc->nand_divider.shift = CLK_DIV_SHIFT;
-	nfc->nand_divider.width = CLK_DIV_WIDTH;
-	nfc->nand_divider.hw.init = &init;
-	nfc->nand_divider.flags = CLK_DIVIDER_ONE_BASED |
-				  CLK_DIVIDER_ROUND_CLOSEST |
-				  CLK_DIVIDER_ALLOW_ZERO;
-
-	nfc->nand_clk = devm_clk_register(nfc->dev, &nfc->nand_divider.hw);
-	if (IS_ERR(nfc->nand_clk))
-		return PTR_ERR(nfc->nand_clk);
-
-	/* init SD_EMMC_CLOCK to sane defaults w/min clock rate */
-	writel(CLK_SELECT_NAND | readl(nfc->reg_clk),
-	       nfc->reg_clk);
-
 	ret = clk_prepare_enable(nfc->core_clk);
 	if (ret) {
 		dev_err(nfc->dev, "failed to enable core clock\n");
 		return ret;
 	}
 
-	ret = clk_prepare_enable(nfc->device_clk);
-	if (ret) {
-		dev_err(nfc->dev, "failed to enable device clock\n");
-		goto err_device_clk;
-	}
-
 	ret = clk_prepare_enable(nfc->nand_clk);
 	if (ret) {
 		dev_err(nfc->dev, "pre enable NFC divider fail\n");
@@ -1071,8 +1062,6 @@ static int meson_nfc_clk_init(struct meson_nfc *nfc)
 err_disable_clk:
 	clk_disable_unprepare(nfc->nand_clk);
 err_nand_clk:
-	clk_disable_unprepare(nfc->device_clk);
-err_device_clk:
 	clk_disable_unprepare(nfc->core_clk);
 	return ret;
 }
@@ -1080,7 +1069,6 @@ static int meson_nfc_clk_init(struct meson_nfc *nfc)
 static void meson_nfc_disable_clk(struct meson_nfc *nfc)
 {
 	clk_disable_unprepare(nfc->nand_clk);
-	clk_disable_unprepare(nfc->device_clk);
 	clk_disable_unprepare(nfc->core_clk);
 }
 
@@ -1360,16 +1348,32 @@ static irqreturn_t meson_nfc_irq(int irq, void *id)
 	return IRQ_HANDLED;
 }
 
+static const struct meson_nfc_data meson8_data = {
+	.ecc_caps = &meson8_ecc_caps,
+	.has_emmc_clk_reg = false,
+};
+
 static const struct meson_nfc_data meson_gxl_data = {
-	.ecc_caps = &meson_gxl_ecc_caps,
+	.ecc_caps = &meson8_ecc_caps,
+	.has_emmc_clk_reg = true,
 };
 
 static const struct meson_nfc_data meson_axg_data = {
 	.ecc_caps = &meson_axg_ecc_caps,
+	.has_emmc_clk_reg = true,
 };
 
 static const struct of_device_id meson_nfc_id_table[] = {
 	{
+		.compatible = "amlogic,meson8-nfc",
+		.data = &meson8_data,
+	}, {
+		.compatible = "amlogic,meson8b-nfc",
+		.data = &meson8_data,
+	}, {
+		.compatible = "amlogic,meson-gxbb-nfc",
+		.data = &meson8_data,
+	}, {
 		.compatible = "amlogic,meson-gxl-nfc",
 		.data = &meson_gxl_data,
 	}, {
@@ -1400,13 +1404,15 @@ static int meson_nfc_probe(struct platform_device *pdev)
 
 	nfc->dev = dev;
 
-	nfc->reg_base = devm_platform_ioremap_resource_byname(pdev, "nfc");
+	nfc->reg_base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(nfc->reg_base))
 		return PTR_ERR(nfc->reg_base);
 
-	nfc->reg_clk = devm_platform_ioremap_resource_byname(pdev, "emmc");
-	if (IS_ERR(nfc->reg_clk))
-		return PTR_ERR(nfc->reg_clk);
+	if (nfc->data->has_emmc_clk_reg) {
+		nfc->reg_clk = devm_platform_ioremap_resource(pdev, 1);
+		if (IS_ERR(nfc->reg_clk))
+			return PTR_ERR(nfc->reg_clk);
+	}
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0)
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-meson.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-meson.c
index 16fb66a0ca72..41c2131b8c75 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-meson.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-meson.c
@@ -5,6 +5,8 @@
  * Copyright (C) 2014 Beniamino Galvani <b.galvani@gmail.com>
  */
 
+#include <linux/bitfield.h>
+#include <linux/clk.h>
 #include <linux/device.h>
 #include <linux/ethtool.h>
 #include <linux/io.h>
@@ -15,11 +17,25 @@
 
 #include "stmmac_platform.h"
 
-#define ETHMAC_SPEED_100	BIT(1)
+#define PREG_ETHERNET_ADDR0_DIV_EN			BIT(0)
+
+/* divides the input clock by 20 (= 0x0) or 2 (= 0x1) */
+#define PREG_ETHERNET_ADDR0_SPEED_100			BIT(1)
+
+/* 0x0 = little, 0x1 = big */
+#define PREG_ETHERNET_ADDR0_DATA_ENDIANNESS		BIT(2)
+
+/* 0x0 = same order, 0x1: unknown */
+#define PREG_ETHERNET_ADDR0_DESC_ENDIANNESS		BIT(3)
+
+#define PREG_ETHERNET_ADDR0_MII_MODE			GENMASK(6, 4)
+#define PREG_ETHERNET_ADDR0_MII_MODE_RGMII		0x1
+#define PREG_ETHERNET_ADDR0_MII_MODE_RMII		0x4
 
 struct meson_dwmac {
 	struct device	*dev;
 	void __iomem	*reg;
+	struct clk	*ethernet_clk;
 };
 
 static void meson6_dwmac_fix_mac_speed(void *priv, unsigned int speed)
@@ -31,16 +47,51 @@ static void meson6_dwmac_fix_mac_speed(void *priv, unsigned int speed)
 
 	switch (speed) {
 	case SPEED_10:
-		val &= ~ETHMAC_SPEED_100;
+		val &= ~PREG_ETHERNET_ADDR0_SPEED_100;
 		break;
 	case SPEED_100:
-		val |= ETHMAC_SPEED_100;
+		val |= PREG_ETHERNET_ADDR0_SPEED_100;
 		break;
 	}
 
 	writel(val, dwmac->reg);
 }
 
+static int meson6_dwmac_init(struct platform_device *pdev, void *priv)
+{
+	struct meson_dwmac *dwmac = priv;
+	u32 val;
+	int ret;
+
+	ret = clk_set_rate(dwmac->ethernet_clk, 50 * 1000 * 1000);
+	if (ret)
+		return ret;
+
+	ret = clk_prepare_enable(dwmac->ethernet_clk);
+	if (ret)
+		return ret;
+
+	val = readl(dwmac->reg);
+	val &= ~PREG_ETHERNET_ADDR0_DATA_ENDIANNESS;
+	val &= ~PREG_ETHERNET_ADDR0_DESC_ENDIANNESS;
+	val &= ~PREG_ETHERNET_ADDR0_MII_MODE;
+	val |= FIELD_PREP(PREG_ETHERNET_ADDR0_MII_MODE,
+			  PREG_ETHERNET_ADDR0_MII_MODE_RMII);
+	val |= PREG_ETHERNET_ADDR0_DIV_EN;
+	writel(val, dwmac->reg);
+
+	return 0;
+}
+
+static void meson6_dwmac_exit(struct platform_device *pdev, void *priv)
+{
+	struct meson_dwmac *dwmac = priv;
+
+	writel(readl(dwmac->reg) & ~PREG_ETHERNET_ADDR0_DIV_EN, dwmac->reg);
+
+	clk_disable_unprepare(dwmac->ethernet_clk);
+}
+
 static int meson6_dwmac_probe(struct platform_device *pdev)
 {
 	struct plat_stmmacenet_data *plat_dat;
@@ -68,15 +119,29 @@ static int meson6_dwmac_probe(struct platform_device *pdev)
 		goto err_remove_config_dt;
 	}
 
+	dwmac->ethernet_clk = devm_clk_get_optional(&pdev->dev, "ethernet");
+	if (IS_ERR(dwmac->ethernet_clk)) {
+		ret = PTR_ERR(dwmac->ethernet_clk);
+		goto err_remove_config_dt;
+	}
+
 	plat_dat->bsp_priv = dwmac;
+	plat_dat->init = meson6_dwmac_init;
+	plat_dat->exit = meson6_dwmac_exit;
 	plat_dat->fix_mac_speed = meson6_dwmac_fix_mac_speed;
 
-	ret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);
+	ret = meson6_dwmac_init(pdev, dwmac);
 	if (ret)
 		goto err_remove_config_dt;
 
+	ret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);
+	if (ret)
+		goto err_exit_dwmac;
+
 	return 0;
 
+err_exit_dwmac:
+	meson6_dwmac_exit(pdev, dwmac);
 err_remove_config_dt:
 	stmmac_remove_config_dt(pdev, plat_dat);
 
diff --git a/drivers/net/phy/realtek.c b/drivers/net/phy/realtek.c
index 3d99fd6664d7..f4cdb77fc407 100644
--- a/drivers/net/phy/realtek.c
+++ b/drivers/net/phy/realtek.c
@@ -7,9 +7,11 @@
  *
  * Copyright (c) 2004 Freescale Semiconductor, Inc.
  */
+#include <dt-bindings/net/realtek-rtl8211f.h>
 #include <linux/bitops.h>
 #include <linux/of.h>
 #include <linux/phy.h>
+#include <linux/property.h>
 #include <linux/module.h>
 #include <linux/delay.h>
 
@@ -38,6 +40,15 @@
 #define RTL8211F_ALDPS_ENABLE			BIT(2)
 #define RTL8211F_ALDPS_XTAL_OFF			BIT(12)
 
+#define RTL8211F_LED_CONFIG_PAGE		0xd04
+#define RTL8211F_LCR				0x10
+#define RTL8211F_LCR_LED0_LINK_10		BIT(0)
+#define RTL8211F_LCR_LED0_LINK_100		BIT(1)
+#define RTL8211F_LCR_LED0_LINK_1000		BIT(3)
+#define RTL8211F_LCR_LED0_ACTIVITY		BIT(4)
+#define RTL8211F_EEELCR				0x11
+#define RTL8211F_EEELCR_LED0_EEE_ENABLE		BIT(1)
+
 #define RTL8211E_CTRL_DELAY			BIT(13)
 #define RTL8211E_TX_DELAY			BIT(12)
 #define RTL8211E_RX_DELAY			BIT(11)
@@ -335,6 +346,91 @@ static int rtl8211c_config_init(struct phy_device *phydev)
 			    CTL1000_ENABLE_MASTER | CTL1000_AS_MASTER);
 }
 
+static int rtl8211f_modify_led_register(struct phy_device *phydev,
+					unsigned int led, u32 regnum, u16 mask,
+					bool set_bit)
+{
+	u8 led_reg_width = regnum == RTL8211F_LCR ? 5 : 1;
+	u16 reg_mask = mask << (led * led_reg_width);
+
+	return phy_modify_paged(phydev, RTL8211F_LED_CONFIG_PAGE, regnum,
+				reg_mask, set_bit ? reg_mask : 0);
+}
+
+static int rtl8211f_config_init_led(struct phy_device *phydev, unsigned int num)
+{
+	struct device *dev = &phydev->mdio.dev;
+	char led_property[29];
+	u32 mode;
+	int ret;
+
+	ret = sprintf(led_property, "realtek,led-%u-mode", num);
+	if (ret < 0)
+		return ret;
+
+	ret = device_property_read_u32(dev, led_property, &mode);
+	if (ret) {
+		dev_dbg(dev,
+			"Keeping LED%u configuration from pin-strapping or bootloader",
+			num);
+		return 0;
+	}
+
+	ret = rtl8211f_modify_led_register(phydev, num, RTL8211F_LCR,
+					   RTL8211F_LCR_LED0_LINK_10,
+					   mode & RTL8211F_LED_LINK_10);
+	if (ret) {
+		dev_err(dev, "Failed to update the LED%u LINK_10 bit\n", num);
+		return ret;
+	}
+
+	ret = rtl8211f_modify_led_register(phydev, num, RTL8211F_LCR,
+					   RTL8211F_LCR_LED0_LINK_100,
+					   mode & RTL8211F_LED_LINK_100);
+	if (ret) {
+		dev_err(dev, "Failed to update the LED%u LINK_100 bit\n", num);
+		return ret;
+	}
+
+	ret = rtl8211f_modify_led_register(phydev, num, RTL8211F_LCR,
+					   RTL8211F_LCR_LED0_LINK_1000,
+					   mode & RTL8211F_LED_LINK_1000);
+	if (ret) {
+		dev_err(dev, "Failed to update the LED%u LINK_1000 bit\n", num);
+		return ret;
+	}
+
+	ret = rtl8211f_modify_led_register(phydev, num, RTL8211F_LCR,
+					   RTL8211F_LCR_LED0_ACTIVITY,
+					   mode & RTL8211F_LED_ACTIVITY);
+	if (ret) {
+		dev_err(dev, "Failed to update the LED%u ACTIVITY bit\n", num);
+		return ret;
+	}
+
+	ret = rtl8211f_modify_led_register(phydev, num, RTL8211F_EEELCR,
+					   RTL8211F_EEELCR_LED0_EEE_ENABLE,
+					   mode & RTL8211F_LED_EEE);
+	if (ret) {
+		dev_err(dev, "Failed to update the LED%u EEE_ENABLE bit\n", num);
+		return ret;
+	}
++	ret = rtl8211f_config_init_led(phydev, 0);
++	if (ret)
++		return ret;
++
++	ret = rtl8211f_config_init_led(phydev, 1);
++	if (ret)
++		return ret;
++
++	ret = rtl8211f_config_init_led(phydev, 2);
++	if (ret)
++		return ret;
++
+
+	return 0;
+}
+
 static int rtl8211f_config_init(struct phy_device *phydev)
 {
 	struct rtl821x_priv *priv = phydev->priv;
@@ -418,6 +514,18 @@ static int rtl8211f_config_init(struct phy_device *phydev)
 		return genphy_soft_reset(phydev);
 	}
 
+	ret = rtl8211f_config_init_led(phydev, 0);
+	if (ret)
+		return ret;
+
+	ret = rtl8211f_config_init_led(phydev, 1);
+	if (ret)
+		return ret;
+
+	ret = rtl8211f_config_init_led(phydev, 2);
+	if (ret)
+		return ret;
+
 	return 0;
 }
 
diff --git a/drivers/nvmem/meson-mx-efuse.c b/drivers/nvmem/meson-mx-efuse.c
index 13eb14316f46..916302028a8c 100644
--- a/drivers/nvmem/meson-mx-efuse.c
+++ b/drivers/nvmem/meson-mx-efuse.c
@@ -9,6 +9,7 @@
 #include <linux/bitops.h>
 #include <linux/clk.h>
 #include <linux/delay.h>
+#include <linux/firmware/meson/meson_mx_trustzone.h>
 #include <linux/io.h>
 #include <linux/iopoll.h>
 #include <linux/module.h>
@@ -167,6 +168,28 @@ static int meson_mx_efuse_read(void *context, unsigned int offset,
 	return err;
 }
 
+static int meson_mx_efuse_read_trustzone_firmware(void *context,
+						  unsigned int offset,
+						  void *buf, size_t bytes)
+{
+	struct meson_mx_efuse *efuse = context;
+	unsigned int tmp;
+	int i, ret;
+
+	for (i = 0; i < bytes; i += efuse->config.word_size) {
+		ret = meson_mx_trustzone_firmware_efuse_read(offset + i,
+							     sizeof(tmp),
+							     &tmp);
+		if (ret)
+			return ret;
+
+		memcpy(buf + i, &tmp,
+		       min_t(size_t, bytes - i, efuse->config.word_size));
+	}
+
+	return 0;
+}
+
 static const struct meson_mx_efuse_platform_data meson6_efuse_data = {
 	.name = "meson6-efuse",
 	.word_size = 1,
@@ -217,7 +240,11 @@ static int meson_mx_efuse_probe(struct platform_device *pdev)
 	efuse->config.word_size = drvdata->word_size;
 	efuse->config.size = SZ_512;
 	efuse->config.read_only = true;
-	efuse->config.reg_read = meson_mx_efuse_read;
+
+	if (meson_mx_trustzone_firmware_available())
+		efuse->config.reg_read = meson_mx_efuse_read_trustzone_firmware;
+	else
+		efuse->config.reg_read = meson_mx_efuse_read;
 
 	efuse->core_clk = devm_clk_get(&pdev->dev, "core");
 	if (IS_ERR(efuse->core_clk)) {
diff --git a/drivers/phy/amlogic/Kconfig b/drivers/phy/amlogic/Kconfig
index ce7ba3eb2a8e..671435b605f2 100644
--- a/drivers/phy/amlogic/Kconfig
+++ b/drivers/phy/amlogic/Kconfig
@@ -25,6 +25,16 @@ config PHY_MESON8B_USB2
 	  Meson8b and GXBB SoCs.
 	  If unsure, say N.
 
+config PHY_MESON_CVBS_DAC
+	tristate "Amlogic Meson CVBS DAC PHY driver"
+	depends on ARCH_MESON || COMPILE_TEST
+	depends on OF
+	select MFD_SYSCON
+	help
+	  Enable this to support the CVBS DAC (PHY) found in Amlogic
+	  Meson SoCs.
+	  If unsure, say N.
+
 config PHY_MESON_GXL_USB2
 	tristate "Meson GXL and GXM USB2 PHY drivers"
 	default ARCH_MESON
diff --git a/drivers/phy/amlogic/Makefile b/drivers/phy/amlogic/Makefile
index 91e3b9790c03..f6c38f7386a6 100644
--- a/drivers/phy/amlogic/Makefile
+++ b/drivers/phy/amlogic/Makefile
@@ -1,6 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0-only
 obj-$(CONFIG_PHY_MESON8_HDMI_TX)		+= phy-meson8-hdmi-tx.o
 obj-$(CONFIG_PHY_MESON8B_USB2)			+= phy-meson8b-usb2.o
+obj-$(CONFIG_PHY_MESON_CVBS_DAC)		+= phy-meson-cvbs-dac.o
 obj-$(CONFIG_PHY_MESON_GXL_USB2)		+= phy-meson-gxl-usb2.o
 obj-$(CONFIG_PHY_MESON_G12A_USB2)		+= phy-meson-g12a-usb2.o
 obj-$(CONFIG_PHY_MESON_G12A_USB3_PCIE)		+= phy-meson-g12a-usb3-pcie.o
diff --git a/drivers/phy/amlogic/phy-meson-cvbs-dac.c b/drivers/phy/amlogic/phy-meson-cvbs-dac.c
new file mode 100644
index 000000000000..29d0e116e2a1
--- /dev/null
+++ b/drivers/phy/amlogic/phy-meson-cvbs-dac.c
@@ -0,0 +1,372 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2016 BayLibre, SAS
+ * Copyright (C) 2021 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/property.h>
+#include <linux/mfd/syscon.h>
+#include <linux/nvmem-consumer.h>
+
+#define HHI_VDAC_CNTL0_MESON8			0x2F4 /* 0xbd offset in data sheet */
+#define HHI_VDAC_CNTL1_MESON8			0x2F8 /* 0xbe offset in data sheet */
+
+#define HHI_VDAC_CNTL0_G12A			0x2EC /* 0xbd offset in data sheet */
+#define HHI_VDAC_CNTL1_G12A			0x2F0 /* 0xbe offset in data sheet */
+
+enum phy_meson_cvbs_dac_reg {
+	MESON_CDAC_CTRL_RESV1,
+	MESON_CDAC_CTRL_RESV2,
+	MESON_CDAC_VREF_ADJ,
+	MESON_CDAC_RL_ADJ,
+	MESON_CDAC_CLK_PHASE_SEL,
+	MESON_CDAC_DRIVER_ADJ,
+	MESON_CDAC_EXT_VREF_EN,
+	MESON_CDAC_BIAS_C,
+	MESON_VDAC_CNTL0_RESERVED,
+	MESON_CDAC_GSW,
+	MESON_CDAC_PWD,
+	MESON_VDAC_CNTL1_RESERVED,
+	MESON_CVBS_DAC_NUM_REGS
+};
+
+struct phy_meson_cvbs_dac_data {
+	const struct reg_field	*reg_fields;
+	u8			cdac_ctrl_resv2_enable_val;
+	u8			cdac_vref_adj_enable_val;
+	u8			cdac_rl_adj_enable_val;
+	u8			cdac_pwd_disable_val;
+	bool			needs_cvbs_trimming_nvmem_cell;
+};
+
+struct phy_meson_cvbs_dac_priv {
+	struct regmap_field			*regs[MESON_CVBS_DAC_NUM_REGS];
+	const struct phy_meson_cvbs_dac_data	*data;
+	u8					cdac_gsw_enable_val;
+};
+
+static const struct reg_field phy_meson8_cvbs_dac_reg_fields[] = {
+	[MESON_CDAC_CTRL_RESV1] =	REG_FIELD(HHI_VDAC_CNTL0_MESON8, 0, 7),
+	[MESON_CDAC_CTRL_RESV2] =	REG_FIELD(HHI_VDAC_CNTL0_MESON8, 8, 15),
+	[MESON_CDAC_VREF_ADJ] =		REG_FIELD(HHI_VDAC_CNTL0_MESON8, 16, 20),
+	[MESON_CDAC_RL_ADJ] =		REG_FIELD(HHI_VDAC_CNTL0_MESON8, 21, 23),
+	[MESON_CDAC_CLK_PHASE_SEL] =	REG_FIELD(HHI_VDAC_CNTL0_MESON8, 24, 24),
+	[MESON_CDAC_DRIVER_ADJ] =	REG_FIELD(HHI_VDAC_CNTL0_MESON8, 25, 25),
+	[MESON_CDAC_EXT_VREF_EN] =	REG_FIELD(HHI_VDAC_CNTL0_MESON8, 26, 26),
+	[MESON_CDAC_BIAS_C] =		REG_FIELD(HHI_VDAC_CNTL0_MESON8, 27, 27),
+	[MESON_VDAC_CNTL0_RESERVED] =	REG_FIELD(HHI_VDAC_CNTL0_MESON8, 28, 31),
+	[MESON_CDAC_GSW] =		REG_FIELD(HHI_VDAC_CNTL1_MESON8, 0, 2),
+	[MESON_CDAC_PWD] =		REG_FIELD(HHI_VDAC_CNTL1_MESON8, 3, 3),
+	[MESON_VDAC_CNTL1_RESERVED] =	REG_FIELD(HHI_VDAC_CNTL1_MESON8, 4, 31),
+};
+
+static const struct reg_field phy_meson_g12a_cvbs_dac_reg_fields[] = {
+	[MESON_CDAC_CTRL_RESV1] =	REG_FIELD(HHI_VDAC_CNTL0_G12A, 0, 7),
+	[MESON_CDAC_CTRL_RESV2] =	REG_FIELD(HHI_VDAC_CNTL0_G12A, 8, 15),
+	[MESON_CDAC_VREF_ADJ] =		REG_FIELD(HHI_VDAC_CNTL0_G12A, 16, 20),
+	[MESON_CDAC_RL_ADJ] =		REG_FIELD(HHI_VDAC_CNTL0_G12A, 21, 23),
+	[MESON_CDAC_CLK_PHASE_SEL] =	REG_FIELD(HHI_VDAC_CNTL0_G12A, 24, 24),
+	[MESON_CDAC_DRIVER_ADJ] =	REG_FIELD(HHI_VDAC_CNTL0_G12A, 25, 25),
+	[MESON_CDAC_EXT_VREF_EN] =	REG_FIELD(HHI_VDAC_CNTL0_G12A, 26, 26),
+	[MESON_CDAC_BIAS_C] =		REG_FIELD(HHI_VDAC_CNTL0_G12A, 27, 27),
+	[MESON_VDAC_CNTL0_RESERVED] =	REG_FIELD(HHI_VDAC_CNTL0_G12A, 28, 31),
+	[MESON_CDAC_GSW] =		REG_FIELD(HHI_VDAC_CNTL1_G12A, 0, 2),
+	[MESON_CDAC_PWD] =		REG_FIELD(HHI_VDAC_CNTL1_G12A, 3, 3),
+	[MESON_VDAC_CNTL1_RESERVED] =	REG_FIELD(HHI_VDAC_CNTL1_G12A, 4, 31),
+};
+
+static const struct phy_meson_cvbs_dac_data phy_meson8_cvbs_dac_data = {
+	.reg_fields			= phy_meson8_cvbs_dac_reg_fields,
+	.cdac_ctrl_resv2_enable_val	= 0x0,
+	.cdac_vref_adj_enable_val	= 0x0,
+	.cdac_rl_adj_enable_val		= 0x0,
+	.cdac_pwd_disable_val		= 0x1,
+	.needs_cvbs_trimming_nvmem_cell	= true,
+};
+
+static const struct phy_meson_cvbs_dac_data phy_meson_gxbb_cvbs_dac_data = {
+	.reg_fields			= phy_meson8_cvbs_dac_reg_fields,
+	.cdac_ctrl_resv2_enable_val	= 0x0,
+	.cdac_vref_adj_enable_val	= 0x0,
+	.cdac_rl_adj_enable_val		= 0x0,
+	.cdac_pwd_disable_val		= 0x1,
+	.needs_cvbs_trimming_nvmem_cell	= false,
+};
+
+static const struct phy_meson_cvbs_dac_data phy_meson_gxl_cvbs_dac_data = {
+	.reg_fields			= phy_meson8_cvbs_dac_reg_fields,
+	.cdac_ctrl_resv2_enable_val	= 0x0,
+	.cdac_vref_adj_enable_val	= 0xf,
+	.cdac_rl_adj_enable_val		= 0x0,
+	.cdac_pwd_disable_val		= 0x1,
+	.needs_cvbs_trimming_nvmem_cell	= false,
+};
+
+static const struct phy_meson_cvbs_dac_data phy_meson_g12a_cvbs_dac_data = {
+	.reg_fields			= phy_meson_g12a_cvbs_dac_reg_fields,
+	.cdac_ctrl_resv2_enable_val	= 0x60,
+	.cdac_vref_adj_enable_val	= 0x10,
+	.cdac_rl_adj_enable_val		= 0x4,
+	.cdac_pwd_disable_val		= 0x0,
+	.needs_cvbs_trimming_nvmem_cell	= false,
+};
+
+static int phy_meson_cvbs_dac_power_on(struct phy *phy)
+{
+	struct phy_meson_cvbs_dac_priv *priv = phy_get_drvdata(phy);
+
+	regmap_field_write(priv->regs[MESON_CDAC_CTRL_RESV1], 0x1);
+	regmap_field_write(priv->regs[MESON_CDAC_CTRL_RESV2],
+			   priv->data->cdac_ctrl_resv2_enable_val);
+	regmap_field_write(priv->regs[MESON_CDAC_VREF_ADJ],
+			   priv->data->cdac_vref_adj_enable_val);
+	regmap_field_write(priv->regs[MESON_CDAC_RL_ADJ],
+			   priv->data->cdac_rl_adj_enable_val);
+	regmap_field_write(priv->regs[MESON_CDAC_GSW],
+			   priv->cdac_gsw_enable_val);
+	regmap_field_write(priv->regs[MESON_CDAC_PWD], 0x0);
+
+	return 0;
+}
+
+static int phy_meson_cvbs_dac_power_off(struct phy *phy)
+{
+	struct phy_meson_cvbs_dac_priv *priv = phy_get_drvdata(phy);
+
+	regmap_field_write(priv->regs[MESON_CDAC_CTRL_RESV1], 0x0);
+	regmap_field_write(priv->regs[MESON_CDAC_CTRL_RESV2], 0x0);
+	regmap_field_write(priv->regs[MESON_CDAC_VREF_ADJ], 0x0);
+	regmap_field_write(priv->regs[MESON_CDAC_RL_ADJ], 0x0);
+	regmap_field_write(priv->regs[MESON_CDAC_GSW], 0x0);
+	regmap_field_write(priv->regs[MESON_CDAC_PWD],
+			   priv->data->cdac_pwd_disable_val);
+
+	return 0;
+}
+
+static int phy_meson_cvbs_dac_init(struct phy *phy)
+{
+	struct phy_meson_cvbs_dac_priv *priv = phy_get_drvdata(phy);
+
+	regmap_field_write(priv->regs[MESON_CDAC_CLK_PHASE_SEL], 0x0);
+	regmap_field_write(priv->regs[MESON_CDAC_DRIVER_ADJ], 0x0);
+	regmap_field_write(priv->regs[MESON_CDAC_EXT_VREF_EN], 0x0);
+	regmap_field_write(priv->regs[MESON_CDAC_BIAS_C], 0x0);
+	regmap_field_write(priv->regs[MESON_VDAC_CNTL0_RESERVED], 0x0);
+	regmap_field_write(priv->regs[MESON_VDAC_CNTL1_RESERVED], 0x0);
+
+	return phy_meson_cvbs_dac_power_off(phy);
+}
+
+static const struct phy_ops phy_meson_cvbs_dac_ops = {
+	.init		= phy_meson_cvbs_dac_init,
+	.power_on	= phy_meson_cvbs_dac_power_on,
+	.power_off	= phy_meson_cvbs_dac_power_off,
+	.owner		= THIS_MODULE,
+};
+
+static u8 phy_meson_cvbs_trimming_version(u8 trimming1)
+{
+	if ((trimming1 & 0xf0) == 0xa0)
+		return 5;
+	else if ((trimming1 & 0xf0) == 0x40)
+		return 2;
+	else if ((trimming1 & 0xc0) == 0x80)
+		return 1;
+	else if ((trimming1 & 0xc0) == 0x00)
+		return 0;
+	else
+		return 0xff;
+}
+
+static int phy_meson_cvbs_read_trimming(struct device *dev,
+					struct phy_meson_cvbs_dac_priv *priv)
+{
+	struct nvmem_cell *cell;
+	u8 *trimming;
+	size_t len;
+
+	cell = devm_nvmem_cell_get(dev, "cvbs_trimming");
+	if (IS_ERR(cell))
+		return dev_err_probe(dev, PTR_ERR(cell),
+				     "Failed to get the 'cvbs_trimming' nvmem-cell\n");
+
+	trimming = nvmem_cell_read(cell, &len);
+	if (IS_ERR(trimming)) {
+		/*
+		 * TrustZone firmware may block access to the CVBS trimming
+		 * data stored in the eFuse. On those devices the trimming data
+		 * is stored in the u-boot environment. However, the known
+		 * examples of trimming data in the u-boot environment are all
+		 * zero.
+		 */
+		dev_dbg(dev,
+			"Failed to read the 'cvbs_trimming' nvmem-cell - falling back to a default value\n");
+		priv->cdac_gsw_enable_val = 0x0;
+		return 0;
+	}
+
+	if (len != 2) {
+		kfree(trimming);
+		return dev_err_probe(dev, -EINVAL,
+				     "Read the 'cvbs_trimming' nvmem-cell with invalid length\n");
+	}
+
+	switch (phy_meson_cvbs_trimming_version(trimming[1])) {
+	case 1:
+	case 2:
+	case 5:
+		priv->cdac_gsw_enable_val = trimming[0] & 0x7;
+		break;
+	default:
+		priv->cdac_gsw_enable_val = 0x0;
+		break;
+	}
+
+	kfree(trimming);
+
+	return 0;
+}
+
+static int phy_meson_cvbs_dac_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct phy_meson_cvbs_dac_priv *priv;
+	struct phy_provider *phy_provider;
+	struct device *dev = &pdev->dev;
+	struct regmap *hhi;
+	struct phy *phy;
+	int ret;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	if (np) {
+		priv->data = device_get_match_data(dev);
+		if (!priv->data)
+			return dev_err_probe(dev, -EINVAL,
+					     "Could not find the OF match data\n");
+
+		hhi = syscon_node_to_regmap(np->parent);
+		if (IS_ERR(hhi))
+			return dev_err_probe(dev, PTR_ERR(hhi),
+					     "Failed to get the parent syscon\n");
+	} else {
+		const struct platform_device_id *pdev_id;
+
+		pdev_id = platform_get_device_id(pdev);
+		if (!pdev_id)
+			return dev_err_probe(dev, -EINVAL,
+					     "Failed to find platform device ID\n");
+
+		priv->data = (void *)pdev_id->driver_data;
+		if (!priv->data)
+			return dev_err_probe(dev, -EINVAL,
+					     "Could not find the platform driver data\n");
+
+		hhi = syscon_regmap_lookup_by_compatible("amlogic,meson-gx-hhi-sysctrl");
+		if (IS_ERR(hhi))
+			return dev_err_probe(dev, PTR_ERR(hhi),
+					     "Failed to get the \"amlogic,meson-gx-hhi-sysctrl\" syscon\n");
+	}
+
+	if (priv->data->needs_cvbs_trimming_nvmem_cell) {
+		ret = phy_meson_cvbs_read_trimming(dev, priv);
+		if (ret)
+			return ret;
+	}
+
+	ret = devm_regmap_field_bulk_alloc(dev, hhi, priv->regs,
+					   priv->data->reg_fields,
+					   MESON_CVBS_DAC_NUM_REGS);
+	if (ret)
+		return dev_err_probe(dev, ret,
+				     "Failed to create regmap fields\n");
+
+	phy = devm_phy_create(dev, np, &phy_meson_cvbs_dac_ops);
+	if (IS_ERR(phy))
+		return PTR_ERR(phy);
+
+	phy_set_drvdata(phy, priv);
+
+	if (np) {
+		phy_provider = devm_of_phy_provider_register(dev,
+							     of_phy_simple_xlate);
+		ret = PTR_ERR_OR_ZERO(phy_provider);
+		if (ret)
+			return dev_err_probe(dev, ret,
+					     "Failed to register PHY provider\n");
+	}
+
+	platform_set_drvdata(pdev, phy);
+
+	return 0;
+}
+
+static const struct of_device_id phy_meson_cvbs_dac_of_match[] = {
+	{
+		.compatible = "amlogic,meson8-cvbs-dac",
+		.data = &phy_meson8_cvbs_dac_data,
+	},
+	{
+		.compatible = "amlogic,meson-gxbb-cvbs-dac",
+		.data = &phy_meson_gxbb_cvbs_dac_data,
+	},
+	{
+		.compatible = "amlogic,meson-gxl-cvbs-dac",
+		.data = &phy_meson_gxl_cvbs_dac_data,
+	},
+	{
+		.compatible = "amlogic,meson-g12a-cvbs-dac",
+		.data = &phy_meson_g12a_cvbs_dac_data,
+	},
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, phy_meson_cvbs_dac_of_match);
+
+/*
+ * The platform_device_id table is used for backwards compatibility with old
+ * .dtbs which don't have a CVBS DAC node (where the VPU DRM driver registers
+ * this as a platform device. Support for additional SoCs should only be added
+ * to the of_device_id table above.
+ */
+static const struct platform_device_id phy_meson_cvbs_dac_device_ids[] = {
+	{
+		.name = "meson-gxbb-cvbs-dac",
+		.driver_data = (kernel_ulong_t)&phy_meson_gxbb_cvbs_dac_data,
+	},
+	{
+		.name = "meson-gxl-cvbs-dac",
+		.driver_data = (kernel_ulong_t)&phy_meson_gxl_cvbs_dac_data,
+	},
+	{
+		.name = "meson-g12a-cvbs-dac",
+		.driver_data = (kernel_ulong_t)&phy_meson_g12a_cvbs_dac_data,
+	},
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(platform, phy_meson_cvbs_dac_device_ids);
+
+static struct platform_driver phy_meson_cvbs_dac_driver = {
+	.driver = {
+		.name		= "phy-meson-cvbs-dac",
+		.of_match_table	= phy_meson_cvbs_dac_of_match,
+	},
+	.id_table = phy_meson_cvbs_dac_device_ids,
+	.probe = phy_meson_cvbs_dac_probe,
+};
+module_platform_driver(phy_meson_cvbs_dac_driver);
+
+MODULE_AUTHOR("Martin Blumenstingl <martin.blumenstingl@googlemail.com>");
+MODULE_DESCRIPTION("Amlogic Meson CVBS DAC driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/phy/amlogic/phy-meson8b-usb2.c b/drivers/phy/amlogic/phy-meson8b-usb2.c
index dd96763911b8..56b526b71851 100644
--- a/drivers/phy/amlogic/phy-meson8b-usb2.c
+++ b/drivers/phy/amlogic/phy-meson8b-usb2.c
@@ -7,6 +7,7 @@
 
 #include <linux/clk.h>
 #include <linux/delay.h>
+#include <linux/gpio/driver.h>
 #include <linux/io.h>
 #include <linux/module.h>
 #include <linux/of_device.h>
@@ -127,6 +128,7 @@ struct phy_meson8b_usb2_priv {
 	struct clk					*clk_usb_general;
 	struct clk					*clk_usb;
 	struct reset_control				*reset;
+	struct gpio_chip				gpiochip;
 	const struct phy_meson8b_usb2_match_data	*match;
 };
 
@@ -236,12 +238,44 @@ static const struct phy_ops phy_meson8b_usb2_ops = {
 	.owner		= THIS_MODULE,
 };
 
+static int phy_meson8b_usb2_id_gpio_get_direction(struct gpio_chip *gc,
+						  unsigned int offset)
+{
+	return GPIO_LINE_DIRECTION_IN;
+}
+
+static int phy_meson8b_usb2_id_gpio_get_value(struct gpio_chip *gc,
+					      unsigned int offset)
+{
+	struct phy_meson8b_usb2_priv *priv = gpiochip_get_data(gc);
+	unsigned int val;
+
+	regmap_read(priv->regmap, REG_ADP_BC, &val);
+
+	return (val & REG_ADP_BC_ID_DIG) ? 1 : 0;
+}
+
+static int phy_meson8b_usb2_id_gpiochip_add(struct device *dev,
+					    struct phy_meson8b_usb2_priv *priv)
+{
+	priv->gpiochip.label = dev_name(dev);
+	priv->gpiochip.parent = dev;
+	priv->gpiochip.get_direction = phy_meson8b_usb2_id_gpio_get_direction;
+	priv->gpiochip.get = phy_meson8b_usb2_id_gpio_get_value;
+	priv->gpiochip.of_gpio_n_cells = 2;
+	priv->gpiochip.base = -1;
+	priv->gpiochip.ngpio = 1;
+
+	return devm_gpiochip_add_data(dev, &priv->gpiochip, priv);
+}
+
 static int phy_meson8b_usb2_probe(struct platform_device *pdev)
 {
 	struct phy_meson8b_usb2_priv *priv;
-	struct phy *phy;
 	struct phy_provider *phy_provider;
 	void __iomem *base;
+	struct phy *phy;
+	int ret;
 
 	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
 	if (!priv)
@@ -280,6 +314,12 @@ static int phy_meson8b_usb2_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
+	if (device_property_read_bool(&pdev->dev, "gpio-controller")) {
+		ret = phy_meson8b_usb2_id_gpiochip_add(&pdev->dev, priv);
+		if (ret)
+			return ret;
+	}
+
 	phy = devm_phy_create(&pdev->dev, NULL, &phy_meson8b_usb2_ops);
 	if (IS_ERR(phy)) {
 		return dev_err_probe(&pdev->dev, PTR_ERR(phy),
diff --git a/drivers/soc/amlogic/meson-mx-socinfo.c b/drivers/soc/amlogic/meson-mx-socinfo.c
index 92125dd65f33..25503bdd7ab1 100644
--- a/drivers/soc/amlogic/meson-mx-socinfo.c
+++ b/drivers/soc/amlogic/meson-mx-socinfo.c
@@ -4,6 +4,7 @@
  * SPDX-License-Identifier: GPL-2.0+
  */
 
+#include <linux/firmware/meson/meson_mx_trustzone.h>
 #include <linux/io.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
@@ -118,10 +119,12 @@ static int __init meson_mx_socinfo_init(void)
 	if (IS_ERR(assist_regmap))
 		return PTR_ERR(assist_regmap);
 
-	bootrom_regmap =
-		syscon_regmap_lookup_by_compatible("amlogic,meson-mx-bootrom");
-	if (IS_ERR(bootrom_regmap))
-		return PTR_ERR(bootrom_regmap);
+	if (!meson_mx_trustzone_firmware_available()) {
+		bootrom_regmap =
+			syscon_regmap_lookup_by_compatible("amlogic,meson-mx-bootrom");
+		if (IS_ERR(bootrom_regmap))
+			return PTR_ERR(bootrom_regmap);
+	}
 
 	np = of_find_matching_node(NULL, meson_mx_socinfo_analog_top_ids);
 	if (np) {
@@ -141,10 +144,14 @@ static int __init meson_mx_socinfo_init(void)
 	if (ret < 0)
 		return ret;
 
-	ret = regmap_read(bootrom_regmap, MESON_MX_BOOTROM_MISC_VER,
-			  &misc_ver);
-	if (ret < 0)
-		return ret;
+	if (meson_mx_trustzone_firmware_available()) {
+		misc_ver = meson_mx_trustzone_read_soc_rev1();
+	} else {
+		ret = regmap_read(bootrom_regmap, MESON_MX_BOOTROM_MISC_VER,
+				  &misc_ver);
+		if (ret < 0)
+			return ret;
+	}
 
 	soc_dev_attr = kzalloc(sizeof(*soc_dev_attr), GFP_KERNEL);
 	if (!soc_dev_attr)
diff --git a/drivers/usb/common/usb-conn-gpio.c b/drivers/usb/common/usb-conn-gpio.c
index 3f5180d64931..af5a645c633d 100644
--- a/drivers/usb/common/usb-conn-gpio.c
+++ b/drivers/usb/common/usb-conn-gpio.c
@@ -23,6 +23,7 @@
 
 #define USB_GPIO_DEB_MS		20	/* ms */
 #define USB_GPIO_DEB_US		((USB_GPIO_DEB_MS) * 1000)	/* us */
+#define USB_GPIO_POLL_MS	1000
 
 #define USB_CONN_IRQF	\
 	(IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | IRQF_ONESHOT)
@@ -45,6 +46,23 @@ struct usb_conn_info {
 	bool initial_detection;
 };
 
+static void usb_conn_queue_dwork(struct usb_conn_info *info,
+				 unsigned long delay)
+{
+	queue_delayed_work(system_power_efficient_wq, &info->dw_det, delay);
+}
+
+static void usb_conn_gpio_start_polling(struct usb_conn_info *info)
+{
+	usb_conn_queue_dwork(info, msecs_to_jiffies(USB_GPIO_POLL_MS));
+}
+
+static bool usb_conn_gpio_needs_polling(struct usb_conn_info *info)
+{
+	/* We need to poll if one of the GPIOs cannot generate an IRQ. */
+	return info->id_irq < 0 || info->vbus_irq < 0;
+}
+
 /*
  * "DEVICE" = VBUS and "HOST" = !ID, so we have:
  * Both "DEVICE" and "HOST" can't be set as active at the same time
@@ -88,7 +106,12 @@ static void usb_conn_detect_cable(struct work_struct *work)
 		usb_role_string(info->last_role), usb_role_string(role), id, vbus);
 
 	if (!info->initial_detection && info->last_role == role) {
-		dev_warn(info->dev, "repeated role: %s\n", usb_role_string(role));
+		if (usb_conn_gpio_needs_polling(info))
+			usb_conn_gpio_start_polling(info);
+		else
+			dev_warn(info->dev, "repeated role: %s\n",
+				 usb_role_string(role));
+
 		return;
 	}
 
@@ -114,12 +137,9 @@ static void usb_conn_detect_cable(struct work_struct *work)
 			regulator_is_enabled(info->vbus) ? "enabled" : "disabled");
 
 	power_supply_changed(info->charger);
-}
 
-static void usb_conn_queue_dwork(struct usb_conn_info *info,
-				 unsigned long delay)
-{
-	queue_delayed_work(system_power_efficient_wq, &info->dw_det, delay);
+	if (usb_conn_gpio_needs_polling(info))
+		usb_conn_gpio_start_polling(info);
 }
 
 static irqreturn_t usb_conn_isr(int irq, void *dev_id)
@@ -226,34 +246,34 @@ static int usb_conn_probe(struct platform_device *pdev)
 	if (info->id_gpiod) {
 		info->id_irq = gpiod_to_irq(info->id_gpiod);
 		if (info->id_irq < 0) {
-			dev_err(dev, "failed to get ID IRQ\n");
-			ret = info->id_irq;
-			goto put_role_sw;
-		}
-
-		ret = devm_request_threaded_irq(dev, info->id_irq, NULL,
-						usb_conn_isr, USB_CONN_IRQF,
-						pdev->name, info);
-		if (ret < 0) {
-			dev_err(dev, "failed to request ID IRQ\n");
-			goto put_role_sw;
+			dev_info(dev,
+				 "failed to get ID IRQ - falling back to polling\n");
+		} else {
+			ret = devm_request_threaded_irq(dev, info->id_irq,
+							NULL, usb_conn_isr,
+							USB_CONN_IRQF,
+							pdev->name, info);
+			if (ret < 0) {
+				dev_err(dev, "failed to request ID IRQ\n");
+				goto put_role_sw;
+			}
 		}
 	}
 
 	if (info->vbus_gpiod) {
 		info->vbus_irq = gpiod_to_irq(info->vbus_gpiod);
 		if (info->vbus_irq < 0) {
-			dev_err(dev, "failed to get VBUS IRQ\n");
-			ret = info->vbus_irq;
-			goto put_role_sw;
-		}
-
-		ret = devm_request_threaded_irq(dev, info->vbus_irq, NULL,
-						usb_conn_isr, USB_CONN_IRQF,
-						pdev->name, info);
-		if (ret < 0) {
-			dev_err(dev, "failed to request VBUS IRQ\n");
-			goto put_role_sw;
+			dev_info(dev,
+				 "failed to get VBUS IRQ - falling back to polling\n");
+		} else {
+			ret = devm_request_threaded_irq(dev, info->vbus_irq,
+							NULL, usb_conn_isr,
+							USB_CONN_IRQF,
+							pdev->name, info);
+			if (ret < 0) {
+				dev_err(dev, "failed to request VBUS IRQ\n");
+				goto put_role_sw;
+			}
 		}
 	}
 
@@ -302,6 +322,8 @@ static int __maybe_unused usb_conn_suspend(struct device *dev)
 	if (info->vbus_gpiod)
 		disable_irq(info->vbus_irq);
 
+	cancel_delayed_work_sync(&info->dw_det);
+
 	pinctrl_pm_select_sleep_state(dev);
 
 	return 0;
diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 23ef75996823..62290d46e4ba 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -592,6 +592,19 @@ static int dwc2_driver_probe(struct platform_device *dev)
 		}
 	}
 #endif /* CONFIG_USB_DWC2_PERIPHERAL || CONFIG_USB_DWC2_DUAL_ROLE */
+
+	retval = devm_of_platform_populate(&dev->dev);
+	if (retval) {
+		dev_err(hsotg->dev,
+			"Failed to create child devices/connectors for %p\n",
+			dev->dev.of_node);
+
+		if (hsotg->gadget_enabled)
+			dwc2_hsotg_remove(hsotg);
+
+		goto error_debugfs;
+	}
+
 	return 0;
 
 #if IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL) || \
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 8d799d23c476..579af61d2ee0 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -43,6 +43,16 @@ config USB_XHCI_PCI
 	depends on USB_XHCI_PCI_RENESAS || !USB_XHCI_PCI_RENESAS
 	default y
 
+config USB_XHCI_PCI_ETRON
+	tristate "Support for GPIOs in the Etron EJ168/EJ188/EJ198 controllers"
+	depends on USB_XHCI_PCI && OF_GPIO
+	default n
+	help
+	  Say 'Y' to enable the support for the GPIO controller inside the
+	  Etron EJ168/EJ188/EJ198 xHCI controllers.
+
+	  If unsure, say 'N'.
+
 config USB_XHCI_PCI_RENESAS
 	tristate "Support for additional Renesas xHCI controller with firmware"
 	help
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 6d8ee264c9b2..b70776eee5d8 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -69,6 +69,7 @@ obj-$(CONFIG_USB_UHCI_HCD)	+= uhci-hcd.o
 obj-$(CONFIG_USB_FHCI_HCD)	+= fhci.o
 obj-$(CONFIG_USB_XHCI_HCD)	+= xhci-hcd.o
 obj-$(CONFIG_USB_XHCI_PCI)	+= xhci-pci.o
+obj-$(CONFIG_USB_XHCI_PCI_ETRON)	+= xhci-pci-etron.o
 obj-$(CONFIG_USB_XHCI_PCI_RENESAS)	+= xhci-pci-renesas.o
 obj-$(CONFIG_USB_XHCI_PLATFORM) += xhci-plat-hcd.o
 obj-$(CONFIG_USB_XHCI_HISTB)	+= xhci-histb.o
diff --git a/drivers/usb/host/xhci-pci-etron.c b/drivers/usb/host/xhci-pci-etron.c
new file mode 100644
index 000000000000..fcb0a32a4768
--- /dev/null
+++ b/drivers/usb/host/xhci-pci-etron.c
@@ -0,0 +1,287 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/* Copyright (C) 2020 Martin Blumenstingl <martin.blumenstingl@googlemail.com> */
+
+#include <linux/bitfield.h>
+#include <linux/delay.h>
+#include <linux/gpio/driver.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/property.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+
+#include "xhci-pci.h"
+
+#define EJ1X8_GPIO_INIT					0x44
+#define EJ1X8_GPIO_WRITE				0x68
+#define EJ1X8_GPIO_READ					0x6c
+
+#define EJ1X8_GPIO_CTRL					0x18005020
+#define EJ1X8_GPIO_CTRL_READ_ALL_MASK			GENMASK(7, 0)
+#define EJ1X8_GPIO_CTRL_WRITE_ALL_MASK			GENMASK(23, 16)
+#define EJ1X8_GPIO_CTRL_OUT_LOW				0x0
+#define EJ1X8_GPIO_CTRL_OUT_HIGH			0x1
+#define EJ1X8_GPIO_CTRL_IN				0x2
+#define EJ1X8_GPIO_CTRL_MASK				0x3
+
+#define EJ1X8_GPIO_MODE					0x18005022
+#define EJ1X8_GPIO_MODE_READ_WRITE_ALL_MASK		GENMASK(23, 16)
+#define EJ1X8_GPIO_MODE_DISABLE				0x0
+#define EJ1X8_GPIO_MODE_ENABLE				0x1
+#define EJ1X8_GPIO_MODE_MASK				0x3
+
+struct etron_xhci_pci_priv {
+	spinlock_t			lock;
+	struct pci_dev			*pci_dev;
+	struct gpio_chip		chip;
+};
+
+static u8 etron_xhci_pci_gpio_shift(unsigned int gpio, u8 mask)
+{
+	return (gpio * fls(mask));
+}
+
+static u8 etron_xhci_pci_gpio_mask(unsigned int gpio, u8 mask)
+{
+	return mask << etron_xhci_pci_gpio_shift(gpio, mask);
+}
+
+static int etron_xhci_pci_gpio_read(struct gpio_chip *gc, u32 reg, u32 *value)
+{
+	struct etron_xhci_pci_priv *etron_priv = gpiochip_get_data(gc);
+	int err;
+
+	err = pci_write_config_dword(etron_priv->pci_dev, EJ1X8_GPIO_WRITE, reg);
+	if (err) {
+		dev_err(gc->parent, "Failed to select 0x%08x register\n", reg);
+		return err;
+	}
+
+	usleep_range(1000, 10000);
+
+	err = pci_read_config_dword(etron_priv->pci_dev, EJ1X8_GPIO_READ, value);
+	if (err) {
+		dev_err(gc->parent, "Failed to read 0x%08x register\n", reg);
+		return err;
+	}
+
+	return 0;
+}
+
+static int etron_xhci_pci_gpio_write(struct gpio_chip *gc, u32 reg, u32 value)
+{
+	struct etron_xhci_pci_priv *etron_priv = gpiochip_get_data(gc);
+	int err;
+
+	err = pci_write_config_dword(etron_priv->pci_dev, EJ1X8_GPIO_WRITE,
+				     reg | value | BIT(24));
+	if (err) {
+		dev_err(gc->parent, "Failed to write 0x%08x register\n", reg);
+		return err;
+	}
+
+	usleep_range(1000, 10000);
+
+	return 0;
+}
+
+static int etron_xhci_pci_gpio_config(struct gpio_chip *gc, unsigned int gpio,
+				      u8 mode, u8 ctrl)
+{
+	struct etron_xhci_pci_priv *etron_priv = gpiochip_get_data(gc);
+	u8 all_gpio_ctrl, all_gpio_mode;
+	u32 temp;
+	int err;
+
+	spin_lock(&etron_priv->lock);
+
+	err = pci_read_config_dword(etron_priv->pci_dev, EJ1X8_GPIO_INIT, &temp);
+	if (err) {
+		dev_err(gc->parent, "Failed to read INIT register\n");
+		return err;
+	}
+
+	err = pci_write_config_dword(etron_priv->pci_dev, EJ1X8_GPIO_INIT,
+				     temp | 0x1);
+	if (err) {
+		dev_err(gc->parent, "Failed to write INIT register\n");
+		return err;
+	}
+
+	err = etron_xhci_pci_gpio_read(gc, EJ1X8_GPIO_CTRL, &temp);
+	if (err)
+		goto err_unlock;
+
+	all_gpio_ctrl = FIELD_GET(EJ1X8_GPIO_CTRL_READ_ALL_MASK, temp);
+	all_gpio_ctrl &= ~etron_xhci_pci_gpio_mask(gpio, EJ1X8_GPIO_CTRL_MASK);
+	all_gpio_ctrl |= ctrl << etron_xhci_pci_gpio_shift(gpio,
+							   EJ1X8_GPIO_CTRL_MASK);
+
+	err = etron_xhci_pci_gpio_read(gc, EJ1X8_GPIO_MODE, &temp);
+	if (err)
+		goto err_unlock;
+
+	all_gpio_mode = FIELD_GET(EJ1X8_GPIO_MODE_READ_WRITE_ALL_MASK, temp);
+	all_gpio_mode &= ~etron_xhci_pci_gpio_mask(gpio, EJ1X8_GPIO_MODE_MASK);
+	all_gpio_mode |= mode << etron_xhci_pci_gpio_shift(gpio,
+							   EJ1X8_GPIO_MODE_MASK);
+
+	err = etron_xhci_pci_gpio_write(gc, EJ1X8_GPIO_CTRL,
+			       FIELD_PREP(EJ1X8_GPIO_CTRL_WRITE_ALL_MASK,
+					  all_gpio_ctrl));
+	if (err)
+		goto err_unlock;
+
+	err = etron_xhci_pci_gpio_write(gc, EJ1X8_GPIO_MODE,
+			       FIELD_PREP(EJ1X8_GPIO_MODE_READ_WRITE_ALL_MASK,
+					  all_gpio_mode));
+	if (err)
+		goto err_unlock;
+
+	spin_unlock(&etron_priv->lock);
+
+	return 0;
+
+err_unlock:
+	spin_unlock(&etron_priv->lock);
+	return err;
+}
+
+static int etron_xhci_pci_gpio_get_mode(struct gpio_chip *gc, unsigned int gpio,
+					u8 *mode)
+{
+	struct etron_xhci_pci_priv *etron_priv = gpiochip_get_data(gc);
+	u32 temp, all_gpio_mode;
+	int err;
+
+	spin_lock(&etron_priv->lock);
+	err = etron_xhci_pci_gpio_read(gc, EJ1X8_GPIO_MODE, &temp);
+	spin_unlock(&etron_priv->lock);
+
+	if (err)
+		return err;
+
+	all_gpio_mode = FIELD_GET(EJ1X8_GPIO_MODE_READ_WRITE_ALL_MASK, temp);
+	*mode = all_gpio_mode >> etron_xhci_pci_gpio_shift(gpio,
+							   EJ1X8_GPIO_MODE_MASK);
+	*mode &= EJ1X8_GPIO_MODE_MASK;
+
+	return 0;
+}
+
+static void etron_xhci_pci_gpio_free(struct gpio_chip *gc, unsigned int gpio)
+{
+	etron_xhci_pci_gpio_config(gc, gpio, EJ1X8_GPIO_MODE_DISABLE,
+				   EJ1X8_GPIO_CTRL_IN);
+}
+
+static int etron_xhci_pci_gpio_get_direction(struct gpio_chip *gc,
+					     unsigned int gpio)
+{
+	u8 mode;
+	int err;
+
+	err = etron_xhci_pci_gpio_get_mode(gc, gpio, &mode);
+	if (err)
+		return err;
+
+	switch (mode) {
+	case EJ1X8_GPIO_CTRL_IN:
+		return GPIO_LINE_DIRECTION_IN;
+
+	case EJ1X8_GPIO_CTRL_OUT_HIGH:
+	case EJ1X8_GPIO_CTRL_OUT_LOW:
+		return GPIO_LINE_DIRECTION_OUT;
+
+	default:
+		return -EINVAL;
+	}
+}
+
+static int etron_xhci_pci_gpio_direction_output(struct gpio_chip *gc,
+						unsigned int gpio, int value)
+{
+	u8 gpio_ctrl;
+
+	if (value)
+		gpio_ctrl = EJ1X8_GPIO_CTRL_OUT_HIGH;
+	else
+		gpio_ctrl = EJ1X8_GPIO_CTRL_OUT_LOW;
+
+	return etron_xhci_pci_gpio_config(gc, gpio, EJ1X8_GPIO_MODE_ENABLE,
+					  gpio_ctrl);
+}
+
+static int etron_xhci_pci_gpio_get_value(struct gpio_chip *gc, unsigned int gpio)
+{
+	u8 mode;
+	int err;
+
+	err = etron_xhci_pci_gpio_get_mode(gc, gpio, &mode);
+	if (err)
+		return err;
+
+	switch (mode) {
+	case EJ1X8_GPIO_CTRL_OUT_HIGH:
+		return 1;
+
+	case EJ1X8_GPIO_CTRL_OUT_LOW:
+		return 0;
+
+	default:
+		return -EINVAL;
+	}
+}
+
+static void etron_xhci_pci_gpio_set_value(struct gpio_chip *gc,
+					  unsigned int gpio, int value)
+{
+	etron_xhci_pci_gpio_direction_output(gc, gpio, value);
+}
+
+int etron_xhci_pci_probe(struct pci_dev *pci_dev)
+{
+	struct etron_xhci_pci_priv *etron_priv;
+	struct device *dev = &pci_dev->dev;
+	int err;
+
+	if (!device_property_read_bool(dev, "gpio-controller"))
+		return 0;
+
+	etron_priv = devm_kzalloc(dev, sizeof(*etron_priv), GFP_KERNEL);
+	if (!etron_priv)
+		return -ENOMEM;
+
+	spin_lock_init(&etron_priv->lock);
+	etron_priv->pci_dev = pci_dev;
+
+	/* TODO: input mode is supported by the hardware but not the driver */
+	etron_priv->chip.label = dev_name(dev);
+	etron_priv->chip.owner = THIS_MODULE;
+	etron_priv->chip.parent = dev;
+	etron_priv->chip.of_node = dev->of_node;
+	etron_priv->chip.free = etron_xhci_pci_gpio_free;
+	etron_priv->chip.get_direction = etron_xhci_pci_gpio_get_direction;
+	etron_priv->chip.direction_output = etron_xhci_pci_gpio_direction_output;
+	etron_priv->chip.get = etron_xhci_pci_gpio_get_value;
+	etron_priv->chip.set = etron_xhci_pci_gpio_set_value;
+	etron_priv->chip.base = -1;
+	etron_priv->chip.ngpio = 4;
+
+	err = devm_gpiochip_add_data(dev, &etron_priv->chip, etron_priv);
+	if (err) {
+		dev_warn(dev, "Failed to register GPIO device: %d\n", err);
+		return err;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(etron_xhci_pci_probe);
+
+MODULE_SOFTDEP("pre: xhci-pci");
+MODULE_AUTHOR("Martin Blumenstingl <martin.blumenstingl@googlemail.com>");
+MODULE_DESCRIPTION("Etron Technology Inc. EJ168/EJ188/EJ198 GPIO driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 79d679b3e076..7d924117e76e 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -270,6 +270,7 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		xhci->quirks |= XHCI_RESET_ON_RESUME;
 		xhci->quirks |= XHCI_TRUST_TX_LENGTH;
 		xhci->quirks |= XHCI_BROKEN_STREAMS;
+		xhci->quirks |= XHCI_ETRON_GPIO_QUIRK;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_RENESAS &&
 	    pdev->device == 0x0014) {
@@ -455,8 +456,16 @@ static int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	if (xhci->quirks & XHCI_DEFAULT_PM_RUNTIME_ALLOW)
 		pm_runtime_allow(&dev->dev);
 
+	if (xhci->quirks & XHCI_ETRON_GPIO_QUIRK) {
+		retval = etron_xhci_pci_probe(dev);
+		if (retval)
+			goto remove_usb3_hcd;
+	}
+
 	return 0;
 
+remove_usb3_hcd:
+	usb_remove_hcd(xhci->shared_hcd);
 put_usb3_hcd:
 	usb_put_hcd(xhci->shared_hcd);
 dealloc_usb2_hcd:
diff --git a/drivers/usb/host/xhci-pci.h b/drivers/usb/host/xhci-pci.h
index cb9a8f331a44..ec435b5b5728 100644
--- a/drivers/usb/host/xhci-pci.h
+++ b/drivers/usb/host/xhci-pci.h
@@ -4,6 +4,15 @@
 #ifndef XHCI_PCI_H
 #define XHCI_PCI_H
 
+#if IS_REACHABLE(CONFIG_USB_XHCI_PCI_ETRON)
+int etron_xhci_pci_probe(struct pci_dev *pci_dev);
+#else
+static inline int etron_xhci_pci_probe(struct pci_dev *pci_dev)
+{
+	return 0;
+}
+#endif
+
 #if IS_ENABLED(CONFIG_USB_XHCI_PCI_RENESAS)
 int renesas_xhci_check_request_fw(struct pci_dev *dev,
 				  const struct pci_device_id *id);
diff --git a/include/dt-bindings/clock/meson8b-clkc.h b/include/dt-bindings/clock/meson8b-clkc.h
index 78aa07fd7cc0..b5232cff19e4 100644
--- a/include/dt-bindings/clock/meson8b-clkc.h
+++ b/include/dt-bindings/clock/meson8b-clkc.h
@@ -124,5 +124,6 @@
 #define CLKID_CTS_AMCLK		209
 #define CLKID_CTS_MCLK_I958	212
 #define CLKID_CTS_I958		213
+#define CLKID_ETH_CLK		221
 
 #endif /* __MESON8B_CLKC_H */
diff --git a/include/dt-bindings/net/realtek-rtl8211f.h b/include/dt-bindings/net/realtek-rtl8211f.h
new file mode 100644
index 000000000000..80eb78219697
--- /dev/null
+++ b/include/dt-bindings/net/realtek-rtl8211f.h
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause) */
+
+#ifndef _DT_BINDINGS_REALTEK_RTL8211F_H
+#define _DT_BINDINGS_REALTEK_RTL8211F_H
+
+#define RTL8211F_LED_LINK_10			(1 << 0)
+#define RTL8211F_LED_LINK_100			(1 << 1)
+#define RTL8211F_LED_LINK_1000			(1 << 2)
+#define RTL8211F_LED_ACTIVITY			(1 << 3)
+#define RTL8211F_LED_EEE			(1 << 4)
+
+#endif /* _DT_BINDINGS_REALTEK_RTL8211F_H */
diff --git a/include/linux/firmware/meson/meson_mx_trustzone.h b/include/linux/firmware/meson/meson_mx_trustzone.h
new file mode 100644
index 000000000000..947463050782
--- /dev/null
+++ b/include/linux/firmware/meson/meson_mx_trustzone.h
@@ -0,0 +1,37 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2021 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ */
+
+#include <linux/errno.h>
+#include <linux/types.h>
+
+#if defined(CONFIG_ARM) && defined(CONFIG_ARCH_MESON)
+
+bool meson_mx_trustzone_firmware_available(void);
+
+int meson_mx_trustzone_firmware_efuse_read(unsigned int offset,
+					   unsigned int bytes, void *buf);
+
+u32 meson_mx_trustzone_read_soc_rev1(void);
+
+#else
+
+static inline bool meson_mx_trustzone_firmware_available(void)
+{
+	return false;
+}
+
+static inline int meson_mx_trustzone_firmware_efuse_read(unsigned int offset,
+							 unsigned int bytes,
+							 void *buf)
+{
+	return -EINVAL;
+}
+
+static inline u32 meson_mx_trustzone_read_soc_rev1(void)
+{
+	return 0;
+}
+
+#endif
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 0f9d71490075..fb24e6f86951 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -79,6 +79,7 @@ config SND_SOC_ALL_CODECS
 	imply SND_SOC_CS4271_SPI
 	imply SND_SOC_CS42XX8_I2C
 	imply SND_SOC_CS43130
+	imply SND_SOC_CS4334
 	imply SND_SOC_CS4341
 	imply SND_SOC_CS4349
 	imply SND_SOC_CS47L15
@@ -782,6 +783,9 @@ config SND_SOC_CS43130
 	tristate "Cirrus Logic CS43130 CODEC"
 	depends on I2C
 
+config SND_SOC_CS4334
+	tristate "Cirrus Logic CS4334 CODEC"
+
 config SND_SOC_CS4341
 	tristate "Cirrus Logic CS4341 CODEC"
 	depends on SND_SOC_I2C_AND_SPI
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 71d3ce5867e4..61df70425e67 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -81,6 +81,7 @@ snd-soc-cs4271-spi-objs := cs4271-spi.o
 snd-soc-cs42xx8-objs := cs42xx8.o
 snd-soc-cs42xx8-i2c-objs := cs42xx8-i2c.o
 snd-soc-cs43130-objs := cs43130.o
+snd-soc-cs4334-objs := cs4334.o
 snd-soc-cs4341-objs := cs4341.o
 snd-soc-cs4349-objs := cs4349.o
 snd-soc-cs47l15-objs := cs47l15.o
@@ -442,6 +443,7 @@ obj-$(CONFIG_SND_SOC_CS4271_SPI)	+= snd-soc-cs4271-spi.o
 obj-$(CONFIG_SND_SOC_CS42XX8)	+= snd-soc-cs42xx8.o
 obj-$(CONFIG_SND_SOC_CS42XX8_I2C) += snd-soc-cs42xx8-i2c.o
 obj-$(CONFIG_SND_SOC_CS43130)   += snd-soc-cs43130.o
+obj-$(CONFIG_SND_SOC_CS4334)	+= snd-soc-cs4334.o
 obj-$(CONFIG_SND_SOC_CS4341)	+= snd-soc-cs4341.o
 obj-$(CONFIG_SND_SOC_CS4349)	+= snd-soc-cs4349.o
 obj-$(CONFIG_SND_SOC_CS47L24)	+= snd-soc-cs47l24.o
diff --git a/sound/soc/codecs/cs4334.c b/sound/soc/codecs/cs4334.c
new file mode 100644
index 000000000000..7f0c1abe7279
--- /dev/null
+++ b/sound/soc/codecs/cs4334.c
@@ -0,0 +1,197 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Driver for the Cirrus CS4334 - or functionally compatible - I2S Stereo DACs.
+ *
+ * Copyright (C) 2021 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ *
+ * Based on es7134.c:
+ *   Copyright (c) 2017 BayLibre, SAS.
+ *   Author: Jerome Brunet <jbrunet@baylibre.com>
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <sound/soc.h>
+
+struct cs4334_clock_mode {
+	unsigned int rate_min;
+	unsigned int rate_max;
+	unsigned int *mclk_fs;
+	unsigned int mclk_fs_num;
+};
+
+struct cs4334_chip {
+	struct snd_soc_dai_driver *dai_drv;
+	const struct cs4334_clock_mode *modes;
+	unsigned int mode_num;
+};
+
+struct cs4334_data {
+	unsigned int mclk;
+	const struct cs4334_chip *chip;
+};
+
+static int cs4334_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *params,
+			    struct snd_soc_dai *dai)
+{
+	struct cs4334_data *priv = snd_soc_dai_get_drvdata(dai);
+	unsigned int mfs, rate = params_rate(params);
+	int i, j;
+
+	/* mclk has not been provided, assume it is OK */
+	if (!priv->mclk)
+		return 0;
+
+	mfs = priv->mclk / rate;
+
+	for (i = 0; i < priv->chip->mode_num; i++) {
+		const struct cs4334_clock_mode *mode = &priv->chip->modes[i];
+
+		if (rate < mode->rate_min || rate > mode->rate_max)
+			continue;
+
+		for (j = 0; j < mode->mclk_fs_num; j++) {
+			if (mode->mclk_fs[j] == mfs)
+				return 0;
+		}
+
+		dev_err(dai->dev, "unsupported mclk_fs %u for rate %u\n",
+			mfs, rate);
+		return -EINVAL;
+	}
+
+	/* should not happen */
+	dev_err(dai->dev, "unsupported rate: %u\n", rate);
+	return -EINVAL;
+}
+
+static int cs4334_set_sysclk(struct snd_soc_dai *dai, int clk_id,
+			     unsigned int freq, int dir)
+{
+	struct cs4334_data *priv = snd_soc_dai_get_drvdata(dai);
+
+	if (dir == SND_SOC_CLOCK_IN && clk_id == 0) {
+		priv->mclk = freq;
+		return 0;
+	}
+
+	return -ENOTSUPP;
+}
+
+static int cs4334_set_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
+{
+	fmt &= (SND_SOC_DAIFMT_FORMAT_MASK | SND_SOC_DAIFMT_INV_MASK |
+		SND_SOC_DAIFMT_MASTER_MASK);
+
+	if (fmt != (SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		    SND_SOC_DAIFMT_CBC_CFC)) {
+		dev_err(codec_dai->dev, "Invalid DAI format\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops cs4334_dai_ops = {
+	.set_fmt = cs4334_set_fmt,
+	.hw_params = cs4334_hw_params,
+	.set_sysclk = cs4334_set_sysclk,
+};
+
+static struct snd_soc_dai_driver cs4334_dai = {
+	.name = "cs4334-hifi",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_32000 |
+			 SNDRV_PCM_RATE_44100 |
+			 SNDRV_PCM_RATE_48000 |
+			 SNDRV_PCM_RATE_64000 |
+			 SNDRV_PCM_RATE_88200 |
+			 SNDRV_PCM_RATE_96000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE |
+			   SNDRV_PCM_FMTBIT_S24_LE,
+	},
+	.ops = &cs4334_dai_ops,
+};
+
+static const struct cs4334_clock_mode cs4334_modes[] = {
+	{
+		/* Base Rate Mode (BRM) */
+		.rate_min = 32000,
+		.rate_max = 48000,
+		.mclk_fs = (unsigned int[]) { 256, 384, 512 },
+		.mclk_fs_num = 3,
+	},
+	{
+		/* High Rate Mode (HRM) */
+		.rate_min = 32000,
+		.rate_max = 96000,
+		.mclk_fs = (unsigned int[]) { 128, 192 },
+		.mclk_fs_num = 2,
+	},
+};
+
+static const struct cs4334_chip cs4334_chip = {
+	.dai_drv = &cs4334_dai,
+	.modes = cs4334_modes,
+	.mode_num = ARRAY_SIZE(cs4334_modes),
+};
+
+static const struct snd_soc_dapm_widget cs4334_dapm_widgets[] = {
+	SND_SOC_DAPM_REGULATOR_SUPPLY("VA", 0, 0),
+};
+
+static const struct snd_soc_component_driver cs4334_component_driver = {
+	.dapm_widgets		= cs4334_dapm_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(cs4334_dapm_widgets),
+	.idle_bias_on		= 1,
+	.use_pmdown_time	= 1,
+	.endianness		= 1,
+};
+
+static int cs4334_probe(struct platform_device *pdev)
+{
+	struct cs4334_data *priv;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, priv);
+
+	priv->chip = of_device_get_match_data(&pdev->dev);
+	if (!priv->chip) {
+		dev_err(&pdev->dev, "Failed to find OF match data\n");
+		return -ENODEV;
+	}
+
+	return devm_snd_soc_register_component(&pdev->dev,
+					       &cs4334_component_driver,
+					       priv->chip->dai_drv, 1);
+}
+
+static const struct of_device_id cs4334_of_match[] = {
+	{ .compatible = "cirrus,cs4334", .data = &cs4334_chip },
+	{ .compatible = "mxtronics,mxt8234", .data = &cs4334_chip },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, cs4334_of_match);
+
+static struct platform_driver cs4334_codec_driver = {
+	.probe = cs4334_probe,
+	.driver = {
+		.name = "cs4334-codec",
+		.of_match_table = cs4334_of_match,
+	},
+};
+
+module_platform_driver(cs4334_codec_driver);
+
+MODULE_DESCRIPTION("ASoC Cirrus CS4334 codec driver");
+MODULE_AUTHOR("Martin Blumenstingl <martin.blumenstingl@googlemail.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index fd095ff9fc8b..2712b712cf9d 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1664,6 +1664,7 @@ struct xhci_hcd {
 #define XHCI_WRITE_64_HI_LO	BIT_ULL(47)
 #define XHCI_CDNS_SCTX_QUIRK	BIT_ULL(48)
 #define XHCI_LIMIT_ENDPOINT_INTERVAL_9 BIT_ULL(49)
+#define XHCI_ETRON_GPIO_QUIRK	BIT_ULL(50)
 
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
diff --git a/drivers/gpu/drm/meson/meson_drv.c b/drivers/gpu/drm/meson/meson_drv.c
index 5606a248f4c4..45b043cb0a22 100644
--- a/drivers/gpu/drm/meson/meson_drv.c
+++ b/drivers/gpu/drm/meson/meson_drv.c
@@ -12,6 +12,7 @@
 #include <linux/module.h>
 #include <linux/of_graph.h>
 #include <linux/sys_soc.h>
+#include <linux/phy/phy.h>
 #include <linux/platform_device.h>
 #include <linux/soc/amlogic/meson-canvas.h>
 
@@ -132,30 +133,147 @@ static struct regmap_config meson_regmap_config = {
 	.max_register   = 0x1000,
 };
 
+static int meson_cvbs_dac_phy_init(struct meson_drm *priv)
+{
+	struct platform_device *pdev;
+	const char *platform_id_name;
+
+	priv->cvbs_dac = devm_phy_optional_get(priv->dev, "cvbs-dac");
+	if (IS_ERR(priv->cvbs_dac))
+		return dev_err_probe(priv->dev, PTR_ERR(priv->cvbs_dac),
+				     "Failed to get the 'cvbs-dac' PHY\n");
+	else if (priv->cvbs_dac)
+		return 0;
+
+	switch (priv->compat) {
+	case VPU_COMPATIBLE_GXBB:
+		platform_id_name = "meson-gxbb-cvbs-dac";
+		break;
+	case VPU_COMPATIBLE_GXL:
+	case VPU_COMPATIBLE_GXM:
+		platform_id_name = "meson-gxl-cvbs-dac";
+		break;
+	case VPU_COMPATIBLE_G12A:
+		platform_id_name = "meson-g12a-cvbs-dac";
+		break;
+	default:
+		return dev_err_probe(priv->dev, -EINVAL,
+				     "No CVBS DAC platform ID found\n");
+	}
+
+	pdev = platform_device_register_data(priv->dev, platform_id_name,
+					     PLATFORM_DEVID_AUTO, NULL, 0);
+	if (IS_ERR(pdev))
+		return dev_err_probe(priv->dev, PTR_ERR(pdev),
+				     "Failed to register fallback CVBS DAC PHY platform device\n");
+
+	priv->cvbs_dac = platform_get_drvdata(pdev);
+	if (IS_ERR(priv->cvbs_dac)) {
+		platform_device_unregister(pdev);
+		return dev_err_probe(priv->dev, PTR_ERR(priv->cvbs_dac),
+				     "Failed to get the 'cvbs-dac' PHY from it's platform device\n");
+	}
+
+	dev_warn(priv->dev, "Using fallback for old .dtbs without CVBS DAC\n");
+
+	priv->cvbs_dac_pdev = pdev;
+
+	return 0;
+}
+
+static void meson_cvbs_dac_phy_exit(struct meson_drm *priv)
+{
+	platform_device_unregister(priv->cvbs_dac_pdev);
+}
+
 static void meson_vpu_init(struct meson_drm *priv)
 {
-	u32 value;
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2)) {
+		writel(0x0, priv->io_base + _REG(VPU_MEM_PD_REG0));
+		writel(0x0, priv->io_base + _REG(VPU_MEM_PD_REG1));
+	} else {
+		u32 value;
+
+		/*
+		* Slave dc0 and dc5 connected to master port 1.
+		* By default other slaves are connected to master port 0.
+		*/
+		value = VPU_RDARB_SLAVE_TO_MASTER_PORT(0, 1) |
+			VPU_RDARB_SLAVE_TO_MASTER_PORT(5, 1);
+		writel_relaxed(value,
+			       priv->io_base + _REG(VPU_RDARB_MODE_L1C1));
+
+		/* Slave dc0 connected to master port 1 */
+		value = VPU_RDARB_SLAVE_TO_MASTER_PORT(0, 1);
+		writel_relaxed(value,
+			       priv->io_base + _REG(VPU_RDARB_MODE_L1C2));
+
+		/* Slave dc4 and dc7 connected to master port 1 */
+		value = VPU_RDARB_SLAVE_TO_MASTER_PORT(4, 1) |
+			VPU_RDARB_SLAVE_TO_MASTER_PORT(7, 1);
+		writel_relaxed(value,
+			       priv->io_base + _REG(VPU_RDARB_MODE_L2C1));
+
+		/* Slave dc1 connected to master port 1 */
+		value = VPU_RDARB_SLAVE_TO_MASTER_PORT(1, 1);
+		writel_relaxed(value,
+			       priv->io_base + _REG(VPU_WRARB_MODE_L2C1));
+	}
+}
+
+static int meson_video_clock_init(struct meson_drm *priv)
+{
+	int ret;
+
+	ret = clk_bulk_prepare(VPU_VID_CLK_NUM, priv->vid_clks);
+	if (ret)
+		return dev_err_probe(priv->dev, ret,
+				     "Failed to prepare the video clocks\n");
+
+	ret = clk_bulk_prepare(priv->num_intr_clks, priv->intr_clks);
+	if (ret)
+		return dev_err_probe(priv->dev, ret,
+				     "Failed to prepare the interrupt clocks\n");
+
+	return 0;
+}
+
+static void meson_video_clock_exit(struct meson_drm *priv)
+{
+	if (priv->clk_dac_enabled)
+		clk_disable(priv->clk_dac);
+
+	if (priv->clk_venc_enabled)
+		clk_disable(priv->clk_venc);
+
+	clk_bulk_unprepare(priv->num_intr_clks, priv->intr_clks);
+	clk_bulk_unprepare(VPU_VID_CLK_NUM, priv->vid_clks);
+}
+
+static void meson_fbdev_setup(struct meson_drm *priv)
+{
+	unsigned int preferred_bpp;
 
 	/*
-	 * Slave dc0 and dc5 connected to master port 1.
-	 * By default other slaves are connected to master port 0.
+	 * All SoC generations before GXBB don't have a way to configure the
+	 * alpha value for DRM_FORMAT_XRGB8888 and DRM_FORMAT_XBGR8888. These
+	 * formats have an X component instead of an alpha component. On
+	 * Meson8/8b/8m2 there is no way to configure the alpha value to use
+	 * instead of the X component. This results in the fact that the
+	 * formats with X component are only supported on GXBB and newer. Use
+	 * 24 bits per pixel and therefore DRM_FORMAT_RGB888 to get a
+	 * working framebuffer console.
 	 */
-	value = VPU_RDARB_SLAVE_TO_MASTER_PORT(0, 1) |
-		VPU_RDARB_SLAVE_TO_MASTER_PORT(5, 1);
-	writel_relaxed(value, priv->io_base + _REG(VPU_RDARB_MODE_L1C1));
-
-	/* Slave dc0 connected to master port 1 */
-	value = VPU_RDARB_SLAVE_TO_MASTER_PORT(0, 1);
-	writel_relaxed(value, priv->io_base + _REG(VPU_RDARB_MODE_L1C2));
-
-	/* Slave dc4 and dc7 connected to master port 1 */
-	value = VPU_RDARB_SLAVE_TO_MASTER_PORT(4, 1) |
-		VPU_RDARB_SLAVE_TO_MASTER_PORT(7, 1);
-	writel_relaxed(value, priv->io_base + _REG(VPU_RDARB_MODE_L2C1));
-
-	/* Slave dc1 connected to master port 1 */
-	value = VPU_RDARB_SLAVE_TO_MASTER_PORT(1, 1);
-	writel_relaxed(value, priv->io_base + _REG(VPU_WRARB_MODE_L2C1));
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2))
+		preferred_bpp = 24;
+	else
+		preferred_bpp = 32;
+
+	drm_fbdev_generic_setup(priv->drm, preferred_bpp);
 }
 
 struct meson_drm_soc_attr {
@@ -164,13 +282,29 @@ struct meson_drm_soc_attr {
 };
 
 static const struct meson_drm_soc_attr meson_drm_soc_attrs[] = {
-	/* S805X/S805Y HDMI PLL won't lock for HDMI PHY freq > 1,65GHz */
+	/* The maximum frequency of HDMI PHY on Meson8 and Meson8m2 is ~3GHz */
+	{
+		.limits = {
+			.max_hdmi_phy_freq = 2976000,
+		},
+		.attrs = (const struct soc_device_attribute []) {
+			{ .soc_id = "Meson8 (S802)", },
+			{ .soc_id = "Meson8m2 (S812)", },
+			{ /* sentinel */ },
+		}
+	},
+	/*
+	 * GXL S805X/S805Y HDMI PLL won't lock for HDMI PHY freq > 1,65GHz.
+	 * Meson8b (S805) only supports "1200p@60 max resolution" according to
+	 * the public datasheet.
+	 */
 	{
 		.limits = {
 			.max_hdmi_phy_freq = 1650000000,
 		},
 		.attrs = (const struct soc_device_attribute []) {
 			{ .soc_id = "GXL (S805*)", },
+			{ .soc_id = "Meson8b (S805)", },
 			{ /* sentinel */ }
 		}
 	},
@@ -211,58 +345,118 @@ static int meson_drv_bind_master(struct device *dev, bool has_components)
 	priv->compat = match->compat;
 	priv->afbcd.ops = match->afbcd_ops;
 
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8B) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_M8M2)) {
+		priv->vid_pll_resets[VPU_RESET_VID_PLL_PRE].id = "vid_pll_pre";
+		priv->vid_pll_resets[VPU_RESET_VID_PLL_POST].id = "vid_pll_post";
+		priv->vid_pll_resets[VPU_RESET_VID_PLL_SOFT_PRE].id = "vid_pll_soft_pre";
+		priv->vid_pll_resets[VPU_RESET_VID_PLL_SOFT_POST].id = "vid_pll_soft_post";
+
+		ret = devm_reset_control_bulk_get_exclusive(dev,
+							    VPU_RESET_VID_PLL_NUM,
+							    priv->vid_pll_resets);
+		if (ret)
+			goto free_drm;
+
+		priv->intr_clks[0].id = "vpu_intr";
+		priv->intr_clks[1].id = "hdmi_intr_sync";
+		priv->intr_clks[2].id = "venci_int";
+		priv->num_intr_clks = 3;
+
+		ret = devm_clk_bulk_get(dev, priv->num_intr_clks,
+					priv->intr_clks);
+		if (ret)
+			goto free_drm;
+
+		priv->vid_clks[VPU_VID_CLK_TMDS].id = "tmds";
+		priv->vid_clks[VPU_VID_CLK_HDMI_TX_PIXEL].id = "hdmi_tx_pixel";
+		priv->vid_clks[VPU_VID_CLK_CTS_ENCP].id = "cts_encp";
+		priv->vid_clks[VPU_VID_CLK_CTS_ENCI].id = "cts_enci";
+		priv->vid_clks[VPU_VID_CLK_CTS_ENCT].id = "cts_enct";
+		priv->vid_clks[VPU_VID_CLK_CTS_ENCL].id = "cts_encl";
+		priv->vid_clks[VPU_VID_CLK_CTS_VDAC0].id = "cts_vdac0";
+
+		ret = devm_clk_bulk_get(dev, VPU_VID_CLK_NUM, priv->vid_clks);
+		if (ret)
+			goto free_drm;
+	} else {
+		priv->intr_clks[0].id = "vpu_intr";
+		priv->num_intr_clks = 1;
+
+		ret = devm_clk_bulk_get_optional(dev, priv->num_intr_clks,
+						 priv->intr_clks);
+		if (ret)
+			goto free_drm;
+	}
+
+	ret = meson_video_clock_init(priv);
+	if (ret)
+		goto free_drm;
+
 	regs = devm_platform_ioremap_resource_byname(pdev, "vpu");
 	if (IS_ERR(regs)) {
 		ret = PTR_ERR(regs);
-		goto free_drm;
+		goto video_clock_exit;
 	}
 
 	priv->io_base = regs;
 
+	/*
+	 * The HHI resource is optional because it contains the clocks and CVBS
+	 * encoder registers. These are managed by separate drivers though.
+	 */
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "hhi");
-	if (!res) {
-		ret = -EINVAL;
-		goto free_drm;
-	}
-	/* Simply ioremap since it may be a shared register zone */
-	regs = devm_ioremap(dev, res->start, resource_size(res));
-	if (!regs) {
-		ret = -EADDRNOTAVAIL;
-		goto free_drm;
-	}
-
-	priv->hhi = devm_regmap_init_mmio(dev, regs,
-					  &meson_regmap_config);
-	if (IS_ERR(priv->hhi)) {
-		dev_err(&pdev->dev, "Couldn't create the HHI regmap\n");
-		ret = PTR_ERR(priv->hhi);
-		goto free_drm;
-	}
+	if (res) {
+		/* Simply ioremap since it may be a shared register zone */
+		regs = devm_ioremap(dev, res->start, resource_size(res));
+		if (!regs) {
+			ret = -EADDRNOTAVAIL;
+			goto video_clock_exit;
+		}
+		priv->hhi = devm_regmap_init_mmio(dev, regs,
+						  &meson_regmap_config);
+		if (IS_ERR(priv->hhi)) {
+			dev_err(&pdev->dev,
+				"Couldn't create the HHI regmap\n");
+			ret = PTR_ERR(priv->hhi);
+			goto video_clock_exit;
+		}
+ 	}
 
 	priv->canvas = meson_canvas_get(dev);
 	if (IS_ERR(priv->canvas)) {
 		ret = PTR_ERR(priv->canvas);
-		goto free_drm;
+		goto video_clock_exit;
 	}
 
 	ret = meson_canvas_alloc(priv->canvas, &priv->canvas_id_osd1);
 	if (ret)
-		goto free_drm;
+//		goto free_drm;
+		goto video_clock_exit;
 	ret = meson_canvas_alloc(priv->canvas, &priv->canvas_id_vd1_0);
 	if (ret)
-		goto free_canvas_osd1;
+//		goto free_canvas_osd1;
+		goto video_clock_exit;
 	ret = meson_canvas_alloc(priv->canvas, &priv->canvas_id_vd1_1);
 	if (ret)
-		goto free_canvas_vd1_0;
+//		goto free_canvas_vd1_0;
+		goto video_clock_exit;
 	ret = meson_canvas_alloc(priv->canvas, &priv->canvas_id_vd1_2);
 	if (ret)
-		goto free_canvas_vd1_1;
+//		goto free_canvas_vd1_1;
+		goto video_clock_exit;
+
+	ret = meson_cvbs_dac_phy_init(priv);
+	if (ret)
+		goto free_drm;
 
 	priv->vsync_irq = platform_get_irq(pdev, 0);
 
 	ret = drm_vblank_init(drm, 1);
 	if (ret)
-		goto free_canvas_vd1_2;
+//		goto free_canvas_vd1_2;
+		goto exit_cvbs_dac_phy;
 
 	/* Assign limits per soc revision/package */
 	for (i = 0 ; i < ARRAY_SIZE(meson_drm_soc_attrs) ; ++i) {
@@ -278,11 +472,13 @@ static int meson_drv_bind_master(struct device *dev, bool has_components)
 	 */
 	ret = drm_aperture_remove_framebuffers(&meson_driver);
 	if (ret)
-		goto free_canvas_vd1_2;
+//		goto free_canvas_vd1_2;
+		goto exit_cvbs_dac_phy;
 
 	ret = drmm_mode_config_init(drm);
 	if (ret)
-		goto free_canvas_vd1_2;
+//		goto free_canvas_vd1_2;
+		goto exit_cvbs_dac_phy;
 	drm->mode_config.max_width = 3840;
 	drm->mode_config.max_height = 2160;
 	drm->mode_config.funcs = &meson_mode_config_funcs;
@@ -297,7 +493,8 @@ static int meson_drv_bind_master(struct device *dev, bool has_components)
 	if (priv->afbcd.ops) {
 		ret = priv->afbcd.ops->init(priv);
 		if (ret)
-			goto free_canvas_vd1_2;
+//			goto free_canvas_vd1_2;
+			goto exit_cvbs_dac_phy;
 	}
 
 	/* Encoder Initialization */
@@ -312,7 +509,8 @@ static int meson_drv_bind_master(struct device *dev, bool has_components)
 			dev_err(drm->dev, "Couldn't bind all components\n");
 			/* Do not try to unbind */
 			has_components = false;
-			goto exit_afbcd;
+//			goto exit_afbcd;
+			goto exit_cvbs_dac_phy;
 		}
 	}
 
@@ -346,7 +544,7 @@ static int meson_drv_bind_master(struct device *dev, bool has_components)
 	if (ret)
 		goto uninstall_irq;
 
-	drm_fbdev_generic_setup(drm, 32);
+	meson_fbdev_setup(priv);
 
 	return 0;
 
@@ -355,14 +553,18 @@ static int meson_drv_bind_master(struct device *dev, bool has_components)
 exit_afbcd:
 	if (priv->afbcd.ops)
 		priv->afbcd.ops->exit(priv);
-free_canvas_vd1_2:
-	meson_canvas_free(priv->canvas, priv->canvas_id_vd1_2);
-free_canvas_vd1_1:
-	meson_canvas_free(priv->canvas, priv->canvas_id_vd1_1);
-free_canvas_vd1_0:
-	meson_canvas_free(priv->canvas, priv->canvas_id_vd1_0);
-free_canvas_osd1:
-	meson_canvas_free(priv->canvas, priv->canvas_id_osd1);
+// free_canvas_vd1_2:
+// 	meson_canvas_free(priv->canvas, priv->canvas_id_vd1_2);
+// free_canvas_vd1_1:
+// 	meson_canvas_free(priv->canvas, priv->canvas_id_vd1_1);
+// free_canvas_vd1_0:
+// 	meson_canvas_free(priv->canvas, priv->canvas_id_vd1_0);
+// free_canvas_osd1:
+// 	meson_canvas_free(priv->canvas, priv->canvas_id_osd1);
+exit_cvbs_dac_phy:
+	meson_cvbs_dac_phy_exit(priv);
+video_clock_exit:
+	meson_video_clock_exit(priv);
 free_drm:
 	drm_dev_put(drm);
 
@@ -405,6 +607,10 @@ static void meson_drv_unbind(struct device *dev)
 
 	if (priv->afbcd.ops)
 		priv->afbcd.ops->exit(priv);
+
+	meson_cvbs_dac_phy_exit(priv);
+
+	meson_video_clock_exit(priv);
 }
 
 static const struct component_master_ops meson_drv_master_ops = {
@@ -419,6 +625,8 @@ static int __maybe_unused meson_drv_pm_suspend(struct device *dev)
 	if (!priv)
 		return 0;
 
+	// TODO: video clock suspend
+
 	return drm_mode_config_helper_suspend(priv->drm);
 }
 
@@ -429,6 +637,7 @@ static int __maybe_unused meson_drv_pm_resume(struct device *dev)
 	if (!priv)
 		return 0;
 
+	meson_video_clock_init(priv);
 	meson_vpu_init(priv);
 	meson_venc_init(priv);
 	meson_vpp_init(priv);
@@ -511,6 +720,18 @@ static int meson_drv_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static struct meson_drm_match_data meson_drm_m8_data = {
+	.compat = VPU_COMPATIBLE_M8,
+};
+
+static struct meson_drm_match_data meson_drm_m8b_data = {
+	.compat = VPU_COMPATIBLE_M8B,
+};
+
+static struct meson_drm_match_data meson_drm_m8m2_data = {
+	.compat = VPU_COMPATIBLE_M8M2,
+};
+
 static struct meson_drm_match_data meson_drm_gxbb_data = {
 	.compat = VPU_COMPATIBLE_GXBB,
 };
@@ -530,6 +751,12 @@ static struct meson_drm_match_data meson_drm_g12a_data = {
 };
 
 static const struct of_device_id dt_match[] = {
+	{ .compatible = "amlogic,meson8-vpu",
+	  .data       = (void *)&meson_drm_m8_data },
+	{ .compatible = "amlogic,meson8b-vpu",
+	  .data       = (void *)&meson_drm_m8b_data },
+	{ .compatible = "amlogic,meson8m2-vpu",
+	  .data       = (void *)&meson_drm_m8m2_data },
 	{ .compatible = "amlogic,meson-gxbb-vpu",
 	  .data       = (void *)&meson_drm_gxbb_data },
 	{ .compatible = "amlogic,meson-gxl-vpu",
